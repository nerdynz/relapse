import{defineProperty as t,objectSpread2 as e,objectWithoutProperties as r}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as s}from"../Point.min.mjs";import{iMatrix as o,CENTER as a}from"../constants.min.mjs";import{invertTransform as i}from"../util/misc/matrix.min.mjs";import{resolveOrigin as n}from"../util/misc/resolveOrigin.min.mjs";import{FitContentLayout as u}from"./LayoutStrategies/FitContentLayout.min.mjs";import{LAYOUT_TYPE_OBJECT_MODIFIED as c,LAYOUT_TYPE_OBJECT_MODIFYING as y,LAYOUT_TYPE_INITIALIZATION as g,LAYOUT_TYPE_ADDED as l,LAYOUT_TYPE_REMOVED as b,LAYOUT_TYPE_IMPERATIVE as p}from"./constants.min.mjs";import{classRegistry as h}from"../ClassRegistry.min.mjs";const m=["strategy"],f=["target","strategy","bubbles","prevStrategy"],d="layoutManager";class j{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new u;t(this,"strategy",void 0),this.strategy=e,this._subscriptions=new Map}performLayout(t){const r=e(e({bubbles:!0,strategy:this.strategy},t),{},{prevStrategy:this._prevLayoutStrategy,stopPropagation(){this.bubbles=!1}});this.onBeforeLayout(r);const s=this.getLayoutResult(r);s&&this.commitLayout(r,s),this.onAfterLayout(r,s),this._prevLayoutStrategy=r.strategy}attachHandlers(t,e){const{target:r}=e;return["modified","moving","resizing","rotating","scaling","skewing","changed","modifyPoly"].map((e=>t.on(e,(t=>this.performLayout("modified"===e?{type:c,trigger:e,e:t,target:r}:{type:y,trigger:e,e:t,target:r})))))}subscribe(t,e){this.unsubscribe(t,e);const r=this.attachHandlers(t,e);this._subscriptions.set(t,r)}unsubscribe(t,e){(this._subscriptions.get(t)||[]).forEach((t=>t())),this._subscriptions.delete(t)}unsubscribeTargets(t){t.targets.forEach((e=>this.unsubscribe(e,t)))}subscribeTargets(t){t.targets.forEach((e=>this.subscribe(e,t)))}onBeforeLayout(t){const{target:s,type:o}=t,{canvas:a}=s;if(o===g||o===l?this.subscribeTargets(t):o===b&&this.unsubscribeTargets(t),s.fire("layout:before",{context:t}),a&&a.fire("object:layout:before",{target:s,context:t}),o===p&&t.deep){const o=r(t,m);s.forEachObject((t=>t.layoutManager&&t.layoutManager.performLayout(e(e({},o),{},{bubbles:!1,target:t}))))}}getLayoutResult(t){const{target:e}=t,r=t.strategy.calcLayoutResult(t,e.getObjects());if(!r)return;const a=t.type===g?new s:e.getRelativeCenterPoint(),{center:n,correction:u=new s,relativeCorrection:c=new s}=r,y=a.subtract(n).add(u).transform(t.type===g?o:i(e.calcOwnMatrix()),!0).add(c);return{result:r,prevCenter:a,nextCenter:n,offset:y}}commitLayout(t,e){const{target:r}=t,{result:{size:s},nextCenter:o}=e;var i,u;(r.set({width:s.x,height:s.y}),this.layoutObjects(t,e),t.type===g)?r.set({left:null!==(i=t.x)&&void 0!==i?i:o.x+s.x*n(r.originX),top:null!==(u=t.y)&&void 0!==u?u:o.y+s.y*n(r.originY)}):(r.setPositionByOrigin(o,a,a),r.setCoords(),r.set("dirty",!0))}layoutObjects(t,e){const{target:r}=t;r.forEachObject((s=>{s.group===r&&this.layoutObject(t,e,s)})),t.strategy.shouldLayoutClipPath(t)&&this.layoutObject(t,e,r.clipPath)}layoutObject(t,e,r){let{offset:s}=e;r.set({left:r.left+s.x,top:r.top+s.y})}onAfterLayout(t,s){const{target:o,strategy:a,bubbles:i,prevStrategy:n}=t,u=r(t,f),{canvas:c}=o;o.fire("layout:after",{context:t,result:s}),c&&c.fire("object:layout:after",{context:t,result:s,target:o});const y=o.parent;i&&null!=y&&y.layoutManager&&((u.path||(u.path=[])).push(o),y.layoutManager.performLayout(e(e({},u),{},{target:y}))),o.set("dirty",!0)}dispose(){this._subscriptions.forEach((t=>t.forEach((t=>t())))),this._subscriptions.clear()}toObject(){return{type:d,strategy:this.strategy.constructor.type}}toJSON(){return this.toObject()}}h.setClass(j,d);export{j as LayoutManager};
//# sourceMappingURL=LayoutManager.min.mjs.map
