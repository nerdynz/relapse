import{defineProperty as t,objectSpread2 as r}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as s,ZERO as o}from"../../Point.min.mjs";import{FabricObject as e}from"./Object.min.mjs";import{degreesToRadians as i}from"../../util/misc/radiansDegreesConversion.min.mjs";import{createTranslateMatrix as n,createRotateMatrix as a,multiplyTransformMatrices as l,qrDecompose as c,calcDimensionsMatrix as h}from"../../util/misc/matrix.min.mjs";import{sizeAfterTransform as d}from"../../util/misc/objectTransforms.min.mjs";import{createObjectDefaultControls as C}from"../../controls/commonControls.min.mjs";import{interactiveObjectDefaultValues as u}from"./defaultValues.min.mjs";class f extends e{static getDefaults(){return r(r({},super.getDefaults()),f.ownDefaults)}constructor(t){super(),Object.assign(this,this.constructor.createControls(),f.ownDefaults),this.setOptions(t)}static createControls(){return{controls:C()}}_updateCacheCanvas(){const t=this.canvas;if(this.noScaleCache&&t&&t._currentTransform){const r=t._currentTransform,s=r.target,o=r.action;if(this===s&&o&&o.startsWith("scale"))return!1}return super._updateCacheCanvas()}getActiveControl(){const t=this.__corner;return t?{key:t,control:this.controls[t],coord:this.oCoords[t]}:void 0}findControl(t){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.hasControls||!this.canvas)return;this.__corner=void 0;const s=Object.entries(this.oCoords);for(let o=s.length-1;o>=0;o--){const[e,i]=s[o],n=this.controls[e];if(n.shouldActivate(e,this,t,r?i.touchCorner:i.corner))return this.__corner=e,{key:e,control:n,coord:this.oCoords[e]}}}calcOCoords(){const t=this.getViewportTransform(),r=this.getCenterPoint(),s=n(r.x,r.y),o=a({angle:this.getTotalAngle()-(this.group&&this.flipX?180:0)}),e=l(s,o),i=l(t,e),h=l(i,[1/t[0],0,0,1/t[3],0,0]),d=this.group?c(this.calcTransformMatrix()):void 0;d&&(d.scaleX=Math.abs(d.scaleX),d.scaleY=Math.abs(d.scaleY));const C=this._calculateCurrentDimensions(d),u={};return this.forEachControl(((t,r)=>{const s=t.positionHandler(C,h,this,t);u[r]=Object.assign(s,this._calcCornerCoords(t,s))})),u}_calcCornerCoords(t,r){const s=this.getTotalAngle();return{corner:t.calcCornerCoords(s,this.cornerSize,r.x,r.y,!1,this),touchCorner:t.calcCornerCoords(s,this.touchCornerSize,r.x,r.y,!0,this)}}setCoords(){super.setCoords(),this.canvas&&(this.oCoords=this.calcOCoords())}forEachControl(t){for(const r in this.controls)t(this.controls[r],r,this)}drawSelectionBackground(t){if(!this.selectionBackgroundColor||this.canvas&&this.canvas._activeObject!==this)return;t.save();const r=this.getRelativeCenterPoint(),s=this._calculateCurrentDimensions(),o=this.getViewportTransform();t.translate(r.x,r.y),t.scale(1/o[0],1/o[3]),t.rotate(i(this.angle)),t.fillStyle=this.selectionBackgroundColor,t.fillRect(-s.x/2,-s.y/2,s.x,s.y),t.restore()}strokeBorders(t,r){t.strokeRect(-r.x/2,-r.y/2,r.x,r.y)}_drawBorders(t,s){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const e=r({hasControls:this.hasControls,borderColor:this.borderColor,borderDashArray:this.borderDashArray},o);t.save(),t.strokeStyle=e.borderColor,this._setLineDash(t,e.borderDashArray),this.strokeBorders(t,s),e.hasControls&&this.drawControlsConnectingLines(t,s),t.restore()}_renderControls(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{hasBorders:o,hasControls:e}=this,n=r({hasBorders:o,hasControls:e},s),a=this.getViewportTransform(),h=n.hasBorders,d=n.hasControls,C=l(a,this.calcTransformMatrix()),u=c(C);t.save(),t.translate(u.translateX,u.translateY),t.lineWidth=1*this.borderScaleFactor,this.group===this.parent&&(t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),this.flipX&&(u.angle-=180),t.rotate(i(this.group?u.angle:this.angle)),h&&this.drawBorders(t,u,s),d&&this.drawControls(t,s),t.restore()}drawBorders(t,r,e){let i;if(e&&e.forActiveSelection||this.group){const t=d(this.width,this.height,h(r)),e=this.isStrokeAccountedForInDimensions()?o:(this.strokeUniform?(new s).scalarAdd(this.canvas?this.canvas.getZoom():1):new s(r.scaleX,r.scaleY)).scalarMultiply(this.strokeWidth);i=t.add(e).scalarAdd(this.borderScaleFactor).scalarAdd(2*this.padding)}else i=this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);this._drawBorders(t,i,e)}drawControlsConnectingLines(t,r){let s=!1;t.beginPath(),this.forEachControl(((o,e)=>{o.withConnection&&o.getVisibility(this,e)&&(s=!0,t.moveTo(o.x*r.x,o.y*r.y),t.lineTo(o.x*r.x+o.offsetX,o.y*r.y+o.offsetY))})),s&&t.stroke()}drawControls(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.save();const o=this.getCanvasRetinaScaling(),{cornerStrokeColor:e,cornerDashArray:i,cornerColor:n}=this,a=r({cornerStrokeColor:e,cornerDashArray:i,cornerColor:n},s);t.setTransform(o,0,0,o,0,0),t.strokeStyle=t.fillStyle=a.cornerColor,this.transparentCorners||(t.strokeStyle=a.cornerStrokeColor),this._setLineDash(t,a.cornerDashArray),this.setCoords(),this.forEachControl(((r,s)=>{if(r.getVisibility(this,s)){const o=this.oCoords[s];r.render(t,o.x,o.y,a,this)}})),t.restore()}isControlVisible(t){return this.controls[t]&&this.controls[t].getVisibility(this,t)}setControlVisible(t,r){this._controlsVisibility||(this._controlsVisibility={}),this._controlsVisibility[t]=r}setControlsVisibility(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.entries(t).forEach((t=>{let[r,s]=t;return this.setControlVisible(r,s)}))}clearContextTop(t){if(!this.canvas)return;const r=this.canvas.contextTop;if(!r)return;const s=this.canvas.viewportTransform;r.save(),r.transform(s[0],s[1],s[2],s[3],s[4],s[5]),this.transform(r);const o=this.width+4,e=this.height+4;return r.clearRect(-o/2,-e/2,o,e),t||r.restore(),r}onDeselect(t){return!1}onSelect(t){return!1}shouldStartDragging(t){return!1}onDragStart(t){return!1}canDrop(t){return!1}renderDragSourceEffect(t){}renderDropTargetEffect(t){}}t(f,"ownDefaults",u);export{f as InteractiveFabricObject};
//# sourceMappingURL=InteractiveObject.min.mjs.map
