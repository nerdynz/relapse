{"version":3,"file":"BaseFilter.min.mjs","sources":["../../../src/filters/BaseFilter.ts"],"sourcesContent":["import { getEnv } from '../env';\nimport { createCanvasElement } from '../util/misc/dom';\nimport type {\n  T2DPipelineState,\n  TWebGLAttributeLocationMap,\n  TWebGLPipelineState,\n  TWebGLProgramCacheItem,\n  TWebGLUniformLocationMap,\n} from './typedefs';\nimport { isWebGLPipelineState } from './utils';\nimport {\n  highPsourceCode,\n  identityFragmentShader,\n  vertexSource,\n} from './shaders/baseFilter';\nimport type { Abortable } from '../typedefs';\nimport { FabricError } from '../util/internals/console';\n\nconst regex = new RegExp(highPsourceCode, 'g');\n\nexport class BaseFilter {\n  /**\n   * Filter type\n   * @param {String} type\n   * @default\n   */\n  get type(): string {\n    return (this.constructor as typeof BaseFilter).type;\n  }\n\n  /**\n   * The class type. Used to identify which class this is.\n   * This is used for serialization purposes and internally it can be used\n   * to identify classes. As a developer you could use `instance of Class`\n   * but to avoid importing all the code and blocking tree shaking we try\n   * to avoid doing that.\n   */\n  static type = 'BaseFilter';\n\n  declare static defaults: Record<string, any>;\n\n  /**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */\n  vertexSource = vertexSource;\n\n  /**\n   * Name of the parameter that can be changed in the filter.\n   * Some filters have more than one parameter and there is no\n   * mainParameter\n   * @private\n   */\n  declare mainParameter?: keyof this | undefined;\n\n  /**\n   * Constructor\n   * @param {Object} [options] Options object\n   */\n  constructor({ type, ...options }: Record<string, any> = {}) {\n    Object.assign(\n      this,\n      (this.constructor as typeof BaseFilter).defaults,\n      options\n    );\n  }\n\n  protected getFragmentSource(): string {\n    return identityFragmentShader;\n  }\n\n  /**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */\n  createProgram(\n    gl: WebGLRenderingContext,\n    fragmentSource: string = this.getFragmentSource(),\n    vertexSource: string = this.vertexSource\n  ) {\n    const {\n      WebGLProbe: { GLPrecision = 'highp' },\n    } = getEnv();\n    if (GLPrecision !== 'highp') {\n      fragmentSource = fragmentSource.replace(\n        regex,\n        highPsourceCode.replace('highp', GLPrecision)\n      );\n    }\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    const program = gl.createProgram();\n\n    if (!vertexShader || !fragmentShader || !program) {\n      throw new FabricError(\n        'Vertex, fragment shader or program creation error'\n      );\n    }\n    gl.shaderSource(vertexShader, vertexSource);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      throw new FabricError(\n        `Vertex shader compile error for ${this.type}: ${gl.getShaderInfoLog(\n          vertexShader\n        )}`\n      );\n    }\n\n    gl.shaderSource(fragmentShader, fragmentSource);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      throw new FabricError(\n        `Fragment shader compile error for ${this.type}: ${gl.getShaderInfoLog(\n          fragmentShader\n        )}`\n      );\n    }\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      throw new FabricError(\n        `Shader link error for \"${this.type}\" ${gl.getProgramInfoLog(program)}`\n      );\n    }\n\n    const uniformLocations = this.getUniformLocations(gl, program) || {};\n    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');\n    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');\n    return {\n      program,\n      attributeLocations: this.getAttributeLocations(gl, program),\n      uniformLocations,\n    };\n  }\n\n  /**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */\n  getAttributeLocations(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram\n  ): TWebGLAttributeLocationMap {\n    return {\n      aPosition: gl.getAttribLocation(program, 'aPosition'),\n    };\n  }\n\n  /**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */\n  getUniformLocations(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram\n  ): TWebGLUniformLocationMap {\n    return {};\n  }\n\n  /**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */\n  sendAttributeData(\n    gl: WebGLRenderingContext,\n    attributeLocations: Record<string, number>,\n    aPositionData: Float32Array\n  ) {\n    const attributeLocation = attributeLocations.aPosition;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.enableVertexAttribArray(attributeLocation);\n    gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);\n  }\n\n  _setupFrameBuffer(options: TWebGLPipelineState) {\n    const gl = options.context;\n    if (options.passes > 1) {\n      const width = options.destinationWidth;\n      const height = options.destinationHeight;\n      if (options.sourceWidth !== width || options.sourceHeight !== height) {\n        gl.deleteTexture(options.targetTexture);\n        options.targetTexture = options.filterBackend.createTexture(\n          gl,\n          width,\n          height\n        );\n      }\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        options.targetTexture,\n        0\n      );\n    } else {\n      // draw last filter on canvas and not to framebuffer.\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      gl.finish();\n    }\n  }\n\n  _swapTextures(options: TWebGLPipelineState) {\n    options.passes--;\n    options.pass++;\n    const temp = options.targetTexture;\n    options.targetTexture = options.sourceTexture;\n    options.sourceTexture = temp;\n  }\n\n  /**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isNeutralState(options?: any): boolean {\n    const main = this.mainParameter,\n      defaultValue = (this.constructor as typeof BaseFilter).defaults[\n        main as string\n      ];\n    if (main) {\n      const thisValue = this[main];\n      if (Array.isArray(defaultValue) && Array.isArray(thisValue)) {\n        return defaultValue.every(\n          (value: any, i: number) => value === thisValue[i]\n        );\n      } else {\n        return defaultValue === thisValue;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */\n  applyTo(options: TWebGLPipelineState | T2DPipelineState) {\n    if (isWebGLPipelineState(options)) {\n      this._setupFrameBuffer(options);\n      this.applyToWebGL(options);\n      this._swapTextures(options);\n    } else {\n      this.applyTo2d(options);\n    }\n  }\n\n  applyTo2d(options: T2DPipelineState): void {\n    // override by subclass\n  }\n\n  /**\n   * Returns a string that represent the current selected shader code for the filter.\n   * Used to force recompilation when parameters change or to retrieve the shader from cache\n   * @type string\n   **/\n  getCacheKey() {\n    return this.type;\n  }\n\n  /**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   * @return {WebGLProgram} the compiled program shader\n   */\n  retrieveShader(options: TWebGLPipelineState): TWebGLProgramCacheItem {\n    const key = this.getCacheKey();\n    if (!options.programCache[key]) {\n      options.programCache[key] = this.createProgram(options.context);\n    }\n    return options.programCache[key];\n  }\n\n  /**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */\n  applyToWebGL(options: TWebGLPipelineState) {\n    const gl = options.context;\n    const shader = this.retrieveShader(options);\n    if (options.pass === 0 && options.originalTexture) {\n      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);\n    } else {\n      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);\n    }\n    gl.useProgram(shader.program);\n    this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);\n\n    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);\n    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);\n\n    this.sendUniformData(gl, shader.uniformLocations);\n    gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  bindAdditionalTexture(\n    gl: WebGLRenderingContext,\n    texture: WebGLTexture,\n    textureUnit: number\n  ) {\n    gl.activeTexture(textureUnit);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // reset active texture to 0 as usual\n    gl.activeTexture(gl.TEXTURE0);\n  }\n\n  unbindAdditionalTexture(gl: WebGLRenderingContext, textureUnit: number) {\n    gl.activeTexture(textureUnit);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.activeTexture(gl.TEXTURE0);\n  }\n\n  getMainParameter() {\n    return this.mainParameter ? this[this.mainParameter] : undefined;\n  }\n\n  setMainParameter(value: any) {\n    if (this.mainParameter) {\n      this[this.mainParameter] = value;\n    }\n  }\n\n  /**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */\n  sendUniformData(\n    gl: WebGLRenderingContext,\n    uniformLocations: TWebGLUniformLocationMap\n  ): void {\n    // override by subclass\n  }\n\n  /**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */\n  createHelpLayer(options: T2DPipelineState) {\n    if (!options.helpLayer) {\n      const helpLayer = createCanvasElement();\n      helpLayer.width = options.sourceWidth;\n      helpLayer.height = options.sourceHeight;\n      options.helpLayer = helpLayer;\n    }\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */\n  toObject() {\n    const mainP = this.mainParameter;\n    return {\n      type: this.type,\n      ...(mainP ? { [mainP]: this[mainP] } : {}),\n    };\n  }\n\n  /**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */\n  toJSON() {\n    // delegate, not alias\n    return this.toObject();\n  }\n\n  static async fromObject(\n    { type, ...filterOptions }: Record<string, any>,\n    options: Abortable\n  ) {\n    return new this(filterOptions);\n  }\n}\n"],"names":["regex","RegExp","highPsourceCode","BaseFilter","type","this","constructor","options","_objectWithoutProperties","arguments","length","undefined","_excluded","_defineProperty","vertexSource","Object","assign","defaults","getFragmentSource","identityFragmentShader","createProgram","gl","fragmentSource","WebGLProbe","GLPrecision","getEnv","replace","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","FabricError","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","concat","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","uniformLocations","getUniformLocations","uStepW","getUniformLocation","uStepH","attributeLocations","getAttributeLocations","aPosition","getAttribLocation","sendAttributeData","aPositionData","attributeLocation","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribPointer","FLOAT","bufferData","STATIC_DRAW","_setupFrameBuffer","context","passes","width","destinationWidth","height","destinationHeight","sourceWidth","sourceHeight","deleteTexture","targetTexture","filterBackend","createTexture","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","TEXTURE_2D","bindFramebuffer","finish","_swapTextures","pass","temp","sourceTexture","isNeutralState","main","mainParameter","defaultValue","thisValue","Array","isArray","every","value","i","applyTo","isWebGLPipelineState","applyToWebGL","applyTo2d","getCacheKey","retrieveShader","key","programCache","shader","originalTexture","bindTexture","useProgram","uniform1f","sendUniformData","viewport","drawArrays","TRIANGLE_STRIP","bindAdditionalTexture","texture","textureUnit","activeTexture","TEXTURE0","unbindAdditionalTexture","getMainParameter","setMainParameter","createHelpLayer","helpLayer","createCanvasElement","toObject","mainP","_objectSpread","toJSON","fromObject","_ref2","_excluded2"],"mappings":"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"}