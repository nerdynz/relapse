import{objectSpread2 as e}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{cache as t}from"../../cache.min.mjs";import{config as n}from"../../config.min.mjs";import{halfPI as r,PiBy180 as s}from"../../constants.min.mjs";import{cos as a}from"../misc/cos.min.mjs";import{multiplyTransformMatrices as o,transformPoint as c}from"../misc/matrix.min.mjs";import{sin as i}from"../misc/sin.min.mjs";import{toFixed as l}from"../misc/toFixed.min.mjs";import{Point as h}from"../../Point.min.mjs";import{rePathCommand as m}from"./regex.min.mjs";import{cleanupSvgAttribute as u}from"../internals/cleanupSvgAttribute.min.mjs";const f={m:"l",M:"L"},x=(e,t,n,r,s,o,c,l,h,m,u)=>{const f=a(e),x=i(e),p=a(t),y=i(t),g=n*s*p-r*o*y+c,M=r*s*p+n*o*y+l;return["C",m+h*(-n*s*x-r*o*f),u+h*(-r*s*x+n*o*f),g+h*(n*s*y+r*o*p),M+h*(r*s*y-n*o*p),g,M]},p=(e,t,n,r)=>{const s=Math.atan2(t,e),a=Math.atan2(r,n);return a>=s?a-s:2*Math.PI-(s-a)};function y(e,r,s,a,o,c,i,l){let m;if(n.cachesBoundsOfCurve&&(m=[...arguments].join(),t.boundsOfCurveCache[m]))return t.boundsOfCurveCache[m];const u=Math.sqrt,f=Math.abs,x=[],p=[[0,0],[0,0]];let y=6*e-12*s+6*o,g=-3*e+9*s-9*o+3*i,M=3*s-3*e;for(let e=0;e<2;++e){if(e>0&&(y=6*r-12*a+6*c,g=-3*r+9*a-9*c+3*l,M=3*a-3*r),f(g)<1e-12){if(f(y)<1e-12)continue;const e=-M/y;0<e&&e<1&&x.push(e);continue}const t=y*y-4*M*g;if(t<0)continue;const n=u(t),s=(-y+n)/(2*g);0<s&&s<1&&x.push(s);const o=(-y-n)/(2*g);0<o&&o<1&&x.push(o)}let b=x.length;const w=b,j=d(e,r,s,a,o,c,i,l);for(;b--;){const{x:e,y:t}=j(x[b]);p[0][b]=e,p[1][b]=t}p[0][w]=e,p[1][w]=r,p[0][w+1]=i,p[1][w+1]=l;const k=[new h(Math.min(...p[0]),Math.min(...p[1])),new h(Math.max(...p[0]),Math.max(...p[1]))];return n.cachesBoundsOfCurve&&(t.boundsOfCurveCache[m]=k),k}const g=(e,t,n)=>{let[r,o,c,l,h,m,u,f]=n;const y=((e,t,n,r,o,c,l)=>{if(0===n||0===r)return[];let h=0,m=0,u=0;const f=Math.PI,y=l*s,g=i(y),M=a(y),b=.5*(-M*e-g*t),d=.5*(-M*t+g*e),w=n**2,j=r**2,k=d**2,C=b**2,v=w*j-w*k-j*C;let L=Math.abs(n),Q=Math.abs(r);if(v<0){const e=Math.sqrt(1-v/(w*j));L*=e,Q*=e}else u=(o===c?-1:1)*Math.sqrt(v/(w*k+j*C));const q=u*L*d/Q,F=-u*Q*b/L,P=M*q-g*F+.5*e,A=g*q+M*F+.5*t;let E=p(1,0,(b-q)/L,(d-F)/Q),O=p((b-q)/L,(d-F)/Q,(-b-q)/L,(-d-F)/Q);0===c&&O>0?O-=2*f:1===c&&O<0&&(O+=2*f);const Z=Math.ceil(Math.abs(O/f*2)),N=new Array(Z),B=O/Z,I=8/3*Math.sin(B/4)*Math.sin(B/4)/Math.sin(B/2);let R=E+B;for(let e=0;e<Z;e++)N[e]=x(E,R,M,g,L,Q,P,A,I,h,m),h=N[e][5],m=N[e][6],E=R,R+=B;return N})(u-e,f-t,o,c,h,m,l);for(let n=0,r=y.length;n<r;n++)y[n][1]+=e,y[n][2]+=t,y[n][3]+=e,y[n][4]+=t,y[n][5]+=e,y[n][6]+=t;return y},M=e=>{let t=0,n=0,r=0,s=0;const a=[];let o,c=0,i=0;for(const l of e){const e=[...l];let h;switch(e[0]){case"l":e[1]+=t,e[2]+=n;case"L":t=e[1],n=e[2],h=["L",t,n];break;case"h":e[1]+=t;case"H":t=e[1],h=["L",t,n];break;case"v":e[1]+=n;case"V":n=e[1],h=["L",t,n];break;case"m":e[1]+=t,e[2]+=n;case"M":t=e[1],n=e[2],r=e[1],s=e[2],h=["M",t,n];break;case"c":e[1]+=t,e[2]+=n,e[3]+=t,e[4]+=n,e[5]+=t,e[6]+=n;case"C":c=e[3],i=e[4],t=e[5],n=e[6],h=["C",e[1],e[2],c,i,t,n];break;case"s":e[1]+=t,e[2]+=n,e[3]+=t,e[4]+=n;case"S":"C"===o?(c=2*t-c,i=2*n-i):(c=t,i=n),t=e[3],n=e[4],h=["C",c,i,e[1],e[2],t,n],c=h[3],i=h[4];break;case"q":e[1]+=t,e[2]+=n,e[3]+=t,e[4]+=n;case"Q":c=e[1],i=e[2],t=e[3],n=e[4],h=["Q",c,i,t,n];break;case"t":e[1]+=t,e[2]+=n;case"T":"Q"===o?(c=2*t-c,i=2*n-i):(c=t,i=n),t=e[1],n=e[2],h=["Q",c,i,t,n];break;case"a":e[6]+=t,e[7]+=n;case"A":g(t,n,e).forEach((e=>a.push(e))),t=e[6],n=e[7];break;case"z":case"Z":t=r,n=s,h=["Z"]}h?(a.push(h),o=h[0]):o=""}return a},b=(e,t,n,r)=>Math.sqrt((n-e)**2+(r-t)**2),d=(e,t,n,r,s,a,o,c)=>i=>{const l=i**3,m=(e=>3*e**2*(1-e))(i),u=(e=>3*e*(1-e)**2)(i),f=(e=>(1-e)**3)(i);return new h(o*l+s*m+n*u+e*f,c*l+a*m+r*u+t*f)},w=e=>e**2,j=e=>2*e*(1-e),k=e=>(1-e)**2,C=(e,t,n,r,s,a,o,c)=>i=>{const l=w(i),h=j(i),m=k(i),u=3*(m*(n-e)+h*(s-n)+l*(o-s)),f=3*(m*(r-t)+h*(a-r)+l*(c-a));return Math.atan2(f,u)},v=(e,t,n,r,s,a)=>o=>{const c=w(o),i=j(o),l=k(o);return new h(s*c+n*i+e*l,a*c+r*i+t*l)},L=(e,t,n,r,s,a)=>o=>{const c=1-o,i=2*(c*(n-e)+o*(s-n)),l=2*(c*(r-t)+o*(a-r));return Math.atan2(l,i)},Q=(e,t,n)=>{let r=new h(t,n),s=0;for(let t=1;t<=100;t+=1){const n=e(t/100);s+=b(r.x,r.y,n.x,n.y),r=n}return s},q=(t,n)=>{let r,s=0,a=0,o={x:t.x,y:t.y},c=e({},o),i=.01,l=0;const h=t.iterator,m=t.angleFinder;for(;a<n&&i>1e-4;)c=h(s),l=s,r=b(o.x,o.y,c.x,c.y),r+a>n?(s-=i,i/=2):(o=c,s+=i,a+=r);return e(e({},c),{},{angle:m(l)})},F=e=>{let t,n,r=0,s=0,a=0,o=0,c=0;const i=[];for(const l of e){const e={x:s,y:a,command:l[0],length:0};switch(l[0]){case"M":n=e,n.x=o=s=l[1],n.y=c=a=l[2];break;case"L":n=e,n.length=b(s,a,l[1],l[2]),s=l[1],a=l[2];break;case"C":t=d(s,a,l[1],l[2],l[3],l[4],l[5],l[6]),n=e,n.iterator=t,n.angleFinder=C(s,a,l[1],l[2],l[3],l[4],l[5],l[6]),n.length=Q(t,s,a),s=l[5],a=l[6];break;case"Q":t=v(s,a,l[1],l[2],l[3],l[4]),n=e,n.iterator=t,n.angleFinder=L(s,a,l[1],l[2],l[3],l[4]),n.length=Q(t,s,a),s=l[3],a=l[4];break;case"Z":n=e,n.destX=o,n.destY=c,n.length=b(s,a,o,c),s=o,a=c}r+=n.length,i.push(n)}return i.push({length:r,x:s,y:a}),i},P=function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:F(t),s=0;for(;n-r[s].length>0&&s<r.length-2;)n-=r[s].length,s++;const a=r[s],o=n/a.length,c=t[s];switch(a.command){case"M":return{x:a.x,y:a.y,angle:0};case"Z":return e(e({},new h(a.x,a.y).lerp(new h(a.destX,a.destY),o)),{},{angle:Math.atan2(a.destY-a.y,a.destX-a.x)});case"L":return e(e({},new h(a.x,a.y).lerp(new h(c[1],c[2]),o)),{},{angle:Math.atan2(c[2]-a.y,c[1]-a.x)});case"C":case"Q":return q(a,n)}},A=new RegExp(m,"gi"),E=new RegExp(m,"i"),O=e=>{e=u(e);const t=[];for(let[n]of e.matchAll(A)){const e=[];let r;do{if(r=E.exec(n),!r)break;const t=r.filter((e=>e));t.shift();const s=t.map((e=>{const t=Number.parseFloat(e);return Number.isNaN(t)?e:t}));if(e.push(s),t.length<=1)break;t.shift(),n=n.replace(new RegExp("".concat(t.join(" ?")," ?$")),"")}while(r);e.reverse().forEach(((e,n)=>{const r=f[e[0]];n>0&&("l"==r||"L"==r)&&(e[0]=r),t.push(e)}))}return t},Z=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=new h(e[0]),r=new h(e[1]),s=1,a=0;const o=[],c=e.length,i=c>2;let l;for(i&&(s=e[2].x<r.x?-1:e[2].x===r.x?0:1,a=e[2].y<r.y?-1:e[2].y===r.y?0:1),o.push(["M",n.x-s*t,n.y-a*t]),l=1;l<c;l++){if(!n.eq(r)){const e=n.midPointFrom(r);o.push(["Q",n.x,n.y,e.x,e.y])}n=e[l],l+1<e.length&&(r=e[l+1])}return i&&(s=n.x>e[l-2].x?1:n.x===e[l-2].x?0:-1,a=n.y>e[l-2].y?1:n.y===e[l-2].y?0:-1),o.push(["L",n.x+s*t,n.y+a*t]),o},N=(e,t,n)=>(n&&(t=o(t,[1,0,0,1,-n.x,-n.y])),e.map((e=>{const n=[...e];for(let r=1;r<e.length-1;r+=2){const{x:s,y:a}=c({x:e[r],y:e[r+1]},t);n[r]=s,n[r+1]=a}return n}))),B=(e,t)=>{const n=2*Math.PI/e;let s=-r;e%2==0&&(s+=n/2);const o=new Array(e+1);for(let r=0;r<e;r++){const e=r*n+s,{x:c,y:l}=new h(a(e),i(e)).scalarMultiply(t);o[r]=[0===r?"M":"L",c,l]}return o[e]=["Z"],o},I=(e,t)=>e.map((e=>e.map(((e,n)=>0===n||void 0===t?e:l(e,t))).join(" "))).join(" ");export{g as fromArcToBeziers,y as getBoundsOfCurve,F as getPathSegmentsInfo,P as getPointOnPath,B as getRegularPolygonPath,Z as getSmoothPathFromPoints,I as joinPath,M as makePathSimpler,O as parsePath,N as transformPath};
//# sourceMappingURL=index.min.mjs.map
