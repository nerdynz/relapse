"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Any: () => Any,
  AnyJSON: () => AnyJSON,
  Api: () => Api,
  ApiJSON: () => ApiJSON,
  BinaryReader: () => BinaryReader,
  BinaryWriter: () => BinaryWriter,
  BoolValue: () => BoolValue,
  BoolValueJSON: () => BoolValueJSON,
  BytesValue: () => BytesValue,
  BytesValueJSON: () => BytesValueJSON,
  DoubleValue: () => DoubleValue,
  DoubleValueJSON: () => DoubleValueJSON,
  Duration: () => Duration,
  DurationJSON: () => DurationJSON,
  Empty: () => Empty,
  EmptyJSON: () => EmptyJSON,
  Enum: () => Enum,
  EnumJSON: () => EnumJSON,
  EnumValue: () => EnumValue,
  EnumValueJSON: () => EnumValueJSON,
  Field: () => Field,
  FieldJSON: () => FieldJSON,
  FieldMask: () => FieldMask,
  FieldMaskJSON: () => FieldMaskJSON,
  FloatValue: () => FloatValue,
  FloatValueJSON: () => FloatValueJSON,
  Int32Value: () => Int32Value,
  Int32ValueJSON: () => Int32ValueJSON,
  Int64Value: () => Int64Value,
  Int64ValueJSON: () => Int64ValueJSON,
  ListValue: () => ListValue,
  ListValueJSON: () => ListValueJSON,
  Method: () => Method,
  MethodJSON: () => MethodJSON,
  Mixin: () => Mixin,
  MixinJSON: () => MixinJSON,
  NullValue: () => NullValue,
  NullValueJSON: () => NullValueJSON,
  Option: () => Option2,
  OptionJSON: () => OptionJSON2,
  SourceContext: () => SourceContext2,
  SourceContextJSON: () => SourceContextJSON2,
  StringValue: () => StringValue,
  StringValueJSON: () => StringValueJSON,
  Struct: () => Struct,
  StructJSON: () => StructJSON,
  Syntax: () => Syntax2,
  SyntaxJSON: () => SyntaxJSON2,
  Timestamp: () => Timestamp,
  TimestampJSON: () => TimestampJSON,
  Type: () => Type,
  TypeJSON: () => TypeJSON,
  UInt32Value: () => UInt32Value,
  UInt32ValueJSON: () => UInt32ValueJSON,
  UInt64Value: () => UInt64Value,
  UInt64ValueJSON: () => UInt64ValueJSON,
  Value: () => Value,
  ValueJSON: () => ValueJSON,
  parseBytes: () => parseBytes,
  parseDouble: () => parseDouble,
  parseDuration: () => parseDuration,
  parseNumber: () => parseNumber,
  parseTimestamp: () => parseTimestamp,
  serializeBytes: () => serializeBytes,
  serializeDuration: () => serializeDuration,
  serializeTimestamp: () => serializeTimestamp
});
module.exports = __toCommonJS(src_exports);

// src/runtime/goog/asserts.ts
var assert = (condition) => {
  if (!condition) {
    throw new Error("Assertion failed");
  }
  return condition;
};
var fail = (message) => {
  throw new Error(message);
};

// src/runtime/constants.ts
var FieldType = {
  INVALID: -1,
  DOUBLE: 1,
  FLOAT: 2,
  INT64: 3,
  UINT64: 4,
  INT32: 5,
  FIXED64: 6,
  FIXED32: 7,
  BOOL: 8,
  STRING: 9,
  GROUP: 10,
  MESSAGE: 11,
  BYTES: 12,
  UINT32: 13,
  ENUM: 14,
  SFIXED32: 15,
  SFIXED64: 16,
  SINT32: 17,
  SINT64: 18,
  // Extended types for Javascript
  FHASH64: 30,
  // 64-bit hash string, fixed-length encoding.
  VHASH64: 31
  // 64-bit hash string, varint encoding.
};
var WireType = {
  INVALID: -1,
  VARINT: 0,
  FIXED64: 1,
  DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5
};
var FieldTypeToWireType = function(fieldType) {
  switch (fieldType) {
    case FieldType.INT32:
    case FieldType.INT64:
    case FieldType.UINT32:
    case FieldType.UINT64:
    case FieldType.SINT32:
    case FieldType.SINT64:
    case FieldType.BOOL:
    case FieldType.ENUM:
    case FieldType.VHASH64:
      return WireType.VARINT;
    case FieldType.DOUBLE:
    case FieldType.FIXED64:
    case FieldType.SFIXED64:
    case FieldType.FHASH64:
      return WireType.FIXED64;
    case FieldType.STRING:
    case FieldType.MESSAGE:
    case FieldType.BYTES:
      return WireType.DELIMITED;
    case FieldType.FLOAT:
    case FieldType.FIXED32:
    case FieldType.SFIXED32:
      return WireType.FIXED32;
    case FieldType.INVALID:
    case FieldType.GROUP:
    default:
      return WireType.INVALID;
  }
};
var INVALID_FIELD_NUMBER = -1;
var FLOAT32_MIN = 11754943508222875e-54;
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT64_MIN = 22250738585072014e-324;
var FLOAT64_MAX = 17976931348623157e292;
var TWO_TO_20 = 1048576;
var TWO_TO_23 = 8388608;
var TWO_TO_31 = 2147483648;
var TWO_TO_32 = 4294967296;
var TWO_TO_52 = 4503599627370496;
var TWO_TO_63 = 9223372036854776e3;
var TWO_TO_64 = 18446744073709552e3;

// src/runtime/goog/crypt.ts
var decoder = new TextDecoder("utf8");
function byteArrayToString(bytes) {
  const buffer = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
  return decoder.decode(buffer);
}
var encoder = new TextEncoder();
function stringToUint8Array(s) {
  return encoder.encode(s);
}

// src/runtime/utils.ts
function byteSourceToUint8Array(data) {
  if (data instanceof Uint8Array) {
    return data;
  }
  if (typeof data === "string") {
    return stringToUint8Array(data);
  }
  return new Uint8Array(data);
}
function fromZigzag64(bitsLow, bitsHigh, convert) {
  const signFlipMask = -(bitsLow & 1);
  bitsLow = (bitsLow >>> 1 | bitsHigh << 31) ^ signFlipMask;
  bitsHigh = bitsHigh >>> 1 ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}
function toZigzag64(bitsLow, bitsHigh, convert) {
  const signFlipMask = bitsHigh >> 31;
  bitsHigh = (bitsHigh << 1 | bitsLow >>> 31) ^ signFlipMask;
  bitsLow = bitsLow << 1 ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}
var ZERO_CHAR_CODE_ = 48;
function decimalStringToHash64(dec) {
  assert(dec.length > 0);
  let minus = false;
  if (dec[0] === "-") {
    minus = true;
    dec = dec.slice(1);
  }
  const resultBytes = [0, 0, 0, 0, 0, 0, 0, 0];
  function muladd(m, c) {
    for (let i = 0; i < 8 && (m !== 1 || c > 0); i++) {
      const r = m * resultBytes[i] + c;
      resultBytes[i] = r & 255;
      c = r >>> 8;
    }
  }
  function neg() {
    for (let i = 0; i < 8; i++) {
      resultBytes[i] = ~resultBytes[i] & 255;
    }
  }
  for (let i = 0; i < dec.length; i++) {
    muladd(10, dec.charCodeAt(i) - ZERO_CHAR_CODE_);
  }
  if (minus) {
    neg();
    muladd(1, 1);
  }
  return byteArrayToString(resultBytes);
}
var split64Low = 0;
var split64High = 0;
var splitInt64 = function(value) {
  const sign = value < 0;
  value = Math.abs(value);
  let lowBits = value >>> 0;
  let highBits = Math.floor((value - lowBits) / TWO_TO_32);
  highBits = highBits >>> 0;
  if (sign) {
    highBits = ~highBits >>> 0;
    lowBits = ~lowBits >>> 0;
    lowBits += 1;
    if (lowBits > 4294967295) {
      lowBits = 0;
      highBits++;
      if (highBits > 4294967295)
        highBits = 0;
    }
  }
  split64Low = lowBits;
  split64High = highBits;
};
var splitUint64 = function(value) {
  const lowBits = value >>> 0;
  const highBits = Math.floor((value - lowBits) / TWO_TO_32) >>> 0;
  split64Low = lowBits;
  split64High = highBits;
};
var splitZigzag64 = function(value) {
  const sign = value < 0;
  value = Math.abs(value) * 2;
  splitUint64(value);
  let lowBits = split64Low;
  let highBits = split64High;
  if (sign) {
    if (lowBits == 0) {
      if (highBits == 0) {
        lowBits = 4294967295;
        highBits = 4294967295;
      } else {
        highBits--;
        lowBits = 4294967295;
      }
    } else {
      lowBits--;
    }
  }
  split64Low = lowBits;
  split64High = highBits;
};
var splitHash64 = function(hash) {
  const a = hash.charCodeAt(0);
  const b = hash.charCodeAt(1);
  const c = hash.charCodeAt(2);
  const d = hash.charCodeAt(3);
  const e = hash.charCodeAt(4);
  const f = hash.charCodeAt(5);
  const g = hash.charCodeAt(6);
  const h = hash.charCodeAt(7);
  split64Low = a + (b << 8) + (c << 16) + (d << 24) >>> 0;
  split64High = e + (f << 8) + (g << 16) + (h << 24) >>> 0;
};
var splitFloat32 = function(value) {
  const sign = value < 0 ? 1 : 0;
  value = sign ? -value : value;
  let exp;
  let mant;
  if (value === 0) {
    if (1 / value > 0) {
      split64High = 0;
      split64Low = 0;
    } else {
      split64High = 0;
      split64Low = 2147483648;
    }
    return;
  }
  if (isNaN(value)) {
    split64High = 0;
    split64Low = 2147483647;
    return;
  }
  if (value > FLOAT32_MAX) {
    split64High = 0;
    split64Low = (sign << 31 | 2139095040) >>> 0;
    return;
  }
  if (value < FLOAT32_MIN) {
    mant = Math.round(value / Math.pow(2, -149));
    split64High = 0;
    split64Low = (sign << 31 | mant) >>> 0;
    return;
  }
  exp = Math.floor(Math.log(value) / Math.LN2);
  mant = value * Math.pow(2, -exp);
  mant = Math.round(mant * TWO_TO_23);
  if (mant >= 16777216) {
    ++exp;
  }
  mant = mant & 8388607;
  split64High = 0;
  split64Low = (sign << 31 | exp + 127 << 23 | mant) >>> 0;
};
var splitFloat64 = function(value) {
  const sign = value < 0 ? 1 : 0;
  value = sign ? -value : value;
  if (value === 0) {
    if (1 / value > 0) {
      split64High = 0;
      split64Low = 0;
    } else {
      split64High = 2147483648;
      split64Low = 0;
    }
    return;
  }
  if (isNaN(value)) {
    split64High = 2147483647;
    split64Low = 4294967295;
    return;
  }
  if (value > FLOAT64_MAX) {
    split64High = (sign << 31 | 2146435072) >>> 0;
    split64Low = 0;
    return;
  }
  if (value < FLOAT64_MIN) {
    const mant2 = value / Math.pow(2, -1074);
    const mantHigh2 = mant2 / TWO_TO_32;
    split64High = (sign << 31 | mantHigh2) >>> 0;
    split64Low = mant2 >>> 0;
    return;
  }
  const maxDoubleExponent = 1023;
  const minDoubleExponent = -1022;
  let x = value;
  let exp = 0;
  if (x >= 2) {
    while (x >= 2 && exp < maxDoubleExponent) {
      exp++;
      x = x / 2;
    }
  } else {
    while (x < 1 && exp > minDoubleExponent) {
      x = x * 2;
      exp--;
    }
  }
  const mant = value * Math.pow(2, -exp);
  const mantHigh = mant * TWO_TO_20 & 1048575;
  const mantLow = mant * TWO_TO_52 >>> 0;
  split64High = (sign << 31 | exp + 1023 << 20 | mantHigh) >>> 0;
  split64Low = mantLow;
};
var joinUint64 = function(bitsLow, bitsHigh) {
  return bitsHigh * TWO_TO_32 + (bitsLow >>> 0);
};
var joinInt64 = function(bitsLow, bitsHigh) {
  const sign = bitsHigh & 2147483648;
  if (sign) {
    bitsLow = ~bitsLow + 1 >>> 0;
    bitsHigh = ~bitsHigh >>> 0;
    if (bitsLow == 0) {
      bitsHigh = bitsHigh + 1 >>> 0;
    }
  }
  const result = joinUint64(bitsLow, bitsHigh);
  return sign ? -result : result;
};
var joinZigzag64 = function(bitsLow, bitsHigh) {
  return fromZigzag64(bitsLow, bitsHigh, joinInt64);
};
var joinHash64 = function(bitsLow, bitsHigh) {
  const a = bitsLow >>> 0 & 255;
  const b = bitsLow >>> 8 & 255;
  const c = bitsLow >>> 16 & 255;
  const d = bitsLow >>> 24 & 255;
  const e = bitsHigh >>> 0 & 255;
  const f = bitsHigh >>> 8 & 255;
  const g = bitsHigh >>> 16 & 255;
  const h = bitsHigh >>> 24 & 255;
  return String.fromCharCode(a, b, c, d, e, f, g, h);
};
function joinFloat32(bitsLow) {
  const sign = (bitsLow >> 31) * 2 + 1;
  const exp = bitsLow >>> 23 & 255;
  const mant = bitsLow & 8388607;
  if (exp == 255) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }
  if (exp == 0) {
    return sign * Math.pow(2, -149) * mant;
  } else {
    return sign * Math.pow(2, exp - 150) * (mant + Math.pow(2, 23));
  }
}
var joinFloat64 = function(bitsLow, bitsHigh) {
  const sign = (bitsHigh >> 31) * 2 + 1;
  const exp = bitsHigh >>> 20 & 2047;
  const mant = TWO_TO_32 * (bitsHigh & 1048575) + bitsLow;
  if (exp == 2047) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }
  if (exp == 0) {
    return sign * Math.pow(2, -1074) * mant;
  } else {
    return sign * Math.pow(2, exp - 1075) * (mant + TWO_TO_52);
  }
};
var joinUnsignedDecimalString = function(bitsLow, bitsHigh) {
  if (bitsHigh <= 2097151) {
    return joinUint64(bitsLow, bitsHigh).toString();
  }
  const low = bitsLow & 16777215;
  const mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  const high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    const partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(digitA, 1);
};
var joinSignedDecimalString = function(bitsLow, bitsHigh) {
  const negative = bitsHigh & 2147483648;
  if (negative) {
    bitsLow = ~bitsLow + 1 >>> 0;
    const carry = bitsLow == 0 ? 1 : 0;
    bitsHigh = ~bitsHigh + carry >>> 0;
  }
  const result = joinUnsignedDecimalString(bitsLow, bitsHigh);
  return negative ? "-" + result : result;
};

// src/runtime/decoder.ts
var _BinaryDecoder = class _BinaryDecoder {
  /**
   * Pops an instance off the instance cache, or creates one if the cache is
   * empty.
   */
  static alloc(opt_bytes, opt_start, opt_length) {
    const newDecoder = _BinaryDecoder.instanceCache_.pop();
    if (newDecoder) {
      if (opt_bytes) {
        newDecoder.setBlock(opt_bytes, opt_start, opt_length);
      }
      return newDecoder;
    } else {
      return new _BinaryDecoder(opt_bytes, opt_start, opt_length);
    }
  }
  constructor(opt_bytes, opt_start, opt_length) {
    this.bytes_ = void 0;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
    if (opt_bytes) {
      this.setBlock(opt_bytes, opt_start, opt_length);
    }
  }
  /**
   * Puts this instance back in the instance cache.
   */
  free() {
    this.clear();
    if (_BinaryDecoder.instanceCache_.length < 100) {
      _BinaryDecoder.instanceCache_.push(this);
    }
  }
  /**
   * Makes a copy of this decoder.
   */
  clone() {
    return _BinaryDecoder.alloc(
      this.bytes_,
      this.start_,
      this.end_ - this.start_
    );
  }
  /**
   * Clears the decoder.
   */
  clear() {
    this.bytes_ = void 0;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
  }
  /**
   * Returns the raw buffer.
   */
  getBuffer() {
    return this.bytes_;
  }
  /**
   * Changes the block of bytes we're decoding.
   */
  setBlock(data, opt_start, opt_length) {
    this.bytes_ = byteSourceToUint8Array(data);
    this.start_ = opt_start ?? 0;
    this.end_ = opt_length !== void 0 ? this.start_ + opt_length : this.bytes_.length;
    this.cursor_ = this.start_;
  }
  getEnd() {
    return this.end_;
  }
  setEnd(end) {
    this.end_ = end;
  }
  /**
   * Moves the read cursor back to the start of the block.
   */
  reset() {
    this.cursor_ = this.start_;
  }
  /**
   * Returns the internal read cursor.
   */
  getCursor() {
    return this.cursor_;
  }
  /**
   * Returns the internal read cursor.
   */
  setCursor(cursor) {
    this.cursor_ = cursor;
  }
  /**
   * Advances the stream cursor by the given number of bytes.
   */
  advance(count) {
    this.cursor_ += count;
    assert(this.cursor_ <= this.end_);
  }
  /**
   * Returns true if this decoder is at the end of the block.
   */
  atEnd() {
    return this.cursor_ == this.end_;
  }
  /**
   * Returns true if this decoder is at the end of the block.
   */
  pastEnd() {
    return this.cursor_ > this.end_;
  }
  /**
   * Returns true if this decoder encountered an error due to corrupt data.
   */
  getError() {
    return this.error_ || this.cursor_ < 0 || this.cursor_ > this.end_;
  }
  /**
   * Reads an unsigned varint from the binary stream and invokes the conversion
   * function with the value in two signed 32 bit integers to produce the result.
   * Since this does not convert the value to a number, no precision is lost.
   *
   * It's possible for an unsigned varint to be incorrectly encoded - more than
   * 64 bits' worth of data could be present. If this happens, this method will
   * throw an error.
   *
   * Decoding varints requires doing some funny base-128 math - for more
   * details on the format, see
   * https://developers.google.com/protocol-buffers/docs/encoding
   */
  readSplitVarint64(convert) {
    let temp = 128;
    let lowBits = 0;
    let highBits = 0;
    for (let i = 0; i < 4 && temp >= 128; i++) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 127) << i * 7;
    }
    if (temp >= 128) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 127) << 28;
      highBits |= (temp & 127) >> 4;
    }
    if (temp >= 128) {
      for (let i = 0; i < 5 && temp >= 128; i++) {
        temp = this.bytes_[this.cursor_++];
        highBits |= (temp & 127) << i * 7 + 3;
      }
    }
    if (temp < 128) {
      return convert(lowBits >>> 0, highBits >>> 0);
    }
    fail("Failed to read varint, encoding is invalid.");
    this.error_ = true;
    return void 0;
  }
  /**
   * Reads a 64-bit fixed-width value from the stream and invokes the conversion
   * function with the value in two signed 32 bit integers to produce the result.
   * Since this does not convert the value to a number, no precision is lost.
   */
  readSplitFixed64(convert) {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    this.cursor_ += 8;
    let lowBits = 0;
    let highBits = 0;
    for (let i = cursor + 7; i >= cursor; i--) {
      lowBits = lowBits << 8 | bytes[i];
      highBits = highBits << 8 | bytes[i + 4];
    }
    return convert(lowBits, highBits);
  }
  /**
   * Skips over a varint in the block without decoding it.
   */
  skipVarint() {
    while (this.bytes_[this.cursor_] & 128) {
      this.cursor_++;
    }
    this.cursor_++;
  }
  /**
   * Skips backwards over a varint in the block - to do this correctly, we have
   * to know the value we're skipping backwards over or things are ambiguous.
   */
  unskipVarint(value) {
    while (value > 128) {
      this.cursor_--;
      value = value >>> 7;
    }
    this.cursor_--;
  }
  /**
   * Reads a 32-bit varint from the binary stream. Due to a quirk of the encoding
   * format and Javascript's handling of bitwise math, this actually works
   * correctly for both signed and unsigned 32-bit varints.
   *
   * This function is called vastly more frequently than any other in
   * BinaryDecoder, so it has been unrolled and tweaked for performance.
   *
   * If there are more than 32 bits of data in the varint, it _must_ be due to
   * sign-extension. If we're in debug mode and the high 32 bits don't match the
   * expected sign extension, this method will throw an error.
   *
   * Decoding varints requires doing some funny base-128 math - for more
   * details on the format, see
   * https://developers.google.com/protocol-buffers/docs/encoding
   *
   */
  readUnsignedVarint32() {
    let temp;
    const bytes = this.bytes_;
    temp = bytes[this.cursor_ + 0];
    let x = temp & 127;
    if (temp < 128) {
      this.cursor_ += 1;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 1];
    x |= (temp & 127) << 7;
    if (temp < 128) {
      this.cursor_ += 2;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 2];
    x |= (temp & 127) << 14;
    if (temp < 128) {
      this.cursor_ += 3;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 3];
    x |= (temp & 127) << 21;
    if (temp < 128) {
      this.cursor_ += 4;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 4];
    x |= (temp & 15) << 28;
    if (temp < 128) {
      this.cursor_ += 5;
      assert(this.cursor_ <= this.end_);
      return x >>> 0;
    }
    this.cursor_ += 5;
    if (bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128) {
      assert(false);
    }
    assert(this.cursor_ <= this.end_);
    return x;
  }
  /**
   * The readUnsignedVarint32 above deals with signed 32-bit varints correctly,
   * so this is just an alias.
   */
  readSignedVarint32() {
    return this.readUnsignedVarint32();
  }
  /**
   * Reads a 32-bit unsigned variant and returns its value as a string.
   */
  readUnsignedVarint32String() {
    const value = this.readUnsignedVarint32();
    return value.toString();
  }
  /**
   * Reads a 32-bit signed variant and returns its value as a string.
   */
  readSignedVarint32String() {
    const value = this.readSignedVarint32();
    return value.toString();
  }
  /**
   * Reads a signed, zigzag-encoded 32-bit varint from the binary stream.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   */
  readZigzagVarint32() {
    const result = this.readUnsignedVarint32();
    return result >>> 1 ^ -(result & 1);
  }
  /**
   * Reads an unsigned 64-bit varint from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the varint is larger than 2^53.
   */
  readUnsignedVarint64() {
    return this.readSplitVarint64(joinUint64);
  }
  /**
   * Reads an unsigned 64-bit varint from the binary stream and returns the value
   * as a decimal string.
   */
  readUnsignedVarint64String() {
    return this.readSplitVarint64(joinUnsignedDecimalString);
  }
  /**
   * Reads a signed 64-bit varint from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the varint is larger than 2^53.
   */
  readSignedVarint64() {
    return this.readSplitVarint64(joinInt64);
  }
  /**
   * Reads an signed 64-bit varint from the binary stream and returns the value
   * as a decimal string.
   */
  readSignedVarint64String() {
    return this.readSplitVarint64(joinSignedDecimalString);
  }
  /**
   * Reads a signed, zigzag-encoded 64-bit varint from the binary stream. Note
   * that since Javascript represents all numbers as double-precision floats,
   * there will be precision lost if the absolute value of the varint is larger
   * than 2^53.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   */
  readZigzagVarint64() {
    return this.readSplitVarint64(joinZigzag64);
  }
  /**
   * Reads a signed zigzag encoded varint from the binary stream and invokes
   * the conversion function with the value in two signed 32 bit integers to
   * produce the result. Since this does not convert the value to a number, no
   * precision is lost.
   *
   * It's possible for an unsigned varint to be incorrectly encoded - more than
   * 64 bits' worth of data could be present. If this happens, this method will
   * throw an error.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   *     the result value, takes parameters (lowBits, highBits).
   */
  readSplitZigzagVarint64(convert) {
    return this.readSplitVarint64(function(low, high) {
      return fromZigzag64(low, high, convert);
    });
  }
  /**
   * Reads a signed, zigzag-encoded 64-bit varint from the binary stream
   * losslessly and returns it as an 8-character Unicode string for use as a hash
   * table key.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   */
  readZigzagVarintHash64() {
    return this.readSplitZigzagVarint64(joinHash64);
  }
  /**
   * Reads a signed, zigzag-encoded 64-bit varint from the binary stream and
   * returns its value as a string.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   */
  readZigzagVarint64String() {
    return this.readSplitZigzagVarint64(joinSignedDecimalString);
  }
  /**
   * Reads a raw unsigned 8-bit integer from the binary stream.
   */
  readUint8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    assert(this.cursor_ <= this.end_);
    return a;
  }
  /**
   * Reads a raw unsigned 16-bit integer from the binary stream.
   */
  readUint16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    assert(this.cursor_ <= this.end_);
    return a << 0 | b << 8;
  }
  /**
   * Reads a raw unsigned 32-bit integer from the binary stream.
   */
  readUint32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    assert(this.cursor_ <= this.end_);
    return (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
  }
  /**
   * Reads a raw unsigned 64-bit integer from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the integer is larger than 2^53.
   */
  readUint64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinUint64(bitsLow, bitsHigh);
  }
  /**
   * Reads a raw unsigned 64-bit integer from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the integer is larger than 2^53.
   */
  readUint64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinUnsignedDecimalString(bitsLow, bitsHigh);
  }
  /**
   * Reads a raw signed 8-bit integer from the binary stream.
   */
  readInt8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    assert(this.cursor_ <= this.end_);
    return a << 24 >> 24;
  }
  /**
   * Reads a raw signed 16-bit integer from the binary stream.
   */
  readInt16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    assert(this.cursor_ <= this.end_);
    return (a << 0 | b << 8) << 16 >> 16;
  }
  /**
   * Reads a raw signed 32-bit integer from the binary stream.
   */
  readInt32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    assert(this.cursor_ <= this.end_);
    return a << 0 | b << 8 | c << 16 | d << 24;
  }
  /**
   * Reads a raw signed 64-bit integer from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the integer is larger than 2^53.
   */
  readInt64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinInt64(bitsLow, bitsHigh);
  }
  /**
   * Reads a raw signed 64-bit integer from the binary stream and returns it as a
   * string.
   */
  readInt64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinSignedDecimalString(bitsLow, bitsHigh);
  }
  /**
   * Reads a 32-bit floating-point number from the binary stream, using the
   * temporary buffer to realign the data.
   */
  readFloat() {
    const bitsLow = this.readUint32();
    return joinFloat32(bitsLow);
  }
  /**
   * Reads a 64-bit floating-point number from the binary stream, using the
   * temporary buffer to realign the data.
   */
  readDouble() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinFloat64(bitsLow, bitsHigh);
  }
  /**
   * Reads a boolean value from the binary stream.
   */
  readBool() {
    return !!this.bytes_[this.cursor_++];
  }
  /**
   * Reads an enum value from the binary stream, which are always encoded as
   * signed varints.
   */
  readEnum() {
    return this.readSignedVarint32();
  }
  /**
   * Reads and parses a UTF-8 encoded unicode string from the stream.
   */
  readString(length) {
    return byteArrayToString(this.readBytes(length));
  }
  /**
   * Reads and parses a UTF-8 encoded unicode string (with length prefix) from
   * the stream.
   */
  readStringWithLength() {
    const length = this.readUnsignedVarint32();
    return this.readString(length);
  }
  /**
   * Reads a block of raw bytes from the binary stream.
   */
  readBytes(length) {
    if (length < 0 || this.cursor_ + length > this.bytes_.length) {
      this.error_ = true;
      fail("Invalid byte length!");
      return new Uint8Array(0);
    }
    const result = this.bytes_.subarray(this.cursor_, this.cursor_ + length);
    this.cursor_ += length;
    assert(this.cursor_ <= this.end_);
    return result;
  }
  /**
   * Reads a 64-bit varint from the stream and returns it as an 8-character
   * Unicode string for use as a hash table key.
   */
  readVarintHash64() {
    return this.readSplitVarint64(joinHash64);
  }
  /**
   * Reads a 64-bit fixed-width value from the stream and returns it as an
   * 8-character Unicode string for use as a hash table key.
   */
  readFixedHash64() {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    const a = bytes[cursor + 0];
    const b = bytes[cursor + 1];
    const c = bytes[cursor + 2];
    const d = bytes[cursor + 3];
    const e = bytes[cursor + 4];
    const f = bytes[cursor + 5];
    const g = bytes[cursor + 6];
    const h = bytes[cursor + 7];
    this.cursor_ += 8;
    return String.fromCharCode(a, b, c, d, e, f, g, h);
  }
};
_BinaryDecoder.instanceCache_ = [];
var BinaryDecoder = _BinaryDecoder;

// src/runtime/reader.ts
var _BinaryReader = class _BinaryReader {
  /**
   * Pops an instance off the instance cache, or creates one if the cache is
   * empty.
   */
  static alloc(opt_bytes, opt_start, opt_length) {
    const newReader = _BinaryReader.instanceCache_.pop();
    if (newReader) {
      if (opt_bytes) {
        newReader.decoder_.setBlock(opt_bytes, opt_start, opt_length);
      }
      return newReader;
    } else {
      return new _BinaryReader(opt_bytes, opt_start, opt_length);
    }
  }
  constructor(opt_bytes = void 0, opt_start = void 0, opt_length = void 0) {
    this.decoder_ = BinaryDecoder.alloc(opt_bytes, opt_start, opt_length);
    this.fieldCursor_ = this.decoder_.getCursor();
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
    this.error_ = false;
    this.readCallbacks_ = {};
  }
  /**
   * Puts this instance back in the instance cache.
   */
  free() {
    this.decoder_.clear();
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
    this.error_ = false;
    this.readCallbacks_ = {};
    if (_BinaryReader.instanceCache_.length < 100) {
      _BinaryReader.instanceCache_.push(this);
    }
  }
  /**
   * Returns the cursor immediately before the current field's tag.
   */
  getFieldCursor() {
    return this.fieldCursor_;
  }
  /**
   * Returns the internal read cursor.
   */
  getCursor() {
    return this.decoder_.getCursor();
  }
  /**
   * Returns the raw buffer.
   */
  getBuffer() {
    return this.decoder_.getBuffer();
  }
  getFieldNumber() {
    return this.nextField_;
  }
  /**
   * The wire type of the next field in the stream, or WireType.INVALID if there is no next field.
   */
  getWireType() {
    return this.nextWireType_;
  }
  /**
   * Whether the current wire type is a delimited field. Used to
   * conditionally parse packed repeated fields.
   */
  isDelimited() {
    return this.nextWireType_ == WireType.DELIMITED;
  }
  /**
   * Whether the current wire type is an end-group tag. Used as
   * an exit condition in decoder loops in generated code.
   */
  isEndGroup() {
    return this.nextWireType_ == WireType.END_GROUP;
  }
  /**
   * Returns true if this reader hit an error due to corrupt data.
   */
  getError() {
    return this.error_ || this.decoder_.getError();
  }
  /**
   * Points this reader at a new block of bytes.
   */
  setBlock(bytes, start, length) {
    this.decoder_.setBlock(bytes, start, length);
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
  }
  /**
   * Rewinds the stream cursor to the beginning of the buffer and resets all
   * internal state.
   */
  reset() {
    this.decoder_.reset();
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
  }
  /**
   * Advances the stream cursor by the given number of bytes.
   */
  advance(count) {
    this.decoder_.advance(count);
  }
  /**
   * Reads the next field header in the stream if there is one, returns true if
   * we saw a valid field header or false if we've read the whole stream.
   * Throws an error if we encountered a deprecated START_GROUP/END_GROUP field.
   *
   * True if the stream contains more fields.
   */
  nextField() {
    if (this.decoder_.atEnd()) {
      return false;
    }
    if (this.getError()) {
      fail("Decoder hit an error");
      return false;
    }
    this.fieldCursor_ = this.decoder_.getCursor();
    const header = this.decoder_.readUnsignedVarint32();
    const nextField = header >>> 3;
    const nextWireType = header & 7;
    if (nextWireType != WireType.VARINT && nextWireType != WireType.FIXED32 && nextWireType != WireType.FIXED64 && nextWireType != WireType.DELIMITED && nextWireType != WireType.START_GROUP && nextWireType != WireType.END_GROUP) {
      fail(
        `Invalid wire type: ${nextWireType} (at position ${this.fieldCursor_})`
      );
      this.error_ = true;
      return false;
    }
    this.nextField_ = nextField;
    this.nextWireType_ = nextWireType;
    return true;
  }
  /**
   * Winds the reader back to just before this field's header.
   */
  unskipHeader() {
    this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
  }
  /**
   * Skips all contiguous fields whose header matches the one we just read.
   */
  skipMatchingFields() {
    const field = this.nextField_;
    this.unskipHeader();
    while (this.nextField() && this.getFieldNumber() == field) {
      this.skipField();
    }
    if (!this.decoder_.atEnd()) {
      this.unskipHeader();
    }
  }
  /**
   * Skips over the next varint field in the binary stream.
   */
  skipVarintField() {
    if (this.nextWireType_ != WireType.VARINT) {
      fail("Invalid wire type for skipVarintField");
      this.skipField();
      return;
    }
    this.decoder_.skipVarint();
  }
  /**
   * Skips over the next delimited field in the binary stream.
   */
  skipDelimitedField() {
    if (this.nextWireType_ != WireType.DELIMITED) {
      fail("Invalid wire type for skipDelimitedField");
      this.skipField();
      return;
    }
    const length = this.decoder_.readUnsignedVarint32();
    this.decoder_.advance(length);
  }
  /**
   * Skips over the next fixed32 field in the binary stream.
   */
  skipFixed32Field() {
    if (this.nextWireType_ != WireType.FIXED32) {
      fail("Invalid wire type for skipFixed32Field");
      this.skipField();
      return;
    }
    this.decoder_.advance(4);
  }
  /**
   * Skips over the next fixed64 field in the binary stream.
   */
  skipFixed64Field() {
    if (this.nextWireType_ != WireType.FIXED64) {
      fail("Invalid wire type for skipFixed64Field");
      this.skipField();
      return;
    }
    this.decoder_.advance(8);
  }
  /**
   * Skips over the next group field in the binary stream.
   */
  skipGroup() {
    const previousField = this.nextField_;
    while (true) {
      if (!this.nextField()) {
        fail("Unmatched start-group tag: stream EOF");
        this.error_ = true;
        return;
      }
      if (this.nextWireType_ == WireType.END_GROUP) {
        if (this.nextField_ != previousField) {
          fail("Unmatched end-group tag");
          this.error_ = true;
          return;
        }
        return;
      }
      this.skipField();
    }
  }
  /**
   * Skips over the next field in the binary stream - this is useful if we're
   * decoding a message that contain unknown fields.
   */
  skipField() {
    switch (this.nextWireType_) {
      case WireType.VARINT:
        this.skipVarintField();
        break;
      case WireType.FIXED64:
        this.skipFixed64Field();
        break;
      case WireType.DELIMITED:
        this.skipDelimitedField();
        break;
      case WireType.FIXED32:
        this.skipFixed32Field();
        break;
      case WireType.START_GROUP:
        this.skipGroup();
        break;
      default:
        fail("Invalid wire encoding for field.");
    }
  }
  /**
   * Registers a user-defined read callback.
   */
  registerReadCallback(callbackName, callback) {
    assert(!this.readCallbacks_[callbackName]);
    this.readCallbacks_[callbackName] = callback;
  }
  /**
   * Runs a registered read callback.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  runReadCallback(callbackName) {
    const callback = this.readCallbacks_[callbackName];
    assert(!!callback);
    return callback(this);
  }
  /**
   * Reads a field of any valid non-message type from the binary stream.
   */
  readAny(fieldType) {
    this.nextWireType_ = FieldTypeToWireType(fieldType);
    switch (fieldType) {
      case FieldType.DOUBLE:
        return this.readDouble();
      case FieldType.FLOAT:
        return this.readFloat();
      case FieldType.INT64:
        return this.readInt64();
      case FieldType.UINT64:
        return this.readUint64();
      case FieldType.INT32:
        return this.readInt32();
      case FieldType.FIXED64:
        return this.readFixed64();
      case FieldType.FIXED32:
        return this.readFixed32();
      case FieldType.BOOL:
        return this.readBool();
      case FieldType.STRING:
        return this.readString();
      case FieldType.GROUP:
        fail("Group field type not supported in readAny()");
        break;
      case FieldType.MESSAGE:
        fail("Message field type not supported in readAny()");
        break;
      case FieldType.BYTES:
        return this.readBytes();
      case FieldType.UINT32:
        return this.readUint32();
      case FieldType.ENUM:
        return this.readEnum();
      case FieldType.SFIXED32:
        return this.readSfixed32();
      case FieldType.SFIXED64:
        return this.readSfixed64();
      case FieldType.SINT32:
        return this.readSint32();
      case FieldType.SINT64:
        return this.readSint64();
      case FieldType.FHASH64:
        return this.readFixedHash64();
      case FieldType.VHASH64:
        return this.readVarintHash64();
      default:
        fail("Invalid field type in readAny()");
    }
    return 0;
  }
  /**
   * Deserialize a proto into the provided message object using the provided
   * reader function. This function is templated as we currently have one client
   * who is using manual deserialization instead of the code-generated versions.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  readMessage(message, reader) {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const oldEnd = this.decoder_.getEnd();
    const length = this.decoder_.readUnsignedVarint32();
    const newEnd = this.decoder_.getCursor() + length;
    this.decoder_.setEnd(newEnd);
    reader(message, this);
    this.decoder_.setCursor(newEnd);
    this.decoder_.setEnd(oldEnd);
  }
  /**
   * Deserialize a proto into the provided message object using the provided
   * reader function, assuming that the message is serialized as a group
   * with the given tag.
   */
  readGroup(field, message, reader) {
    assert(this.nextWireType_ == WireType.START_GROUP);
    assert(this.nextField_ == field);
    reader(message, this);
    if (!this.error_ && this.nextWireType_ != WireType.END_GROUP) {
      fail("Group submessage did not end with an END_GROUP tag");
      this.error_ = true;
    }
  }
  /**
   * Return a decoder that wraps the current delimited field.
   */
  getFieldDecoder() {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    const start = this.decoder_.getCursor();
    const end = start + length;
    const innerDecoder = BinaryDecoder.alloc(
      this.decoder_.getBuffer(),
      start,
      length
    );
    this.decoder_.setCursor(end);
    return innerDecoder;
  }
  /**
   * Reads a signed 32-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readInt32() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint32();
  }
  /**
   * Reads a signed 32-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readInt32String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint32String();
  }
  /**
   * Reads a signed 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readInt64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint64();
  }
  /**
   * Reads a signed 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * Returns the value as a string.
   */
  readInt64String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint64String();
  }
  /**
   * Reads an unsigned 32-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readUint32() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint32();
  }
  /**
   * Reads an unsigned 32-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * Returns the value as a string.
   */
  readUint32String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint32String();
  }
  /**
   * Reads an unsigned 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readUint64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint64();
  }
  /**
   * Reads an unsigned 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * Returns the value as a string.
   */
  readUint64String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint64String();
  }
  /**
   * Reads a signed zigzag-encoded 32-bit integer field from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   */
  readSint32() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarint32();
  }
  /**
   * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   */
  readSint64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarint64();
  }
  /**
   * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   */
  readSint64String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarint64String();
  }
  /**
   * Reads an unsigned 32-bit fixed-length integer fiield from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   */
  readFixed32() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readUint32();
  }
  /**
   * Reads an unsigned 64-bit fixed-length integer fiield from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   */
  readFixed64() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readUint64();
  }
  /**
   * Reads a signed 64-bit integer field from the binary stream as a string, or
   * throws an error if the next field in the stream is not of the correct wire
   * type.
   *
   * Returns the value as a string.
   */
  readFixed64String() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readUint64String();
  }
  /**
   * Reads a signed 32-bit fixed-length integer fiield from the binary stream, or
   * throws an error if the next field in the stream is not of the correct wire
   * type.
   */
  readSfixed32() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readInt32();
  }
  /**
   * Reads a signed 32-bit fixed-length integer fiield from the binary stream, or
   * throws an error if the next field in the stream is not of the correct wire
   * type.
   */
  readSfixed32String() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readInt32().toString();
  }
  /**
   * Reads a signed 64-bit fixed-length integer fiield from the binary stream, or
   * throws an error if the next field in the stream is not of the correct wire
   * type
   */
  readSfixed64() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readInt64();
  }
  /**
   * Reads a signed 64-bit fixed-length integer fiield from the binary stream, or
   * throws an error if the next field in the stream is not of the correct wire
   * type.
   *
   * Returns the value as a string.
   */
  readSfixed64String() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readInt64String();
  }
  /**
   * Reads a 32-bit floating-point field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readFloat() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readFloat();
  }
  /**
   * Reads a 64-bit floating-point field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   */
  readDouble() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readDouble();
  }
  /**
   * Reads a boolean field from the binary stream, or throws an error if the next
   * field in the stream is not of the correct wire type.
   */
  readBool() {
    assert(this.nextWireType_ == WireType.VARINT);
    return !!this.decoder_.readUnsignedVarint32();
  }
  /**
   * Reads an enum field from the binary stream, or throws an error if the next
   * field in the stream is not of the correct wire type.
   */
  readEnum() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint64();
  }
  /**
   * Reads a string field from the binary stream, or throws an error if the next
   * field in the stream is not of the correct wire type.
   */
  readString() {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(length);
  }
  /**
   * Reads a length-prefixed block of bytes from the binary stream, or returns
   * null if the next field in the stream has an invalid length value.
   */
  readBytes() {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(length);
  }
  /**
   * Reads a 64-bit varint or fixed64 field from the stream and returns it as an
   * 8-character Unicode string for use as a hash table key, or throws an error
   * if the next field in the stream is not of the correct wire type.
   */
  readVarintHash64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readVarintHash64();
  }
  /**
   * Reads an sint64 field from the stream and returns it as an 8-character
   * Unicode string for use as a hash table key, or throws an error if the next
   * field in the stream is not of the correct wire type.
   */
  readSintHash64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarintHash64();
  }
  /**
   * Reads a 64-bit varint field from the stream and invokes `convert` to produce
   * the return value, or throws an error if the next field in the stream is not
   * of the correct wire type.
   */
  readSplitVarint64(convert) {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSplitVarint64(convert);
  }
  /**
   * Reads a 64-bit varint or fixed64 field from the stream and returns it as a
   * 8-character Unicode string for use as a hash table key, or throws an error
   * if the next field in the stream is not of the correct wire type.
   */
  readFixedHash64() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readFixedHash64();
  }
  /**
   * Reads a 64-bit fixed64 field from the stream and invokes `convert`
   * to produce the return value, or throws an error if the next field in the
   * stream is not of the correct wire type.
   */
  readSplitFixed64(convert) {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readSplitFixed64(convert);
  }
  /**
   * Reads a packed scalar field using the supplied raw reader function.
   */
  readPackedField_(decodeMethod) {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    const end = this.decoder_.getCursor() + length;
    const result = [];
    while (this.decoder_.getCursor() < end) {
      result.push(decodeMethod.call(this.decoder_));
    }
    return result;
  }
  /**
   * Reads a packed int32 field, which consists of a length header and a list of
   * signed varints.
   */
  readPackedInt32() {
    return this.readPackedField_(this.decoder_.readSignedVarint32);
  }
  /**
   * Reads a packed int32 field, which consists of a length header and a list of
   * signed varints. Returns a list of strings.
   */
  readPackedInt32String() {
    return this.readPackedField_(this.decoder_.readSignedVarint32String);
  }
  /**
   * Reads a packed int64 field, which consists of a length header and a list of
   * signed varints.
   */
  readPackedInt64() {
    return this.readPackedField_(this.decoder_.readSignedVarint64);
  }
  /**
   * Reads a packed int64 field, which consists of a length header and a list of
   * signed varints. Returns a list of strings.
   */
  readPackedInt64String() {
    return this.readPackedField_(this.decoder_.readSignedVarint64String);
  }
  /**
   * Reads a packed uint32 field, which consists of a length header and a list of
   * unsigned varints.
   */
  readPackedUint32() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32);
  }
  /**
   * Reads a packed uint32 field, which consists of a length header and a list of
   * unsigned varints. Returns a list of strings.
   */
  readPackedUint32String() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
  }
  /**
   * Reads a packed uint64 field, which consists of a length header and a list of
   * unsigned varints.
   */
  readPackedUint64() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64);
  }
  /**
   * Reads a packed uint64 field, which consists of a length header and a list of
   * unsigned varints. Returns a list of strings.
   */
  readPackedUint64String() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
  }
  /**
   * Reads a packed sint32 field, which consists of a length header and a list of
   * zigzag varints.
   */
  readPackedSint32() {
    return this.readPackedField_(this.decoder_.readZigzagVarint32);
  }
  /**
   * Reads a packed sint64 field, which consists of a length header and a list of
   * zigzag varints.
   */
  readPackedSint64() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64);
  }
  /**
   * Reads a packed sint64 field, which consists of a length header and a list of
   * zigzag varints.  Returns a list of strings.
   */
  readPackedSint64String() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64String);
  }
  /**
   * Reads a packed fixed32 field, which consists of a length header and a list
   * of unsigned 32-bit ints.
   */
  readPackedFixed32() {
    return this.readPackedField_(this.decoder_.readUint32);
  }
  /**
   * Reads a packed fixed64 field, which consists of a length header and a list
   * of unsigned 64-bit ints.
   */
  readPackedFixed64() {
    return this.readPackedField_(this.decoder_.readUint64);
  }
  /**
   * Reads a packed fixed64 field, which consists of a length header and a list
   * of unsigned 64-bit ints.  Returns a list of strings.
   */
  readPackedFixed64String() {
    return this.readPackedField_(this.decoder_.readUint64String);
  }
  /**
   * Reads a packed sfixed32 field, which consists of a length header and a list
   * of 32-bit ints.
   */
  readPackedSfixed32() {
    return this.readPackedField_(this.decoder_.readInt32);
  }
  /**
   * Reads a packed sfixed64 field, which consists of a length header and a list
   * of 64-bit ints.
   */
  readPackedSfixed64() {
    return this.readPackedField_(this.decoder_.readInt64);
  }
  /**
   * Reads a packed sfixed64 field, which consists of a length header and a list
   * of 64-bit ints.  Returns a list of strings.
   */
  readPackedSfixed64String() {
    return this.readPackedField_(this.decoder_.readInt64String);
  }
  /**
   * Reads a packed float field, which consists of a length header and a list of
   * floats.
   */
  readPackedFloat() {
    return this.readPackedField_(this.decoder_.readFloat);
  }
  /**
   * Reads a packed double field, which consists of a length header and a list of
   * doubles.
   */
  readPackedDouble() {
    return this.readPackedField_(this.decoder_.readDouble);
  }
  /**
   * Reads a packed bool field, which consists of a length header and a list of
   * unsigned varints.
   */
  readPackedBool() {
    return this.readPackedField_(this.decoder_.readBool);
  }
  /**
   * Reads a packed enum field, which consists of a length header and a list of
   * unsigned varints.
   */
  readPackedEnum() {
    return this.readPackedField_(this.decoder_.readEnum);
  }
  /**
   * Reads a packed varint hash64 field, which consists of a length header and a
   * list of varint hash64s.
   */
  readPackedVarintHash64() {
    return this.readPackedField_(this.decoder_.readVarintHash64);
  }
  /**
   * Reads a packed fixed hash64 field, which consists of a length header and a
   * list of fixed hash64s.
   */
  readPackedFixedHash64() {
    return this.readPackedField_(this.decoder_.readFixedHash64);
  }
};
/**
 * Global pool of BinaryReader instances.
 */
_BinaryReader.instanceCache_ = [];
var BinaryReader = _BinaryReader;

// src/runtime/encoder.ts
var BinaryEncoder = class {
  constructor() {
    this.buffer_ = [];
  }
  length() {
    return this.buffer_.length;
  }
  end() {
    const buffer = this.buffer_;
    this.buffer_ = [];
    return buffer;
  }
  /**
   * Encodes a 64-bit integer in 32:32 split representation into its wire-format
   * varint representation and stores it in the buffer.
   */
  writeSplitVarint64(lowBits, highBits) {
    assert(lowBits == Math.floor(lowBits));
    assert(highBits == Math.floor(highBits));
    assert(lowBits >= 0 && lowBits < TWO_TO_32);
    assert(highBits >= 0 && highBits < TWO_TO_32);
    while (highBits > 0 || lowBits > 127) {
      this.buffer_.push(lowBits & 127 | 128);
      lowBits = (lowBits >>> 7 | highBits << 25) >>> 0;
      highBits = highBits >>> 7;
    }
    this.buffer_.push(lowBits);
  }
  /**
   * Encodes a 64-bit integer in 32:32 split representation into its wire-format
   * fixed representation and stores it in the buffer.
   */
  writeSplitFixed64(lowBits, highBits) {
    assert(lowBits == Math.floor(lowBits));
    assert(highBits == Math.floor(highBits));
    assert(lowBits >= 0 && lowBits < TWO_TO_32);
    assert(highBits >= 0 && highBits < TWO_TO_32);
    this.writeUint32(lowBits);
    this.writeUint32(highBits);
  }
  /**
   * Encodes a 32-bit unsigned integer into its wire-format varint representation
   * and stores it in the buffer.
   */
  writeUnsignedVarint32(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_32);
    while (value > 127) {
      this.buffer_.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buffer_.push(value);
  }
  /**
   * Encodes a 32-bit signed integer into its wire-format varint representation
   * and stores it in the buffer.
   */
  writeSignedVarint32(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    if (value >= 0) {
      this.writeUnsignedVarint32(value);
      return;
    }
    for (let i = 0; i < 9; i++) {
      this.buffer_.push(value & 127 | 128);
      value = value >> 7;
    }
    this.buffer_.push(1);
  }
  /**
   * Encodes a 64-bit unsigned integer into its wire-format varint representation
   * and stores it in the buffer. Integers that are not representable in 64 bits
   * will be truncated.
   */
  writeUnsignedVarint64(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_64);
    splitInt64(value);
    this.writeSplitVarint64(split64Low, split64High);
  }
  /**
   * Encodes a 64-bit signed integer into its wire-format varint representation
   * and stores it in the buffer. Integers that are not representable in 64 bits
   * will be truncated.
   */
  writeSignedVarint64(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    splitInt64(value);
    this.writeSplitVarint64(split64Low, split64High);
  }
  /**
   * Encodes a JavaScript integer into its wire-format, zigzag-encoded varint
   * representation and stores it in the buffer.
   */
  writeZigzagVarint32(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeUnsignedVarint32((value << 1 ^ value >> 31) >>> 0);
  }
  /**
   * Encodes a JavaScript integer into its wire-format, zigzag-encoded varint
   * representation and stores it in the buffer. Integers not representable in 64
   * bits will be truncated.
   */
  writeZigzagVarint64(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    splitZigzag64(value);
    this.writeSplitVarint64(split64Low, split64High);
  }
  /**
   * Encodes a JavaScript decimal string into its wire-format, zigzag-encoded
   * varint representation and stores it in the buffer. Integers not representable
   * in 64 bits will be truncated.
   */
  writeZigzagVarint64String(value) {
    this.writeZigzagVarintHash64(decimalStringToHash64(value));
  }
  /**
   * Writes a 64-bit hash string (8 characters @ 8 bits of data each) to the
   * buffer as a zigzag varint.
   */
  writeZigzagVarintHash64(hash) {
    splitHash64(hash);
    toZigzag64(split64Low, split64High, (lo, hi) => {
      this.writeSplitVarint64(lo >>> 0, hi >>> 0);
    });
  }
  /**
   * Writes an 8-bit unsigned integer to the buffer. Numbers outside the range
   * [0,2^8) will be truncated.
   */
  writeUint8(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < 256);
    this.buffer_.push(value >>> 0 & 255);
  }
  /**
   * Writes a 16-bit unsigned integer to the buffer. Numbers outside the
   * range [0,2^16) will be truncated.
   */
  writeUint16(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < 65536);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
  }
  /**
   * Writes a 32-bit unsigned integer to the buffer. Numbers outside the
   * range [0,2^32) will be truncated.
   */
  writeUint32(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_32);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
    this.buffer_.push(value >>> 16 & 255);
    this.buffer_.push(value >>> 24 & 255);
  }
  /**
   * Writes a 64-bit unsigned integer to the buffer. Numbers outside the
   * range [0,2^64) will be truncated.
   */
  writeUint64(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_64);
    splitUint64(value);
    this.writeUint32(split64Low);
    this.writeUint32(split64High);
  }
  /**
   * Writes an 8-bit integer to the buffer. Numbers outside the range
   * [-2^7,2^7) will be truncated.
   */
  writeInt8(value) {
    assert(value == Math.floor(value));
    assert(value >= -128 && value < 128);
    this.buffer_.push(value >>> 0 & 255);
  }
  /**
   * Writes a 16-bit integer to the buffer. Numbers outside the range
   * [-2^15,2^15) will be truncated.
   */
  writeInt16(value) {
    assert(value == Math.floor(value));
    assert(value >= -32768 && value < 32768);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
  }
  /**
   * Writes a 32-bit integer to the buffer. Numbers outside the range
   * [-2^31,2^31) will be truncated.
   */
  writeInt32(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
    this.buffer_.push(value >>> 16 & 255);
    this.buffer_.push(value >>> 24 & 255);
  }
  /**
   * Writes a 64-bit integer to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   */
  writeInt64(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    splitInt64(value);
    this.writeSplitFixed64(split64Low, split64High);
  }
  /**
   * Writes a 64-bit integer decimal strings to the buffer. Numbers outside the
   * range [-2^63,2^63) will be truncated.
   */
  writeInt64String(value) {
    assert(
      value == Math.floor(value)
    );
    assert(+value >= -TWO_TO_63 && +value < TWO_TO_63);
    splitHash64(decimalStringToHash64(value));
    this.writeSplitFixed64(split64Low, split64High);
  }
  /**
   * Writes a single-precision floating point value to the buffer. Numbers
   * requiring more than 32 bits of precision will be truncated.
   */
  writeFloat(value) {
    assert(
      value === Infinity || value === -Infinity || isNaN(value) || value >= -FLOAT32_MAX && value <= FLOAT32_MAX
    );
    splitFloat32(value);
    this.writeUint32(split64Low);
  }
  /**
   * Writes a double-precision floating point value to the buffer. As this is
   * the native format used by JavaScript, no precision will be lost.
   */
  writeDouble(value) {
    assert(
      value === Infinity || value === -Infinity || isNaN(value) || value >= -FLOAT64_MAX && value <= FLOAT64_MAX
    );
    splitFloat64(value);
    this.writeUint32(split64Low);
    this.writeUint32(split64High);
  }
  /**
   * Writes a boolean value to the buffer as a varint. We allow numbers as input
   * because the JSPB code generator uses 0/1 instead of true/false to save space
   * in the string representation of the proto.
   */
  writeBool(value) {
    assert(typeof value === "boolean" || typeof value === "number");
    this.buffer_.push(value ? 1 : 0);
  }
  /**
   * Writes an enum value to the buffer as a varint.
   */
  writeEnum(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeSignedVarint32(value);
  }
  /**
   * Writes an arbitrary byte array to the buffer.
   */
  writeBytes(bytes) {
    this.buffer_.push(...bytes);
  }
  /**
   * Writes a 64-bit hash string (8 characters @ 8 bits of data each) to the
   * buffer as a varint.
   */
  writeVarintHash64(hash) {
    splitHash64(hash);
    this.writeSplitVarint64(split64Low, split64High);
  }
  /**
   * Writes a 64-bit hash string (8 characters @ 8 bits of data each) to the
   * buffer as a fixed64.
   */
  writeFixedHash64(hash) {
    splitHash64(hash);
    this.writeUint32(split64Low);
    this.writeUint32(split64High);
  }
  /**
   * Writes a UTF16 Javascript string to the buffer encoded as UTF8.
   */
  writeString(value) {
    const oldLength = this.buffer_.length;
    const buffer = stringToUint8Array(value);
    buffer.forEach((val) => this.buffer_.push(val));
    const length = this.buffer_.length - oldLength;
    return length;
  }
};

// src/runtime/arith.ts
var UInt64 = class _UInt64 {
  constructor(bigint, lo, hi) {
    this.bigint = bigint;
    this.lo = lo;
    this.hi = hi;
  }
  toString() {
    return this.bigint.toString();
  }
  static fromString(s) {
    const bigint = BigInt.asUintN(64, BigInt(s));
    const lo = Number(BigInt.asUintN(32, bigint));
    const hi = Number(bigint >> BigInt(32));
    return new _UInt64(bigint, lo, hi);
  }
};
var Int64 = class _Int64 extends UInt64 {
  static fromString(s) {
    const bigint = BigInt.asIntN(64, BigInt(s));
    const { lo, hi } = UInt64.fromString(s);
    return new _Int64(bigint, lo, hi);
  }
};

// src/runtime/writer.ts
var BinaryWriter = class {
  constructor() {
    this.blocks_ = [];
    this.totalLength_ = 0;
    this.encoder_ = new BinaryEncoder();
  }
  /**
   * Append a typed array of bytes onto the buffer.
   */
  appendUint8Array_(arr) {
    const temp = this.encoder_.end();
    this.blocks_.push(temp);
    this.blocks_.push(arr);
    this.totalLength_ += temp.length + arr.length;
  }
  /**
   * Begins a new message by writing the field header and returning a bookmark
   * which we will use to patch in the message length to in endDelimited_ below.
   */
  beginDelimited_(field) {
    this.writeFieldHeader_(field, WireType.DELIMITED);
    const bookmark = this.encoder_.end();
    this.blocks_.push(bookmark);
    this.totalLength_ += bookmark.length;
    bookmark.push(this.totalLength_);
    return bookmark;
  }
  /**
   * Ends a message by encoding the _change_ in length of the buffer to the
   * parent block and adds the number of bytes needed to encode that length to
   * the total byte length.
   */
  endDelimited_(bookmark) {
    const oldLength = bookmark.pop() ?? 0;
    let messageLength = this.totalLength_ + this.encoder_.length() - oldLength;
    assert(messageLength >= 0);
    while (messageLength > 127) {
      bookmark.push(messageLength & 127 | 128);
      messageLength = messageLength >>> 7;
      this.totalLength_++;
    }
    bookmark.push(messageLength);
    this.totalLength_++;
  }
  /**
   * Writes a pre-serialized message to the buffer.
   */
  writeSerializedMessage(bytes, start, end) {
    this.appendUint8Array_(bytes.subarray(start, end));
  }
  /**
   * Writes a pre-serialized message to the buffer if the message and endpoints
   * are non-null.
   */
  maybeWriteSerializedMessage(bytes, start, end) {
    if (bytes != null && start != null && end != null) {
      this.writeSerializedMessage(bytes, start, end);
    }
  }
  /**
   * Resets the writer, throwing away any accumulated buffers.
   */
  reset() {
    this.blocks_ = [];
    this.encoder_.end();
    this.totalLength_ = 0;
  }
  /**
   * Converts the encoded data into a Uint8Array.
   */
  getResultBuffer() {
    const flat = new Uint8Array(this.totalLength_ + this.encoder_.length());
    const blocks = this.blocks_;
    const blockCount = blocks.length;
    let offset = 0;
    for (let i = 0; i < blockCount; i++) {
      const block = blocks[i];
      flat.set(block, offset);
      offset += block.length;
    }
    const tail = this.encoder_.end();
    flat.set(tail, offset);
    offset += tail.length;
    assert(offset == flat.length);
    this.blocks_ = [flat];
    return flat;
  }
  /**
   * Encodes a (field number, wire type) tuple into a wire-format field header
   * and stores it in the buffer as a varint.
   */
  writeFieldHeader_(field, wireType) {
    assert(field >= 1 && field == Math.floor(field));
    const x = field * 8 + wireType;
    this.encoder_.writeUnsignedVarint32(x);
  }
  /**
   * Writes a field of any valid scalar type to the binary stream.
   */
  writeAny(fieldType, field, value) {
    switch (fieldType) {
      case FieldType.DOUBLE:
        this.writeDouble(field, value);
        return;
      case FieldType.FLOAT:
        this.writeFloat(field, value);
        return;
      case FieldType.INT64:
        this.writeInt64(field, value);
        return;
      case FieldType.UINT64:
        this.writeUint64(field, value);
        return;
      case FieldType.INT32:
        this.writeInt32(field, value);
        return;
      case FieldType.FIXED64:
        this.writeFixed64(field, value);
        return;
      case FieldType.FIXED32:
        this.writeFixed32(field, value);
        return;
      case FieldType.BOOL:
        this.writeBool(field, value);
        return;
      case FieldType.STRING:
        this.writeString(field, value);
        return;
      case FieldType.GROUP:
        fail("Group field type not supported in writeAny()");
        return;
      case FieldType.MESSAGE:
        fail("Message field type not supported in writeAny()");
        return;
      case FieldType.BYTES:
        this.writeBytes(field, value);
        return;
      case FieldType.UINT32:
        this.writeUint32(field, value);
        return;
      case FieldType.ENUM:
        this.writeEnum(field, value);
        return;
      case FieldType.SFIXED32:
        this.writeSfixed32(field, value);
        return;
      case FieldType.SFIXED64:
        this.writeSfixed64(field, value);
        return;
      case FieldType.SINT32:
        this.writeSint32(field, value);
        return;
      case FieldType.SINT64:
        this.writeSint64(field, value);
        return;
      case FieldType.FHASH64:
        this.writeFixedHash64(field, value);
        return;
      case FieldType.VHASH64:
        this.writeVarintHash64(field, value);
        return;
      default:
        fail("Invalid field type in writeAny()");
        return;
    }
  }
  /**
   * Writes a varint field to the buffer without range checking.
   */
  writeUnsignedVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeUnsignedVarint32(value);
  }
  /**
   * Writes a varint field to the buffer without range checking.
   */
  writeSignedVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }
  /**
   * Writes a varint field to the buffer without range checking.
   */
  writeUnsignedVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeUnsignedVarint64(value);
  }
  /**
   * Writes a varint field to the buffer without range checking.
   */
  writeSignedVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint64(value);
  }
  /**
   * Writes a zigzag varint field to the buffer without range checking.
   */
  writeZigzagVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint32(value);
  }
  /**
   * Writes a zigzag varint field to the buffer without range checking.
   */
  writeZigzagVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint64(value);
  }
  /**
   * Writes a zigzag varint field to the buffer without range checking.
   */
  writeZigzagVarint64String_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint64String(value);
  }
  /**
   * Writes a zigzag varint field to the buffer without range checking.
   */
  writeZigzagVarintHash64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarintHash64(value);
  }
  /**
   * Writes an int32 field to the buffer. Numbers outside the range [-2^31,2^31)
   * will be truncated.
   */
  writeInt32(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeSignedVarint32_(field, value);
  }
  /**
   * Writes an int32 field represented as a string to the buffer. Numbers outside
   * the range [-2^31,2^31) will be truncated.
   */
  writeInt32String(field, value) {
    if (value == null)
      return;
    const intValue = (
      /** {number} */
      parseInt(value, 10)
    );
    assert(intValue >= -TWO_TO_31 && intValue < TWO_TO_31);
    this.writeSignedVarint32_(field, intValue);
  }
  /**
   * Writes an int64 field to the buffer. Numbers outside the range [-2^63,2^63)
   * will be truncated.
   */
  writeInt64(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    this.writeSignedVarint64_(field, value);
  }
  /**
   * Writes a int64 field (with value as a string) to the buffer.
   */
  writeInt64String(field, value) {
    if (value == null)
      return;
    const num = Int64.fromString(value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }
  /**
   * Writes a uint32 field to the buffer. Numbers outside the range [0,2^32)
   * will be truncated.
   */
  writeUint32(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_32);
    this.writeUnsignedVarint32_(field, value);
  }
  /**
   * Writes a uint32 field represented as a string to the buffer. Numbers outside
   * the range [0,2^32) will be truncated.
   */
  writeUint32String(field, value) {
    if (value == null)
      return;
    const intValue = (
      /** {number} */
      parseInt(value, 10)
    );
    assert(intValue >= 0 && intValue < TWO_TO_32);
    this.writeUnsignedVarint32_(field, intValue);
  }
  /**
   * Writes a uint64 field to the buffer. Numbers outside the range [0,2^64)
   * will be truncated.
   */
  writeUint64(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_64);
    this.writeUnsignedVarint64_(field, value);
  }
  /**
   * Writes a uint64 field (with value as a string) to the buffer.
   */
  writeUint64String(field, value) {
    if (value == null)
      return;
    const num = UInt64.fromString(value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }
  /**
   * Writes an sint32 field to the buffer. Numbers outside the range [-2^31,2^31)
   * will be truncated.
   */
  writeSint32(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeZigzagVarint32_(field, value);
  }
  /**
   * Writes an sint64 field to the buffer. Numbers outside the range [-2^63,2^63)
   * will be truncated.
   */
  writeSint64(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    this.writeZigzagVarint64_(field, value);
  }
  /**
   * Writes an sint64 field to the buffer from a hash64 encoded value. Numbers
   * outside the range [-2^63,2^63) will be truncated.
   */
  writeSintHash64(field, value) {
    if (value == null)
      return;
    this.writeZigzagVarintHash64_(field, value);
  }
  /**
   * Writes an sint64 field to the buffer. Numbers outside the range [-2^63,2^63)
   * will be truncated.
   */
  writeSint64String(field, value) {
    if (value == null)
      return;
    this.writeZigzagVarint64String_(field, value);
  }
  /**
   * Writes a fixed32 field to the buffer. Numbers outside the range [0,2^32)
   * will be truncated.
   */
  writeFixed32(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_32);
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeUint32(value);
  }
  /**
   * Writes a fixed64 field to the buffer. Numbers outside the range [0,2^64)
   * will be truncated.
   */
  writeFixed64(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_64);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeUint64(value);
  }
  /**
   * Writes a fixed64 field (with value as a string) to the buffer.
   */
  writeFixed64String(field, value) {
    if (value == null)
      return;
    const num = UInt64.fromString(value);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }
  /**
   * Writes a sfixed32 field to the buffer. Numbers outside the range
   * [-2^31,2^31) will be truncated.
   */
  writeSfixed32(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeInt32(value);
  }
  /**
   * Writes a sfixed64 field to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   */
  writeSfixed64(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeInt64(value);
  }
  /**
   * Writes a sfixed64 string field to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   */
  writeSfixed64String(field, value) {
    if (value == null)
      return;
    const num = Int64.fromString(value);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }
  /**
   * Writes a single-precision floating point field to the buffer. Numbers
   * requiring more than 32 bits of precision will be truncated.
   */
  writeFloat(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeFloat(value);
  }
  /**
   * Writes a double-precision floating point field to the buffer. As this is the
   * native format used by JavaScript, no precision will be lost.
   */
  writeDouble(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeDouble(value);
  }
  /**
   * Writes a boolean field to the buffer. We allow numbers as input
   * because the JSPB code generator uses 0/1 instead of true/false to save space
   * in the string representation of the proto.
   */
  writeBool(field, value) {
    if (value == null)
      return;
    assert(typeof value === "boolean" || typeof value === "number");
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeBool(value);
  }
  /**
   * Writes an enum field to the buffer.
   */
  writeEnum(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }
  /**
   * Writes a string field to the buffer.
   */
  writeString(field, value) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    this.encoder_.writeString(value);
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an arbitrary byte field to the buffer. Note - to match the behavior
   * of the C++ implementation, empty byte arrays _are_ serialized.
   */
  writeBytes(field, value) {
    if (value == null)
      return;
    const bytes = byteSourceToUint8Array(value);
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(bytes.length);
    this.appendUint8Array_(bytes);
  }
  /**
   * Writes a message to the buffer.
   */
  writeMessage(field, value, writerCallback) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
  }
  /**
   * Writes a message set extension to the buffer.
   */
  writeMessageSet(field, value, writerCallback) {
    if (value == null)
      return;
    this.writeFieldHeader_(1, WireType.START_GROUP);
    this.writeFieldHeader_(2, WireType.VARINT);
    this.encoder_.writeSignedVarint32(field);
    const bookmark = this.beginDelimited_(3);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
    this.writeFieldHeader_(1, WireType.END_GROUP);
  }
  /**
   * Writes a group message to the buffer.
   */
  writeGroup(field, value, writerCallback) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.START_GROUP);
    writerCallback(value, this);
    this.writeFieldHeader_(field, WireType.END_GROUP);
  }
  /**
   * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to
   * the buffer.
   */
  writeFixedHash64(field, value) {
    if (value == null)
      return;
    assert(value.length == 8);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeFixedHash64(value);
  }
  /**
   * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to
   * the buffer.
   */
  writeVarintHash64(field, value) {
    if (value == null)
      return;
    assert(value.length == 8);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeVarintHash64(value);
  }
  /**
   * Writes a 64-bit field to the buffer as a fixed64.
   */
  writeSplitFixed64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(lowBits, highBits);
  }
  /**
   * Writes a 64-bit field to the buffer as a varint.
   */
  writeSplitVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(lowBits, highBits);
  }
  /**
   * Writes a 64-bit field to the buffer as a zigzag encoded varint.
   */
  writeSplitZigzagVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.VARINT);
    const encoder2 = this.encoder_;
    toZigzag64(lowBits, highBits, function(lowBits2, highBits2) {
      encoder2.writeSplitVarint64(lowBits2 >>> 0, highBits2 >>> 0);
    });
  }
  /**
   * Writes an array of numbers to the buffer as a repeated 32-bit int field.
   */
  writeRepeatedInt32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint32_(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers formatted as strings to the buffer as a repeated
   * 32-bit int field.
   */
  writeRepeatedInt32String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt32String(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated 64-bit int field.
   */
  writeRepeatedInt64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint64_(field, value[i]);
    }
  }
  /**
   * Writes an array of 64-bit values to the buffer as a fixed64.
   */
  writeRepeatedSplitFixed64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitFixed64(field, lo(value[i]), hi(value[i]));
    }
  }
  /**
   * Writes an array of 64-bit values to the buffer as a varint.
   */
  writeRepeatedSplitVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitVarint64(field, lo(value[i]), hi(value[i]));
    }
  }
  /**
   * Writes an array of 64-bit values to the buffer as a zigzag varint.
   */
  writeRepeatedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitZigzagVarint64(field, lo(value[i]), hi(value[i]));
    }
  }
  /**
   * Writes an array of numbers formatted as strings to the buffer as a repeated
   * 64-bit int field.
   */
  writeRepeatedInt64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt64String(field, value[i]);
    }
  }
  /**
   * Writes an array numbers to the buffer as a repeated unsigned 32-bit int
   *     field.
   */
  writeRepeatedUint32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint32_(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers formatted as strings to the buffer as a repeated
   * unsigned 32-bit int field.
   */
  writeRepeatedUint32String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint32String(field, value[i]);
    }
  }
  /**
   * Writes an array numbers to the buffer as a repeated unsigned 64-bit int
   *     field.
   */
  writeRepeatedUint64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint64_(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers formatted as strings to the buffer as a repeated
   * unsigned 64-bit int field.
   */
  writeRepeatedUint64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint64String(field, value[i]);
    }
  }
  /**
   * Writes an array numbers to the buffer as a repeated signed 32-bit int field.
   */
  writeRepeatedSint32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint32_(field, value[i]);
    }
  }
  /**
   * Writes an array numbers to the buffer as a repeated signed 64-bit int field.
   */
  writeRepeatedSint64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64_(field, value[i]);
    }
  }
  /**
   * Writes an array numbers to the buffer as a repeated signed 64-bit int field.
   */
  writeRepeatedSint64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64String_(field, value[i]);
    }
  }
  /**
   * Writes an array of hash64 strings to the buffer as a repeated signed 64-bit
   * int field.
   */
  writeRepeatedSintHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarintHash64_(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated fixed32 field. This
   * works for both signed and unsigned fixed32s.
   */
  writeRepeatedFixed32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed32(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated fixed64 field. This
   * works for both signed and unsigned fixed64s.
   */
  writeRepeatedFixed64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated fixed64 field. This
   * works for both signed and unsigned fixed64s.
   */
  writeRepeatedFixed64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64String(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated sfixed32 field.
   */
  writeRepeatedSfixed32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed32(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated sfixed64 field.
   */
  writeRepeatedSfixed64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64(field, value[i]);
    }
  }
  /**
   * Writes an array of decimal strings to the buffer as a repeated sfixed64
   * field.
   */
  writeRepeatedSfixed64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64String(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated float field.
   */
  writeRepeatedFloat(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFloat(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a repeated double field.
   */
  writeRepeatedDouble(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeDouble(field, value[i]);
    }
  }
  /**
   * Writes an array of booleans to the buffer as a repeated bool field.
   */
  writeRepeatedBool(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeBool(field, value[i]);
    }
  }
  /**
   * Writes an array of enums to the buffer as a repeated enum field.
   */
  writeRepeatedEnum(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeEnum(field, value[i]);
    }
  }
  /**
   * Writes an array of strings to the buffer as a repeated string field.
   */
  writeRepeatedString(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeString(field, value[i]);
    }
  }
  /**
   * Writes an array of arbitrary byte fields to the buffer.
   */
  writeRepeatedBytes(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeBytes(field, value[i]);
    }
  }
  /**
   * Writes an array of messages to the buffer.
   */
  writeRepeatedMessage(field, value, writerCallback) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      const bookmark = this.beginDelimited_(field);
      writerCallback(value[i], this);
      this.endDelimited_(bookmark);
    }
  }
  /**
   * Writes an array of group messages to the buffer.
   * @template MessageType
   */
  writeRepeatedGroup(field, value, writerCallback) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFieldHeader_(field, WireType.START_GROUP);
      writerCallback(value[i], this);
      this.writeFieldHeader_(field, WireType.END_GROUP);
    }
  }
  /**
   * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to
   * the buffer.
   */
  writeRepeatedFixedHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixedHash64(field, value[i]);
    }
  }
  /**
   * Writes a repeated 64-bit hash string field (8 characters @ 8 bits of data
   * each) to the buffer.
   */
  writeRepeatedVarintHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeVarintHash64(field, value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed 32-bit int field.
   */
  writePackedInt32(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * 32-bit int field.
   */
  writePackedInt32String(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint32(parseInt(value[i], 10));
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers to the buffer as a packed 64-bit int field.
   */
  writePackedInt64(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of 64-bit values to the buffer as a fixed64.
   */
  writePackedSplitFixed64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitFixed64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of 64-bit values to the buffer as a varint.
   */
  writePackedSplitVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitVarint64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of 64-bit values to the buffer as a zigzag varint.
   */
  writePackedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    const encoder2 = this.encoder_;
    for (let i = 0; i < value.length; i++) {
      toZigzag64(lo(value[i]), hi(value[i]), function(bitsLow, bitsHigh) {
        encoder2.writeSplitVarint64(bitsLow >>> 0, bitsHigh >>> 0);
      });
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * 64-bit int field.
   */
  writePackedInt64String(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = Int64.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array numbers to the buffer as a packed unsigned 32-bit int field.
   */
  writePackedUint32(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * unsigned 32-bit int field.
   */
  writePackedUint32String(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(parseInt(value[i], 10));
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array numbers to the buffer as a packed unsigned 64-bit int field.
   */
  writePackedUint64(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * unsigned 64-bit int field.
   */
  writePackedUint64String(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = UInt64.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array numbers to the buffer as a packed signed 32-bit int field.
   */
  writePackedSint32(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers to the buffer as a packed signed 64-bit int field.
   */
  writePackedSint64(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of decimal strings to the buffer as a packed signed 64-bit
   * int field.
   */
  writePackedSint64String(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarintHash64(decimalStringToHash64(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of hash 64 strings to the buffer as a packed signed 64-bit
   * int field.
   */
  writePackedSintHash64(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarintHash64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes an array of numbers to the buffer as a packed fixed32 field.
   */
  writePackedFixed32(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint32(value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed fixed64 field.
   */
  writePackedFixed64(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint64(value[i]);
    }
  }
  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * fixed64 field.
   */
  writePackedFixed64String(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      const num = UInt64.fromString(value[i]);
      this.encoder_.writeSplitFixed64(num.lo, num.hi);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed sfixed32 field.
   */
  writePackedSfixed32(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt32(value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed sfixed64 field.
   */
  writePackedSfixed64(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64(value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed sfixed64 field.
   */
  writePackedSfixed64String(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64String(value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed float field.
   */
  writePackedFloat(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFloat(value[i]);
    }
  }
  /**
   * Writes an array of numbers to the buffer as a packed double field.
   */
  writePackedDouble(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeDouble(value[i]);
    }
  }
  /**
   * Writes an array of booleans to the buffer as a packed bool field.
   */
  writePackedBool(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeBool(value[i]);
    }
  }
  /**
   * Writes an array of enums to the buffer as a packed enum field.
   */
  writePackedEnum(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeEnum(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  /**
   * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to
   * the buffer.
   */
  writePackedFixedHash64(field, value) {
    if (!value?.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFixedHash64(value[i]);
    }
  }
  /**
   * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to
   * the buffer.
   */
  writePackedVarintHash64(field, value) {
    if (!value?.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeVarintHash64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
};

// src/runtime/json.ts
function serializeBytes(bytes) {
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function parseBytes(x) {
  let str = x.replace(/-/g, "+").replace(/_/g, "/");
  while (str.length % 4) {
    str += "=";
  }
  const binary = atob(str);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
function parseNumber(x) {
  if (typeof x === "string") {
    return parseInt(x, 10);
  }
  return x;
}
function parseDouble(x) {
  if (typeof x === "string") {
    return parseFloat(x);
  }
  return x;
}
function parseNanos(x) {
  return parseInt((x ?? "").padEnd(9, "0"), 10);
}
function serializeTimestamp({
  seconds = 0n,
  nanos = 0
}) {
  const ms = Number(seconds) * 1e3 + nanos / 1e6;
  return new Date(ms).toISOString();
}
function parseTimestamp(x) {
  const seconds = BigInt(Math.floor(new Date(x).getTime() / 1e3));
  const nanos = parseNanos(x.match(/\.(\d+)/)?.[1]);
  return { seconds, nanos };
}
function serializeDuration({
  seconds = 0n,
  nanos = 0
}) {
  const second = seconds.toString();
  if (nanos === 0) {
    return `${second}s`;
  }
  let nano = Math.abs(nanos).toString().padStart(9, "0");
  if (nano.endsWith("000000")) {
    nano = nano.slice(0, -6);
  } else if (nano.endsWith("000")) {
    nano = nano.slice(0, -3);
  }
  if (seconds === 0n && nanos < 0) {
    return `-${second}.${nano}s`;
  }
  return `${second}.${nano}s`;
}
function parseDuration(x) {
  const [seconds, nanos] = x.replace("s", "").split(".");
  return { seconds: BigInt(seconds), nanos: parseNanos(nanos) };
}

// src/runtime/well-known-types/any.pb.ts
var protoscript = __toESM(require("protoscript"), 1);
var Any = {
  /**
   * Serializes Any to protobuf.
   */
  encode: function(msg) {
    return Any._writeMessage(
      msg,
      new protoscript.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Any from protobuf.
   */
  decode: function(bytes) {
    return Any._readMessage(
      Any.initialize(),
      new protoscript.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Any with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      typeUrl: "",
      value: new Uint8Array(),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var AnyJSON = {
  /**
   * Serializes Any to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(AnyJSON._writeMessage(msg));
  },
  /**
   * Deserializes Any from JSON.
   */
  decode: function(json) {
    return AnyJSON._readMessage(AnyJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Any with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      typeUrl: "",
      value: new Uint8Array(),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.typeUrl) {
      json["typeUrl"] = msg.typeUrl;
    }
    if (msg.value?.length) {
      json["value"] = protoscript.serializeBytes(msg.value);
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _typeUrl_ = json["typeUrl"] ?? json["type_url"];
    if (_typeUrl_) {
      msg.typeUrl = _typeUrl_;
    }
    const _value_ = json["value"];
    if (_value_) {
      msg.value = protoscript.parseBytes(_value_);
    }
    return msg;
  }
};

// src/runtime/well-known-types/api.pb.ts
var protoscript2 = __toESM(require("protoscript"), 1);
var Api = {
  /**
   * Serializes Api to protobuf.
   */
  encode: function(msg) {
    return Api._writeMessage(
      msg,
      new protoscript2.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Api from protobuf.
   */
  decode: function(bytes) {
    return Api._readMessage(
      Api.initialize(),
      new protoscript2.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Api with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      methods: [],
      options: [],
      version: "",
      sourceContext: protoscript2.SourceContext.initialize(),
      mixins: [],
      syntax: protoscript2.Syntax._fromInt(0),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.methods?.length) {
      writer.writeRepeatedMessage(2, msg.methods, Method._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.options,
        protoscript2.Option._writeMessage
      );
    }
    if (msg.version) {
      writer.writeString(4, msg.version);
    }
    if (msg.sourceContext) {
      writer.writeMessage(
        5,
        msg.sourceContext,
        protoscript2.SourceContext._writeMessage
      );
    }
    if (msg.mixins?.length) {
      writer.writeRepeatedMessage(6, msg.mixins, Mixin._writeMessage);
    }
    if (msg.syntax && protoscript2.Syntax._toInt(msg.syntax)) {
      writer.writeEnum(7, protoscript2.Syntax._toInt(msg.syntax));
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Method.initialize();
          reader.readMessage(m, Method._readMessage);
          msg.methods.push(m);
          break;
        }
        case 3: {
          const m = protoscript2.Option.initialize();
          reader.readMessage(m, protoscript2.Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          msg.version = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(
            msg.sourceContext,
            protoscript2.SourceContext._readMessage
          );
          break;
        }
        case 6: {
          const m = Mixin.initialize();
          reader.readMessage(m, Mixin._readMessage);
          msg.mixins.push(m);
          break;
        }
        case 7: {
          msg.syntax = protoscript2.Syntax._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Method = {
  /**
   * Serializes Method to protobuf.
   */
  encode: function(msg) {
    return Method._writeMessage(
      msg,
      new protoscript2.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Method from protobuf.
   */
  decode: function(bytes) {
    return Method._readMessage(
      Method.initialize(),
      new protoscript2.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Method with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      requestTypeUrl: "",
      requestStreaming: false,
      responseTypeUrl: "",
      responseStreaming: false,
      options: [],
      syntax: protoscript2.Syntax._fromInt(0),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.requestTypeUrl) {
      writer.writeString(2, msg.requestTypeUrl);
    }
    if (msg.requestStreaming) {
      writer.writeBool(3, msg.requestStreaming);
    }
    if (msg.responseTypeUrl) {
      writer.writeString(4, msg.responseTypeUrl);
    }
    if (msg.responseStreaming) {
      writer.writeBool(5, msg.responseStreaming);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.options,
        protoscript2.Option._writeMessage
      );
    }
    if (msg.syntax && protoscript2.Syntax._toInt(msg.syntax)) {
      writer.writeEnum(7, protoscript2.Syntax._toInt(msg.syntax));
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.requestTypeUrl = reader.readString();
          break;
        }
        case 3: {
          msg.requestStreaming = reader.readBool();
          break;
        }
        case 4: {
          msg.responseTypeUrl = reader.readString();
          break;
        }
        case 5: {
          msg.responseStreaming = reader.readBool();
          break;
        }
        case 6: {
          const m = protoscript2.Option.initialize();
          reader.readMessage(m, protoscript2.Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 7: {
          msg.syntax = protoscript2.Syntax._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Mixin = {
  /**
   * Serializes Mixin to protobuf.
   */
  encode: function(msg) {
    return Mixin._writeMessage(
      msg,
      new protoscript2.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Mixin from protobuf.
   */
  decode: function(bytes) {
    return Mixin._readMessage(
      Mixin.initialize(),
      new protoscript2.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Mixin with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      root: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.root) {
      writer.writeString(2, msg.root);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.root = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var ApiJSON = {
  /**
   * Serializes Api to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(ApiJSON._writeMessage(msg));
  },
  /**
   * Deserializes Api from JSON.
   */
  decode: function(json) {
    return ApiJSON._readMessage(ApiJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Api with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      methods: [],
      options: [],
      version: "",
      sourceContext: protoscript2.SourceContextJSON.initialize(),
      mixins: [],
      syntax: protoscript2.Syntax._fromInt(0),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.methods?.length) {
      json["methods"] = msg.methods.map(MethodJSON._writeMessage);
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(protoscript2.OptionJSON._writeMessage);
    }
    if (msg.version) {
      json["version"] = msg.version;
    }
    if (msg.sourceContext) {
      const _sourceContext_ = protoscript2.SourceContextJSON._writeMessage(
        msg.sourceContext
      );
      if (Object.keys(_sourceContext_).length > 0) {
        json["sourceContext"] = _sourceContext_;
      }
    }
    if (msg.mixins?.length) {
      json["mixins"] = msg.mixins.map(MixinJSON._writeMessage);
    }
    if (msg.syntax && protoscript2.SyntaxJSON._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _methods_ = json["methods"];
    if (_methods_) {
      for (const item of _methods_) {
        const m = MethodJSON.initialize();
        MethodJSON._readMessage(m, item);
        msg.methods.push(m);
      }
    }
    const _options_ = json["options"];
    if (_options_) {
      for (const item of _options_) {
        const m = protoscript2.OptionJSON.initialize();
        protoscript2.OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = _version_;
    }
    const _sourceContext_ = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext_) {
      protoscript2.SourceContextJSON._readMessage(
        msg.sourceContext,
        _sourceContext_
      );
    }
    const _mixins_ = json["mixins"];
    if (_mixins_) {
      for (const item of _mixins_) {
        const m = MixinJSON.initialize();
        MixinJSON._readMessage(m, item);
        msg.mixins.push(m);
      }
    }
    const _syntax_ = json["syntax"];
    if (_syntax_) {
      msg.syntax = protoscript2.Syntax._fromInt(_syntax_);
    }
    return msg;
  }
};
var MethodJSON = {
  /**
   * Serializes Method to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(MethodJSON._writeMessage(msg));
  },
  /**
   * Deserializes Method from JSON.
   */
  decode: function(json) {
    return MethodJSON._readMessage(MethodJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Method with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      requestTypeUrl: "",
      requestStreaming: false,
      responseTypeUrl: "",
      responseStreaming: false,
      options: [],
      syntax: protoscript2.Syntax._fromInt(0),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.requestTypeUrl) {
      json["requestTypeUrl"] = msg.requestTypeUrl;
    }
    if (msg.requestStreaming) {
      json["requestStreaming"] = msg.requestStreaming;
    }
    if (msg.responseTypeUrl) {
      json["responseTypeUrl"] = msg.responseTypeUrl;
    }
    if (msg.responseStreaming) {
      json["responseStreaming"] = msg.responseStreaming;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(protoscript2.OptionJSON._writeMessage);
    }
    if (msg.syntax && protoscript2.SyntaxJSON._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _requestTypeUrl_ = json["requestTypeUrl"] ?? json["request_type_url"];
    if (_requestTypeUrl_) {
      msg.requestTypeUrl = _requestTypeUrl_;
    }
    const _requestStreaming_ = json["requestStreaming"] ?? json["request_streaming"];
    if (_requestStreaming_) {
      msg.requestStreaming = _requestStreaming_;
    }
    const _responseTypeUrl_ = json["responseTypeUrl"] ?? json["response_type_url"];
    if (_responseTypeUrl_) {
      msg.responseTypeUrl = _responseTypeUrl_;
    }
    const _responseStreaming_ = json["responseStreaming"] ?? json["response_streaming"];
    if (_responseStreaming_) {
      msg.responseStreaming = _responseStreaming_;
    }
    const _options_ = json["options"];
    if (_options_) {
      for (const item of _options_) {
        const m = protoscript2.OptionJSON.initialize();
        protoscript2.OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _syntax_ = json["syntax"];
    if (_syntax_) {
      msg.syntax = protoscript2.Syntax._fromInt(_syntax_);
    }
    return msg;
  }
};
var MixinJSON = {
  /**
   * Serializes Mixin to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(MixinJSON._writeMessage(msg));
  },
  /**
   * Deserializes Mixin from JSON.
   */
  decode: function(json) {
    return MixinJSON._readMessage(MixinJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Mixin with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      root: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.root) {
      json["root"] = msg.root;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _root_ = json["root"];
    if (_root_) {
      msg.root = _root_;
    }
    return msg;
  }
};

// src/runtime/well-known-types/duration.pb.ts
var protoscript3 = __toESM(require("protoscript"), 1);
var Duration = {
  /**
   * Serializes Duration to protobuf.
   */
  encode: function(msg) {
    return Duration._writeMessage(
      msg,
      new protoscript3.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Duration from protobuf.
   */
  decode: function(bytes) {
    return Duration._readMessage(
      Duration.initialize(),
      new protoscript3.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Duration with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      seconds: 0n,
      nanos: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var DurationJSON = {
  /**
   * Serializes Duration to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(DurationJSON._writeMessage(msg));
  },
  /**
   * Deserializes Duration from JSON.
   */
  decode: function(json) {
    return DurationJSON._readMessage(
      DurationJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes Duration with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      seconds: 0n,
      nanos: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.seconds) {
      json["seconds"] = String(msg.seconds);
    }
    if (msg.nanos) {
      json["nanos"] = msg.nanos;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _seconds_ = json["seconds"];
    if (_seconds_) {
      msg.seconds = BigInt(_seconds_);
    }
    const _nanos_ = json["nanos"];
    if (_nanos_) {
      msg.nanos = protoscript3.parseNumber(_nanos_);
    }
    return msg;
  }
};

// src/runtime/well-known-types/empty.pb.ts
var Empty = {
  /**
   * Serializes Empty to protobuf.
   */
  encode: function(_msg) {
    return new Uint8Array();
  },
  /**
   * Deserializes Empty from protobuf.
   */
  decode: function(_bytes) {
    return {};
  },
  /**
   * Initializes Empty with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(_msg, writer) {
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(_msg, _reader) {
    return _msg;
  }
};
var EmptyJSON = {
  /**
   * Serializes Empty to JSON.
   */
  encode: function(_msg) {
    return "{}";
  },
  /**
   * Deserializes Empty from JSON.
   */
  decode: function(_json) {
    return {};
  },
  /**
   * Initializes Empty with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(_msg) {
    return {};
  },
  /**
   * @private
   */
  _readMessage: function(msg, _json) {
    return msg;
  }
};

// src/runtime/well-known-types/field_mask.pb.ts
var protoscript4 = __toESM(require("protoscript"), 1);
var FieldMask = {
  /**
   * Serializes FieldMask to protobuf.
   */
  encode: function(msg) {
    return FieldMask._writeMessage(
      msg,
      new protoscript4.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes FieldMask from protobuf.
   */
  decode: function(bytes) {
    return FieldMask._readMessage(
      FieldMask.initialize(),
      new protoscript4.BinaryReader(bytes)
    );
  },
  /**
   * Initializes FieldMask with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      paths: [],
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.paths?.length) {
      writer.writeRepeatedString(1, msg.paths);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.paths.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var FieldMaskJSON = {
  /**
   * Serializes FieldMask to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(FieldMaskJSON._writeMessage(msg));
  },
  /**
   * Deserializes FieldMask from JSON.
   */
  decode: function(json) {
    return FieldMaskJSON._readMessage(
      FieldMaskJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes FieldMask with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      paths: [],
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.paths?.length) {
      json["paths"] = msg.paths;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _paths_ = json["paths"];
    if (_paths_) {
      msg.paths = _paths_;
    }
    return msg;
  }
};

// src/runtime/well-known-types/source_context.pb.ts
var protoscript5 = __toESM(require("protoscript"), 1);
var SourceContext2 = {
  /**
   * Serializes SourceContext to protobuf.
   */
  encode: function(msg) {
    return SourceContext2._writeMessage(
      msg,
      new protoscript5.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes SourceContext from protobuf.
   */
  decode: function(bytes) {
    return SourceContext2._readMessage(
      SourceContext2.initialize(),
      new protoscript5.BinaryReader(bytes)
    );
  },
  /**
   * Initializes SourceContext with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      fileName: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var SourceContextJSON2 = {
  /**
   * Serializes SourceContext to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(SourceContextJSON2._writeMessage(msg));
  },
  /**
   * Deserializes SourceContext from JSON.
   */
  decode: function(json) {
    return SourceContextJSON2._readMessage(
      SourceContextJSON2.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes SourceContext with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      fileName: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.fileName) {
      json["fileName"] = msg.fileName;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _fileName_ = json["fileName"] ?? json["file_name"];
    if (_fileName_) {
      msg.fileName = _fileName_;
    }
    return msg;
  }
};

// src/runtime/well-known-types/struct.pb.ts
var protoscript6 = __toESM(require("protoscript"), 1);
var NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: "NULL_VALUE",
  /**
   * @private
   */
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "NULL_VALUE";
      }
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function(i) {
    switch (i) {
      case "NULL_VALUE": {
        return 0;
      }
      default: {
        return i;
      }
    }
  }
};
var Struct = {
  /**
   * Serializes Struct to protobuf.
   */
  encode: function(msg) {
    return Struct._writeMessage(
      msg,
      new protoscript6.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Struct from protobuf.
   */
  decode: function(bytes) {
    return Struct._readMessage(
      Struct.initialize(),
      new protoscript6.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Struct with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      fields: {},
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.fields).map(([key, value]) => ({
          key,
          value
        })),
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, Struct.Fields._readMessage);
          msg.fields[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
  Fields: {
    /**
     * @private
     */
    _writeMessage: function(msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },
    /**
     * @private
     */
    _readMessage: function(msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = Value.initialize();
            reader.readMessage(msg.value, Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    }
  }
};
var Value = {
  /**
   * Serializes Value to protobuf.
   */
  encode: function(msg) {
    return Value._writeMessage(
      msg,
      new protoscript6.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Value from protobuf.
   */
  decode: function(bytes) {
    return Value._readMessage(
      Value.initialize(),
      new protoscript6.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.nullValue != void 0) {
      writer.writeEnum(1, NullValue._toInt(msg.nullValue));
    }
    if (msg.numberValue != void 0) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != void 0) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != void 0) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != void 0) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != void 0) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValue._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          msg.structValue = Struct.initialize();
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          msg.listValue = ListValue.initialize();
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var ListValue = {
  /**
   * Serializes ListValue to protobuf.
   */
  encode: function(msg) {
    return ListValue._writeMessage(
      msg,
      new protoscript6.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes ListValue from protobuf.
   */
  decode: function(bytes) {
    return ListValue._readMessage(
      ListValue.initialize(),
      new protoscript6.BinaryReader(bytes)
    );
  },
  /**
   * Initializes ListValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      values: [],
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values, Value._writeMessage);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var NullValueJSON = {
  /**
   * Null value.
   */
  NULL_VALUE: "NULL_VALUE",
  /**
   * @private
   */
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "NULL_VALUE";
      }
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function(i) {
    switch (i) {
      case "NULL_VALUE": {
        return 0;
      }
      default: {
        return i;
      }
    }
  }
};
var StructJSON = {
  /**
   * Serializes Struct to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(StructJSON._writeMessage(msg));
  },
  /**
   * Deserializes Struct from JSON.
   */
  decode: function(json) {
    return StructJSON._readMessage(StructJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Struct with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      fields: {},
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.fields) {
      const _fields_ = Object.fromEntries(
        Object.entries(msg.fields).map(([key, value]) => ({ key, value })).map(StructJSON.Fields._writeMessage).map(({ key, value }) => [key, value])
      );
      if (Object.keys(_fields_).length > 0) {
        json["fields"] = _fields_;
      }
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _fields_ = json["fields"];
    if (_fields_) {
      msg.fields = Object.fromEntries(
        Object.entries(_fields_).map(([key, value]) => ({ key, value })).map(StructJSON.Fields._readMessage).map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },
  Fields: {
    /**
     * @private
     */
    _writeMessage: function(msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },
    /**
     * @private
     */
    _readMessage: function(msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        ValueJSON._readMessage(msg.value, _value_);
      }
      return msg;
    }
  }
};
var ValueJSON = {
  /**
   * Serializes Value to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(ValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes Value from JSON.
   */
  decode: function(json) {
    return ValueJSON._readMessage(ValueJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.nullValue != void 0) {
      json["nullValue"] = msg.nullValue;
    }
    if (msg.numberValue != void 0) {
      json["numberValue"] = msg.numberValue;
    }
    if (msg.stringValue != void 0) {
      json["stringValue"] = msg.stringValue;
    }
    if (msg.boolValue != void 0) {
      json["boolValue"] = msg.boolValue;
    }
    if (msg.structValue != void 0) {
      const _structValue_ = StructJSON._writeMessage(msg.structValue);
      json["structValue"] = _structValue_;
    }
    if (msg.listValue != void 0) {
      const _listValue_ = ListValueJSON._writeMessage(msg.listValue);
      json["listValue"] = _listValue_;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _nullValue_ = json["nullValue"] ?? json["null_value"];
    if (_nullValue_) {
      msg.nullValue = NullValue._fromInt(_nullValue_);
    }
    const _numberValue_ = json["numberValue"] ?? json["number_value"];
    if (_numberValue_) {
      msg.numberValue = protoscript6.parseDouble(_numberValue_);
    }
    const _stringValue_ = json["stringValue"] ?? json["string_value"];
    if (_stringValue_) {
      msg.stringValue = _stringValue_;
    }
    const _boolValue_ = json["boolValue"] ?? json["bool_value"];
    if (_boolValue_) {
      msg.boolValue = _boolValue_;
    }
    const _structValue_ = json["structValue"] ?? json["struct_value"];
    if (_structValue_) {
      msg.structValue = StructJSON.initialize();
      StructJSON._readMessage(msg.structValue, _structValue_);
    }
    const _listValue_ = json["listValue"] ?? json["list_value"];
    if (_listValue_) {
      msg.listValue = ListValueJSON.initialize();
      ListValueJSON._readMessage(msg.listValue, _listValue_);
    }
    return msg;
  }
};
var ListValueJSON = {
  /**
   * Serializes ListValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(ListValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes ListValue from JSON.
   */
  decode: function(json) {
    return ListValueJSON._readMessage(
      ListValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes ListValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      values: [],
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.values?.length) {
      json["values"] = msg.values.map(ValueJSON._writeMessage);
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _values_ = json["values"];
    if (_values_) {
      for (const item of _values_) {
        const m = ValueJSON.initialize();
        ValueJSON._readMessage(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  }
};

// src/runtime/well-known-types/timestamp.pb.ts
var protoscript7 = __toESM(require("protoscript"), 1);
var Timestamp = {
  /**
   * Serializes Timestamp to protobuf.
   */
  encode: function(msg) {
    return Timestamp._writeMessage(
      msg,
      new protoscript7.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Timestamp from protobuf.
   */
  decode: function(bytes) {
    return Timestamp._readMessage(
      Timestamp.initialize(),
      new protoscript7.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Timestamp with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      seconds: 0n,
      nanos: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var TimestampJSON = {
  /**
   * Serializes Timestamp to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(TimestampJSON._writeMessage(msg));
  },
  /**
   * Deserializes Timestamp from JSON.
   */
  decode: function(json) {
    return TimestampJSON._readMessage(
      TimestampJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes Timestamp with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      seconds: 0n,
      nanos: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.seconds) {
      json["seconds"] = String(msg.seconds);
    }
    if (msg.nanos) {
      json["nanos"] = msg.nanos;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _seconds_ = json["seconds"];
    if (_seconds_) {
      msg.seconds = BigInt(_seconds_);
    }
    const _nanos_ = json["nanos"];
    if (_nanos_) {
      msg.nanos = protoscript7.parseNumber(_nanos_);
    }
    return msg;
  }
};

// src/runtime/well-known-types/type.pb.ts
var protoscript8 = __toESM(require("protoscript"), 1);
var Syntax2 = {
  /**
   * Syntax `proto2`.
   */
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  /**
   * Syntax `proto3`.
   */
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  /**
   * Syntax `editions`.
   */
  SYNTAX_EDITIONS: "SYNTAX_EDITIONS",
  /**
   * @private
   */
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      case 2: {
        return "SYNTAX_EDITIONS";
      }
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function(i) {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      case "SYNTAX_EDITIONS": {
        return 2;
      }
      default: {
        return i;
      }
    }
  }
};
var Type = {
  /**
   * Serializes Type to protobuf.
   */
  encode: function(msg) {
    return Type._writeMessage(
      msg,
      new protoscript8.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Type from protobuf.
   */
  decode: function(bytes) {
    return Type._readMessage(
      Type.initialize(),
      new protoscript8.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Type with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: protoscript8.SourceContext.initialize(),
      syntax: Syntax2._fromInt(0),
      edition: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options, Option2._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(
        5,
        msg.sourceContext,
        protoscript8.SourceContext._writeMessage
      );
    }
    if (msg.syntax && Syntax2._toInt(msg.syntax)) {
      writer.writeEnum(6, Syntax2._toInt(msg.syntax));
    }
    if (msg.edition) {
      writer.writeString(7, msg.edition);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(
            msg.sourceContext,
            protoscript8.SourceContext._readMessage
          );
          break;
        }
        case 6: {
          msg.syntax = Syntax2._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.edition = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Field = {
  /**
   * Serializes Field to protobuf.
   */
  encode: function(msg) {
    return Field._writeMessage(
      msg,
      new protoscript8.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Field from protobuf.
   */
  decode: function(bytes) {
    return Field._readMessage(
      Field.initialize(),
      new protoscript8.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Field with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      kind: Field.Kind._fromInt(0),
      cardinality: Field.Cardinality._fromInt(0),
      number: 0,
      name: "",
      typeUrl: "",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: "",
      defaultValue: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.kind && Field.Kind._toInt(msg.kind)) {
      writer.writeEnum(1, Field.Kind._toInt(msg.kind));
    }
    if (msg.cardinality && Field.Cardinality._toInt(msg.cardinality)) {
      writer.writeEnum(2, Field.Cardinality._toInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options, Option2._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.Kind._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.Cardinality._fromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: "TYPE_UNKNOWN",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: "TYPE_DOUBLE",
    /**
     * Field type float.
     */
    TYPE_FLOAT: "TYPE_FLOAT",
    /**
     * Field type int64.
     */
    TYPE_INT64: "TYPE_INT64",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: "TYPE_UINT64",
    /**
     * Field type int32.
     */
    TYPE_INT32: "TYPE_INT32",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: "TYPE_FIXED64",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: "TYPE_FIXED32",
    /**
     * Field type bool.
     */
    TYPE_BOOL: "TYPE_BOOL",
    /**
     * Field type string.
     */
    TYPE_STRING: "TYPE_STRING",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: "TYPE_GROUP",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: "TYPE_MESSAGE",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: "TYPE_BYTES",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: "TYPE_UINT32",
    /**
     * Field type enum.
     */
    TYPE_ENUM: "TYPE_ENUM",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: "TYPE_SFIXED32",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: "TYPE_SFIXED64",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: "TYPE_SINT32",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: "TYPE_SINT64",
    /**
     * @private
     */
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "TYPE_UNKNOWN";
        }
        case 1: {
          return "TYPE_DOUBLE";
        }
        case 2: {
          return "TYPE_FLOAT";
        }
        case 3: {
          return "TYPE_INT64";
        }
        case 4: {
          return "TYPE_UINT64";
        }
        case 5: {
          return "TYPE_INT32";
        }
        case 6: {
          return "TYPE_FIXED64";
        }
        case 7: {
          return "TYPE_FIXED32";
        }
        case 8: {
          return "TYPE_BOOL";
        }
        case 9: {
          return "TYPE_STRING";
        }
        case 10: {
          return "TYPE_GROUP";
        }
        case 11: {
          return "TYPE_MESSAGE";
        }
        case 12: {
          return "TYPE_BYTES";
        }
        case 13: {
          return "TYPE_UINT32";
        }
        case 14: {
          return "TYPE_ENUM";
        }
        case 15: {
          return "TYPE_SFIXED32";
        }
        case 16: {
          return "TYPE_SFIXED64";
        }
        case 17: {
          return "TYPE_SINT32";
        }
        case 18: {
          return "TYPE_SINT64";
        }
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function(i) {
      switch (i) {
        case "TYPE_UNKNOWN": {
          return 0;
        }
        case "TYPE_DOUBLE": {
          return 1;
        }
        case "TYPE_FLOAT": {
          return 2;
        }
        case "TYPE_INT64": {
          return 3;
        }
        case "TYPE_UINT64": {
          return 4;
        }
        case "TYPE_INT32": {
          return 5;
        }
        case "TYPE_FIXED64": {
          return 6;
        }
        case "TYPE_FIXED32": {
          return 7;
        }
        case "TYPE_BOOL": {
          return 8;
        }
        case "TYPE_STRING": {
          return 9;
        }
        case "TYPE_GROUP": {
          return 10;
        }
        case "TYPE_MESSAGE": {
          return 11;
        }
        case "TYPE_BYTES": {
          return 12;
        }
        case "TYPE_UINT32": {
          return 13;
        }
        case "TYPE_ENUM": {
          return 14;
        }
        case "TYPE_SFIXED32": {
          return 15;
        }
        case "TYPE_SFIXED64": {
          return 16;
        }
        case "TYPE_SINT32": {
          return 17;
        }
        case "TYPE_SINT64": {
          return 18;
        }
        default: {
          return i;
        }
      }
    }
  },
  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
    /**
     * @private
     */
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "CARDINALITY_UNKNOWN";
        }
        case 1: {
          return "CARDINALITY_OPTIONAL";
        }
        case 2: {
          return "CARDINALITY_REQUIRED";
        }
        case 3: {
          return "CARDINALITY_REPEATED";
        }
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function(i) {
      switch (i) {
        case "CARDINALITY_UNKNOWN": {
          return 0;
        }
        case "CARDINALITY_OPTIONAL": {
          return 1;
        }
        case "CARDINALITY_REQUIRED": {
          return 2;
        }
        case "CARDINALITY_REPEATED": {
          return 3;
        }
        default: {
          return i;
        }
      }
    }
  }
};
var Enum = {
  /**
   * Serializes Enum to protobuf.
   */
  encode: function(msg) {
    return Enum._writeMessage(
      msg,
      new protoscript8.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Enum from protobuf.
   */
  decode: function(bytes) {
    return Enum._readMessage(
      Enum.initialize(),
      new protoscript8.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Enum with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      enumvalue: [],
      options: [],
      sourceContext: protoscript8.SourceContext.initialize(),
      syntax: Syntax2._fromInt(0),
      edition: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.enumvalue,
        EnumValue._writeMessage
      );
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option2._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(
        4,
        msg.sourceContext,
        protoscript8.SourceContext._writeMessage
      );
    }
    if (msg.syntax && Syntax2._toInt(msg.syntax)) {
      writer.writeEnum(5, Syntax2._toInt(msg.syntax));
    }
    if (msg.edition) {
      writer.writeString(6, msg.edition);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(
            msg.sourceContext,
            protoscript8.SourceContext._readMessage
          );
          break;
        }
        case 5: {
          msg.syntax = Syntax2._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.edition = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var EnumValue = {
  /**
   * Serializes EnumValue to protobuf.
   */
  encode: function(msg) {
    return EnumValue._writeMessage(
      msg,
      new protoscript8.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes EnumValue from protobuf.
   */
  decode: function(bytes) {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new protoscript8.BinaryReader(bytes)
    );
  },
  /**
   * Initializes EnumValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      number: 0,
      options: [],
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option2._writeMessage);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Option2 = {
  /**
   * Serializes Option to protobuf.
   */
  encode: function(msg) {
    return Option2._writeMessage(
      msg,
      new protoscript8.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Option from protobuf.
   */
  decode: function(bytes) {
    return Option2._readMessage(
      Option2.initialize(),
      new protoscript8.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Option with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      value: protoscript8.Any.initialize(),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, protoscript8.Any._writeMessage);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, protoscript8.Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var SyntaxJSON2 = {
  /**
   * Syntax `proto2`.
   */
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  /**
   * Syntax `proto3`.
   */
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  /**
   * Syntax `editions`.
   */
  SYNTAX_EDITIONS: "SYNTAX_EDITIONS",
  /**
   * @private
   */
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      case 2: {
        return "SYNTAX_EDITIONS";
      }
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function(i) {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      case "SYNTAX_EDITIONS": {
        return 2;
      }
      default: {
        return i;
      }
    }
  }
};
var TypeJSON = {
  /**
   * Serializes Type to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(TypeJSON._writeMessage(msg));
  },
  /**
   * Deserializes Type from JSON.
   */
  decode: function(json) {
    return TypeJSON._readMessage(TypeJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Type with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: protoscript8.SourceContextJSON.initialize(),
      syntax: Syntax2._fromInt(0),
      edition: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.fields?.length) {
      json["fields"] = msg.fields.map(FieldJSON._writeMessage);
    }
    if (msg.oneofs?.length) {
      json["oneofs"] = msg.oneofs;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    if (msg.sourceContext) {
      const _sourceContext_ = protoscript8.SourceContextJSON._writeMessage(
        msg.sourceContext
      );
      if (Object.keys(_sourceContext_).length > 0) {
        json["sourceContext"] = _sourceContext_;
      }
    }
    if (msg.syntax && SyntaxJSON2._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    if (msg.edition) {
      json["edition"] = msg.edition;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _fields_ = json["fields"];
    if (_fields_) {
      for (const item of _fields_) {
        const m = FieldJSON.initialize();
        FieldJSON._readMessage(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs_ = json["oneofs"];
    if (_oneofs_) {
      msg.oneofs = _oneofs_;
    }
    const _options_ = json["options"];
    if (_options_) {
      for (const item of _options_) {
        const m = OptionJSON2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext_ = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext_) {
      protoscript8.SourceContextJSON._readMessage(
        msg.sourceContext,
        _sourceContext_
      );
    }
    const _syntax_ = json["syntax"];
    if (_syntax_) {
      msg.syntax = Syntax2._fromInt(_syntax_);
    }
    const _edition_ = json["edition"];
    if (_edition_) {
      msg.edition = _edition_;
    }
    return msg;
  }
};
var FieldJSON = {
  /**
   * Serializes Field to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(FieldJSON._writeMessage(msg));
  },
  /**
   * Deserializes Field from JSON.
   */
  decode: function(json) {
    return FieldJSON._readMessage(FieldJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Field with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      kind: Field.Kind._fromInt(0),
      cardinality: Field.Cardinality._fromInt(0),
      number: 0,
      name: "",
      typeUrl: "",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: "",
      defaultValue: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.kind && FieldJSON.Kind._toInt(msg.kind)) {
      json["kind"] = msg.kind;
    }
    if (msg.cardinality && FieldJSON.Cardinality._toInt(msg.cardinality)) {
      json["cardinality"] = msg.cardinality;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.typeUrl) {
      json["typeUrl"] = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json["oneofIndex"] = msg.oneofIndex;
    }
    if (msg.packed) {
      json["packed"] = msg.packed;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    if (msg.jsonName) {
      json["jsonName"] = msg.jsonName;
    }
    if (msg.defaultValue) {
      json["defaultValue"] = msg.defaultValue;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _kind_ = json["kind"];
    if (_kind_) {
      msg.kind = Field.Kind._fromInt(_kind_);
    }
    const _cardinality_ = json["cardinality"];
    if (_cardinality_) {
      msg.cardinality = Field.Cardinality._fromInt(_cardinality_);
    }
    const _number_ = json["number"];
    if (_number_) {
      msg.number = protoscript8.parseNumber(_number_);
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _typeUrl_ = json["typeUrl"] ?? json["type_url"];
    if (_typeUrl_) {
      msg.typeUrl = _typeUrl_;
    }
    const _oneofIndex_ = json["oneofIndex"] ?? json["oneof_index"];
    if (_oneofIndex_) {
      msg.oneofIndex = protoscript8.parseNumber(_oneofIndex_);
    }
    const _packed_ = json["packed"];
    if (_packed_) {
      msg.packed = _packed_;
    }
    const _options_ = json["options"];
    if (_options_) {
      for (const item of _options_) {
        const m = OptionJSON2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName_ = json["jsonName"] ?? json["json_name"];
    if (_jsonName_) {
      msg.jsonName = _jsonName_;
    }
    const _defaultValue_ = json["defaultValue"] ?? json["default_value"];
    if (_defaultValue_) {
      msg.defaultValue = _defaultValue_;
    }
    return msg;
  },
  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: "TYPE_UNKNOWN",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: "TYPE_DOUBLE",
    /**
     * Field type float.
     */
    TYPE_FLOAT: "TYPE_FLOAT",
    /**
     * Field type int64.
     */
    TYPE_INT64: "TYPE_INT64",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: "TYPE_UINT64",
    /**
     * Field type int32.
     */
    TYPE_INT32: "TYPE_INT32",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: "TYPE_FIXED64",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: "TYPE_FIXED32",
    /**
     * Field type bool.
     */
    TYPE_BOOL: "TYPE_BOOL",
    /**
     * Field type string.
     */
    TYPE_STRING: "TYPE_STRING",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: "TYPE_GROUP",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: "TYPE_MESSAGE",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: "TYPE_BYTES",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: "TYPE_UINT32",
    /**
     * Field type enum.
     */
    TYPE_ENUM: "TYPE_ENUM",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: "TYPE_SFIXED32",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: "TYPE_SFIXED64",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: "TYPE_SINT32",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: "TYPE_SINT64",
    /**
     * @private
     */
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "TYPE_UNKNOWN";
        }
        case 1: {
          return "TYPE_DOUBLE";
        }
        case 2: {
          return "TYPE_FLOAT";
        }
        case 3: {
          return "TYPE_INT64";
        }
        case 4: {
          return "TYPE_UINT64";
        }
        case 5: {
          return "TYPE_INT32";
        }
        case 6: {
          return "TYPE_FIXED64";
        }
        case 7: {
          return "TYPE_FIXED32";
        }
        case 8: {
          return "TYPE_BOOL";
        }
        case 9: {
          return "TYPE_STRING";
        }
        case 10: {
          return "TYPE_GROUP";
        }
        case 11: {
          return "TYPE_MESSAGE";
        }
        case 12: {
          return "TYPE_BYTES";
        }
        case 13: {
          return "TYPE_UINT32";
        }
        case 14: {
          return "TYPE_ENUM";
        }
        case 15: {
          return "TYPE_SFIXED32";
        }
        case 16: {
          return "TYPE_SFIXED64";
        }
        case 17: {
          return "TYPE_SINT32";
        }
        case 18: {
          return "TYPE_SINT64";
        }
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function(i) {
      switch (i) {
        case "TYPE_UNKNOWN": {
          return 0;
        }
        case "TYPE_DOUBLE": {
          return 1;
        }
        case "TYPE_FLOAT": {
          return 2;
        }
        case "TYPE_INT64": {
          return 3;
        }
        case "TYPE_UINT64": {
          return 4;
        }
        case "TYPE_INT32": {
          return 5;
        }
        case "TYPE_FIXED64": {
          return 6;
        }
        case "TYPE_FIXED32": {
          return 7;
        }
        case "TYPE_BOOL": {
          return 8;
        }
        case "TYPE_STRING": {
          return 9;
        }
        case "TYPE_GROUP": {
          return 10;
        }
        case "TYPE_MESSAGE": {
          return 11;
        }
        case "TYPE_BYTES": {
          return 12;
        }
        case "TYPE_UINT32": {
          return 13;
        }
        case "TYPE_ENUM": {
          return 14;
        }
        case "TYPE_SFIXED32": {
          return 15;
        }
        case "TYPE_SFIXED64": {
          return 16;
        }
        case "TYPE_SINT32": {
          return 17;
        }
        case "TYPE_SINT64": {
          return 18;
        }
        default: {
          return i;
        }
      }
    }
  },
  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
    /**
     * @private
     */
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "CARDINALITY_UNKNOWN";
        }
        case 1: {
          return "CARDINALITY_OPTIONAL";
        }
        case 2: {
          return "CARDINALITY_REQUIRED";
        }
        case 3: {
          return "CARDINALITY_REPEATED";
        }
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function(i) {
      switch (i) {
        case "CARDINALITY_UNKNOWN": {
          return 0;
        }
        case "CARDINALITY_OPTIONAL": {
          return 1;
        }
        case "CARDINALITY_REQUIRED": {
          return 2;
        }
        case "CARDINALITY_REPEATED": {
          return 3;
        }
        default: {
          return i;
        }
      }
    }
  }
};
var EnumJSON = {
  /**
   * Serializes Enum to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(EnumJSON._writeMessage(msg));
  },
  /**
   * Deserializes Enum from JSON.
   */
  decode: function(json) {
    return EnumJSON._readMessage(EnumJSON.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Enum with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      enumvalue: [],
      options: [],
      sourceContext: protoscript8.SourceContextJSON.initialize(),
      syntax: Syntax2._fromInt(0),
      edition: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.enumvalue?.length) {
      json["enumvalue"] = msg.enumvalue.map(EnumValueJSON._writeMessage);
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    if (msg.sourceContext) {
      const _sourceContext_ = protoscript8.SourceContextJSON._writeMessage(
        msg.sourceContext
      );
      if (Object.keys(_sourceContext_).length > 0) {
        json["sourceContext"] = _sourceContext_;
      }
    }
    if (msg.syntax && SyntaxJSON2._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    if (msg.edition) {
      json["edition"] = msg.edition;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _enumvalue_ = json["enumvalue"];
    if (_enumvalue_) {
      for (const item of _enumvalue_) {
        const m = EnumValueJSON.initialize();
        EnumValueJSON._readMessage(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options_ = json["options"];
    if (_options_) {
      for (const item of _options_) {
        const m = OptionJSON2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext_ = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext_) {
      protoscript8.SourceContextJSON._readMessage(
        msg.sourceContext,
        _sourceContext_
      );
    }
    const _syntax_ = json["syntax"];
    if (_syntax_) {
      msg.syntax = Syntax2._fromInt(_syntax_);
    }
    const _edition_ = json["edition"];
    if (_edition_) {
      msg.edition = _edition_;
    }
    return msg;
  }
};
var EnumValueJSON = {
  /**
   * Serializes EnumValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(EnumValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes EnumValue from JSON.
   */
  decode: function(json) {
    return EnumValueJSON._readMessage(
      EnumValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes EnumValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      number: 0,
      options: [],
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _number_ = json["number"];
    if (_number_) {
      msg.number = protoscript8.parseNumber(_number_);
    }
    const _options_ = json["options"];
    if (_options_) {
      for (const item of _options_) {
        const m = OptionJSON2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  }
};
var OptionJSON2 = {
  /**
   * Serializes Option to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(OptionJSON2._writeMessage(msg));
  },
  /**
   * Deserializes Option from JSON.
   */
  decode: function(json) {
    return OptionJSON2._readMessage(OptionJSON2.initialize(), JSON.parse(json));
  },
  /**
   * Initializes Option with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      name: "",
      value: protoscript8.AnyJSON.initialize(),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.value) {
      const _value_ = protoscript8.AnyJSON._writeMessage(msg.value);
      if (Object.keys(_value_).length > 0) {
        json["value"] = _value_;
      }
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _value_ = json["value"];
    if (_value_) {
      protoscript8.AnyJSON._readMessage(msg.value, _value_);
    }
    return msg;
  }
};

// src/runtime/well-known-types/wrappers.pb.ts
var protoscript9 = __toESM(require("protoscript"), 1);
var DoubleValue = {
  /**
   * Serializes DoubleValue to protobuf.
   */
  encode: function(msg) {
    return DoubleValue._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes DoubleValue from protobuf.
   */
  decode: function(bytes) {
    return DoubleValue._readMessage(
      DoubleValue.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes DoubleValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeDouble(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var FloatValue = {
  /**
   * Serializes FloatValue to protobuf.
   */
  encode: function(msg) {
    return FloatValue._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes FloatValue from protobuf.
   */
  decode: function(bytes) {
    return FloatValue._readMessage(
      FloatValue.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes FloatValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeFloat(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Int64Value = {
  /**
   * Serializes Int64Value to protobuf.
   */
  encode: function(msg) {
    return Int64Value._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Int64Value from protobuf.
   */
  decode: function(bytes) {
    return Int64Value._readMessage(
      Int64Value.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Int64Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0n,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeInt64String(1, msg.value.toString());
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var UInt64Value = {
  /**
   * Serializes UInt64Value to protobuf.
   */
  encode: function(msg) {
    return UInt64Value._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes UInt64Value from protobuf.
   */
  decode: function(bytes) {
    return UInt64Value._readMessage(
      UInt64Value.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes UInt64Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0n,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeUint64String(1, msg.value.toString());
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Int32Value = {
  /**
   * Serializes Int32Value to protobuf.
   */
  encode: function(msg) {
    return Int32Value._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes Int32Value from protobuf.
   */
  decode: function(bytes) {
    return Int32Value._readMessage(
      Int32Value.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes Int32Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeInt32(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var UInt32Value = {
  /**
   * Serializes UInt32Value to protobuf.
   */
  encode: function(msg) {
    return UInt32Value._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes UInt32Value from protobuf.
   */
  decode: function(bytes) {
    return UInt32Value._readMessage(
      UInt32Value.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes UInt32Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeUint32(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var BoolValue = {
  /**
   * Serializes BoolValue to protobuf.
   */
  encode: function(msg) {
    return BoolValue._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes BoolValue from protobuf.
   */
  decode: function(bytes) {
    return BoolValue._readMessage(
      BoolValue.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes BoolValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: false,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeBool(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var StringValue = {
  /**
   * Serializes StringValue to protobuf.
   */
  encode: function(msg) {
    return StringValue._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes StringValue from protobuf.
   */
  decode: function(bytes) {
    return StringValue._readMessage(
      StringValue.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes StringValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeString(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var BytesValue = {
  /**
   * Serializes BytesValue to protobuf.
   */
  encode: function(msg) {
    return BytesValue._writeMessage(
      msg,
      new protoscript9.BinaryWriter()
    ).getResultBuffer();
  },
  /**
   * Deserializes BytesValue from protobuf.
   */
  decode: function(bytes) {
    return BytesValue._readMessage(
      BytesValue.initialize(),
      new protoscript9.BinaryReader(bytes)
    );
  },
  /**
   * Initializes BytesValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: new Uint8Array(),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg, writer) {
    if (msg.value?.length) {
      writer.writeBytes(1, msg.value);
    }
    return writer;
  },
  /**
   * @private
   */
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var DoubleValueJSON = {
  /**
   * Serializes DoubleValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(DoubleValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes DoubleValue from JSON.
   */
  decode: function(json) {
    return DoubleValueJSON._readMessage(
      DoubleValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes DoubleValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = protoscript9.parseDouble(_value_);
    }
    return msg;
  }
};
var FloatValueJSON = {
  /**
   * Serializes FloatValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(FloatValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes FloatValue from JSON.
   */
  decode: function(json) {
    return FloatValueJSON._readMessage(
      FloatValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes FloatValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = protoscript9.parseDouble(_value_);
    }
    return msg;
  }
};
var Int64ValueJSON = {
  /**
   * Serializes Int64Value to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(Int64ValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes Int64Value from JSON.
   */
  decode: function(json) {
    return Int64ValueJSON._readMessage(
      Int64ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes Int64Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0n,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = String(msg.value);
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = BigInt(_value_);
    }
    return msg;
  }
};
var UInt64ValueJSON = {
  /**
   * Serializes UInt64Value to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(UInt64ValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes UInt64Value from JSON.
   */
  decode: function(json) {
    return UInt64ValueJSON._readMessage(
      UInt64ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes UInt64Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0n,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = String(msg.value);
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = BigInt(_value_);
    }
    return msg;
  }
};
var Int32ValueJSON = {
  /**
   * Serializes Int32Value to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(Int32ValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes Int32Value from JSON.
   */
  decode: function(json) {
    return Int32ValueJSON._readMessage(
      Int32ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes Int32Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = protoscript9.parseNumber(_value_);
    }
    return msg;
  }
};
var UInt32ValueJSON = {
  /**
   * Serializes UInt32Value to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(UInt32ValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes UInt32Value from JSON.
   */
  decode: function(json) {
    return UInt32ValueJSON._readMessage(
      UInt32ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes UInt32Value with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: 0,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = protoscript9.parseNumber(_value_);
    }
    return msg;
  }
};
var BoolValueJSON = {
  /**
   * Serializes BoolValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(BoolValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes BoolValue from JSON.
   */
  decode: function(json) {
    return BoolValueJSON._readMessage(
      BoolValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes BoolValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: false,
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = _value_;
    }
    return msg;
  }
};
var StringValueJSON = {
  /**
   * Serializes StringValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(StringValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes StringValue from JSON.
   */
  decode: function(json) {
    return StringValueJSON._readMessage(
      StringValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes StringValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: "",
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = _value_;
    }
    return msg;
  }
};
var BytesValueJSON = {
  /**
   * Serializes BytesValue to JSON.
   */
  encode: function(msg) {
    return JSON.stringify(BytesValueJSON._writeMessage(msg));
  },
  /**
   * Deserializes BytesValue from JSON.
   */
  decode: function(json) {
    return BytesValueJSON._readMessage(
      BytesValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  /**
   * Initializes BytesValue with all fields set to their default value.
   */
  initialize: function(msg) {
    return {
      value: new Uint8Array(),
      ...msg
    };
  },
  /**
   * @private
   */
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value?.length) {
      json["value"] = protoscript9.serializeBytes(msg.value);
    }
    return json;
  },
  /**
   * @private
   */
  _readMessage: function(msg, json) {
    const _value_ = json["value"];
    if (_value_) {
      msg.value = protoscript9.parseBytes(_value_);
    }
    return msg;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Any,
  AnyJSON,
  Api,
  ApiJSON,
  BinaryReader,
  BinaryWriter,
  BoolValue,
  BoolValueJSON,
  BytesValue,
  BytesValueJSON,
  DoubleValue,
  DoubleValueJSON,
  Duration,
  DurationJSON,
  Empty,
  EmptyJSON,
  Enum,
  EnumJSON,
  EnumValue,
  EnumValueJSON,
  Field,
  FieldJSON,
  FieldMask,
  FieldMaskJSON,
  FloatValue,
  FloatValueJSON,
  Int32Value,
  Int32ValueJSON,
  Int64Value,
  Int64ValueJSON,
  ListValue,
  ListValueJSON,
  Method,
  MethodJSON,
  Mixin,
  MixinJSON,
  NullValue,
  NullValueJSON,
  Option,
  OptionJSON,
  SourceContext,
  SourceContextJSON,
  StringValue,
  StringValueJSON,
  Struct,
  StructJSON,
  Syntax,
  SyntaxJSON,
  Timestamp,
  TimestampJSON,
  Type,
  TypeJSON,
  UInt32Value,
  UInt32ValueJSON,
  UInt64Value,
  UInt64ValueJSON,
  Value,
  ValueJSON,
  parseBytes,
  parseDouble,
  parseDuration,
  parseNumber,
  parseTimestamp,
  serializeBytes,
  serializeDuration,
  serializeTimestamp
});
