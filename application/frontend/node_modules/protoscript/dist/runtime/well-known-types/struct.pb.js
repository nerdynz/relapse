// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto
/* eslint-disable */
import * as protoscript from "protoscript";
//========================================//
//        Protobuf Encode / Decode        //
//========================================//
export const NullValue = {
    /**
     * Null value.
     */
    NULL_VALUE: "NULL_VALUE",
    /**
     * @private
     */
    _fromInt: function (i) {
        switch (i) {
            case 0: {
                return "NULL_VALUE";
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
    /**
     * @private
     */
    _toInt: function (i) {
        switch (i) {
            case "NULL_VALUE": {
                return 0;
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
};
export const Struct = {
    /**
     * Serializes Struct to protobuf.
     */
    encode: function (msg) {
        return Struct._writeMessage(msg, new protoscript.BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Struct from protobuf.
     */
    decode: function (bytes) {
        return Struct._readMessage(Struct.initialize(), new protoscript.BinaryReader(bytes));
    },
    /**
     * Initializes Struct with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            fields: {},
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.fields) {
            writer.writeRepeatedMessage(1, Object.entries(msg.fields).map(([key, value]) => ({
                key: key,
                value: value,
            })), Struct.Fields._writeMessage);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    const map = {};
                    reader.readMessage(map, Struct.Fields._readMessage);
                    msg.fields[map.key.toString()] = map.value;
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
    Fields: {
        /**
         * @private
         */
        _writeMessage: function (msg, writer) {
            if (msg.key) {
                writer.writeString(1, msg.key);
            }
            if (msg.value) {
                writer.writeMessage(2, msg.value, Value._writeMessage);
            }
            return writer;
        },
        /**
         * @private
         */
        _readMessage: function (msg, reader) {
            while (reader.nextField()) {
                const field = reader.getFieldNumber();
                switch (field) {
                    case 1: {
                        msg.key = reader.readString();
                        break;
                    }
                    case 2: {
                        msg.value = Value.initialize();
                        reader.readMessage(msg.value, Value._readMessage);
                        break;
                    }
                    default: {
                        reader.skipField();
                        break;
                    }
                }
            }
            return msg;
        },
    },
};
export const Value = {
    /**
     * Serializes Value to protobuf.
     */
    encode: function (msg) {
        return Value._writeMessage(msg, new protoscript.BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Value from protobuf.
     */
    decode: function (bytes) {
        return Value._readMessage(Value.initialize(), new protoscript.BinaryReader(bytes));
    },
    /**
     * Initializes Value with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            nullValue: undefined,
            numberValue: undefined,
            stringValue: undefined,
            boolValue: undefined,
            structValue: undefined,
            listValue: undefined,
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.nullValue != undefined) {
            writer.writeEnum(1, NullValue._toInt(msg.nullValue));
        }
        if (msg.numberValue != undefined) {
            writer.writeDouble(2, msg.numberValue);
        }
        if (msg.stringValue != undefined) {
            writer.writeString(3, msg.stringValue);
        }
        if (msg.boolValue != undefined) {
            writer.writeBool(4, msg.boolValue);
        }
        if (msg.structValue != undefined) {
            writer.writeMessage(5, msg.structValue, Struct._writeMessage);
        }
        if (msg.listValue != undefined) {
            writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.nullValue = NullValue._fromInt(reader.readEnum());
                    break;
                }
                case 2: {
                    msg.numberValue = reader.readDouble();
                    break;
                }
                case 3: {
                    msg.stringValue = reader.readString();
                    break;
                }
                case 4: {
                    msg.boolValue = reader.readBool();
                    break;
                }
                case 5: {
                    msg.structValue = Struct.initialize();
                    reader.readMessage(msg.structValue, Struct._readMessage);
                    break;
                }
                case 6: {
                    msg.listValue = ListValue.initialize();
                    reader.readMessage(msg.listValue, ListValue._readMessage);
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const ListValue = {
    /**
     * Serializes ListValue to protobuf.
     */
    encode: function (msg) {
        return ListValue._writeMessage(msg, new protoscript.BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes ListValue from protobuf.
     */
    decode: function (bytes) {
        return ListValue._readMessage(ListValue.initialize(), new protoscript.BinaryReader(bytes));
    },
    /**
     * Initializes ListValue with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            values: [],
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.values?.length) {
            writer.writeRepeatedMessage(1, msg.values, Value._writeMessage);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    const m = Value.initialize();
                    reader.readMessage(m, Value._readMessage);
                    msg.values.push(m);
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
//========================================//
//          JSON Encode / Decode          //
//========================================//
export const NullValueJSON = {
    /**
     * Null value.
     */
    NULL_VALUE: "NULL_VALUE",
    /**
     * @private
     */
    _fromInt: function (i) {
        switch (i) {
            case 0: {
                return "NULL_VALUE";
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
    /**
     * @private
     */
    _toInt: function (i) {
        switch (i) {
            case "NULL_VALUE": {
                return 0;
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
};
export const StructJSON = {
    /**
     * Serializes Struct to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(StructJSON._writeMessage(msg));
    },
    /**
     * Deserializes Struct from JSON.
     */
    decode: function (json) {
        return StructJSON._readMessage(StructJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Struct with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            fields: {},
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.fields) {
            const _fields_ = Object.fromEntries(Object.entries(msg.fields)
                .map(([key, value]) => ({ key: key, value: value }))
                .map(StructJSON.Fields._writeMessage)
                .map(({ key, value }) => [key, value]));
            if (Object.keys(_fields_).length > 0) {
                json["fields"] = _fields_;
            }
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _fields_ = json["fields"];
        if (_fields_) {
            msg.fields = Object.fromEntries(Object.entries(_fields_)
                .map(([key, value]) => ({ key: key, value: value }))
                .map(StructJSON.Fields._readMessage)
                .map(({ key, value }) => [key, value]));
        }
        return msg;
    },
    Fields: {
        /**
         * @private
         */
        _writeMessage: function (msg) {
            const json = {};
            if (msg.key) {
                json["key"] = msg.key;
            }
            if (msg.value) {
                const _value_ = ValueJSON._writeMessage(msg.value);
                if (Object.keys(_value_).length > 0) {
                    json["value"] = _value_;
                }
            }
            return json;
        },
        /**
         * @private
         */
        _readMessage: function (msg, json) {
            const _key_ = json["key"];
            if (_key_) {
                msg.key = _key_;
            }
            const _value_ = json["value"];
            if (_value_) {
                ValueJSON._readMessage(msg.value, _value_);
            }
            return msg;
        },
    },
};
export const ValueJSON = {
    /**
     * Serializes Value to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(ValueJSON._writeMessage(msg));
    },
    /**
     * Deserializes Value from JSON.
     */
    decode: function (json) {
        return ValueJSON._readMessage(ValueJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Value with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            nullValue: undefined,
            numberValue: undefined,
            stringValue: undefined,
            boolValue: undefined,
            structValue: undefined,
            listValue: undefined,
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.nullValue != undefined) {
            json["nullValue"] = msg.nullValue;
        }
        if (msg.numberValue != undefined) {
            json["numberValue"] = msg.numberValue;
        }
        if (msg.stringValue != undefined) {
            json["stringValue"] = msg.stringValue;
        }
        if (msg.boolValue != undefined) {
            json["boolValue"] = msg.boolValue;
        }
        if (msg.structValue != undefined) {
            const _structValue_ = StructJSON._writeMessage(msg.structValue);
            json["structValue"] = _structValue_;
        }
        if (msg.listValue != undefined) {
            const _listValue_ = ListValueJSON._writeMessage(msg.listValue);
            json["listValue"] = _listValue_;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _nullValue_ = json["nullValue"] ?? json["null_value"];
        if (_nullValue_) {
            msg.nullValue = NullValue._fromInt(_nullValue_);
        }
        const _numberValue_ = json["numberValue"] ?? json["number_value"];
        if (_numberValue_) {
            msg.numberValue = protoscript.parseDouble(_numberValue_);
        }
        const _stringValue_ = json["stringValue"] ?? json["string_value"];
        if (_stringValue_) {
            msg.stringValue = _stringValue_;
        }
        const _boolValue_ = json["boolValue"] ?? json["bool_value"];
        if (_boolValue_) {
            msg.boolValue = _boolValue_;
        }
        const _structValue_ = json["structValue"] ?? json["struct_value"];
        if (_structValue_) {
            msg.structValue = StructJSON.initialize();
            StructJSON._readMessage(msg.structValue, _structValue_);
        }
        const _listValue_ = json["listValue"] ?? json["list_value"];
        if (_listValue_) {
            msg.listValue = ListValueJSON.initialize();
            ListValueJSON._readMessage(msg.listValue, _listValue_);
        }
        return msg;
    },
};
export const ListValueJSON = {
    /**
     * Serializes ListValue to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(ListValueJSON._writeMessage(msg));
    },
    /**
     * Deserializes ListValue from JSON.
     */
    decode: function (json) {
        return ListValueJSON._readMessage(ListValueJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes ListValue with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            values: [],
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.values?.length) {
            json["values"] = msg.values.map(ValueJSON._writeMessage);
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _values_ = json["values"];
        if (_values_) {
            for (const item of _values_) {
                const m = ValueJSON.initialize();
                ValueJSON._readMessage(m, item);
                msg.values.push(m);
            }
        }
        return msg;
    },
};
