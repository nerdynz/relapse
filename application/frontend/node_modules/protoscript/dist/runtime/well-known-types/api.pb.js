// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/api.proto
/* eslint-disable */
import * as protoscript from "protoscript";
//========================================//
//        Protobuf Encode / Decode        //
//========================================//
export const Api = {
    /**
     * Serializes Api to protobuf.
     */
    encode: function (msg) {
        return Api._writeMessage(msg, new protoscript.BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Api from protobuf.
     */
    decode: function (bytes) {
        return Api._readMessage(Api.initialize(), new protoscript.BinaryReader(bytes));
    },
    /**
     * Initializes Api with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            name: "",
            methods: [],
            options: [],
            version: "",
            sourceContext: protoscript.SourceContext.initialize(),
            mixins: [],
            syntax: protoscript.Syntax._fromInt(0),
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.methods?.length) {
            writer.writeRepeatedMessage(2, msg.methods, Method._writeMessage);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(3, msg.options, protoscript.Option._writeMessage);
        }
        if (msg.version) {
            writer.writeString(4, msg.version);
        }
        if (msg.sourceContext) {
            writer.writeMessage(5, msg.sourceContext, protoscript.SourceContext._writeMessage);
        }
        if (msg.mixins?.length) {
            writer.writeRepeatedMessage(6, msg.mixins, Mixin._writeMessage);
        }
        if (msg.syntax && protoscript.Syntax._toInt(msg.syntax)) {
            writer.writeEnum(7, protoscript.Syntax._toInt(msg.syntax));
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    const m = Method.initialize();
                    reader.readMessage(m, Method._readMessage);
                    msg.methods.push(m);
                    break;
                }
                case 3: {
                    const m = protoscript.Option.initialize();
                    reader.readMessage(m, protoscript.Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 4: {
                    msg.version = reader.readString();
                    break;
                }
                case 5: {
                    reader.readMessage(msg.sourceContext, protoscript.SourceContext._readMessage);
                    break;
                }
                case 6: {
                    const m = Mixin.initialize();
                    reader.readMessage(m, Mixin._readMessage);
                    msg.mixins.push(m);
                    break;
                }
                case 7: {
                    msg.syntax = protoscript.Syntax._fromInt(reader.readEnum());
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const Method = {
    /**
     * Serializes Method to protobuf.
     */
    encode: function (msg) {
        return Method._writeMessage(msg, new protoscript.BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Method from protobuf.
     */
    decode: function (bytes) {
        return Method._readMessage(Method.initialize(), new protoscript.BinaryReader(bytes));
    },
    /**
     * Initializes Method with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            name: "",
            requestTypeUrl: "",
            requestStreaming: false,
            responseTypeUrl: "",
            responseStreaming: false,
            options: [],
            syntax: protoscript.Syntax._fromInt(0),
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.requestTypeUrl) {
            writer.writeString(2, msg.requestTypeUrl);
        }
        if (msg.requestStreaming) {
            writer.writeBool(3, msg.requestStreaming);
        }
        if (msg.responseTypeUrl) {
            writer.writeString(4, msg.responseTypeUrl);
        }
        if (msg.responseStreaming) {
            writer.writeBool(5, msg.responseStreaming);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(6, msg.options, protoscript.Option._writeMessage);
        }
        if (msg.syntax && protoscript.Syntax._toInt(msg.syntax)) {
            writer.writeEnum(7, protoscript.Syntax._toInt(msg.syntax));
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    msg.requestTypeUrl = reader.readString();
                    break;
                }
                case 3: {
                    msg.requestStreaming = reader.readBool();
                    break;
                }
                case 4: {
                    msg.responseTypeUrl = reader.readString();
                    break;
                }
                case 5: {
                    msg.responseStreaming = reader.readBool();
                    break;
                }
                case 6: {
                    const m = protoscript.Option.initialize();
                    reader.readMessage(m, protoscript.Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 7: {
                    msg.syntax = protoscript.Syntax._fromInt(reader.readEnum());
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const Mixin = {
    /**
     * Serializes Mixin to protobuf.
     */
    encode: function (msg) {
        return Mixin._writeMessage(msg, new protoscript.BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Mixin from protobuf.
     */
    decode: function (bytes) {
        return Mixin._readMessage(Mixin.initialize(), new protoscript.BinaryReader(bytes));
    },
    /**
     * Initializes Mixin with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            name: "",
            root: "",
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.root) {
            writer.writeString(2, msg.root);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    msg.root = reader.readString();
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
//========================================//
//          JSON Encode / Decode          //
//========================================//
export const ApiJSON = {
    /**
     * Serializes Api to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(ApiJSON._writeMessage(msg));
    },
    /**
     * Deserializes Api from JSON.
     */
    decode: function (json) {
        return ApiJSON._readMessage(ApiJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Api with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            name: "",
            methods: [],
            options: [],
            version: "",
            sourceContext: protoscript.SourceContextJSON.initialize(),
            mixins: [],
            syntax: protoscript.Syntax._fromInt(0),
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.methods?.length) {
            json["methods"] = msg.methods.map(MethodJSON._writeMessage);
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(protoscript.OptionJSON._writeMessage);
        }
        if (msg.version) {
            json["version"] = msg.version;
        }
        if (msg.sourceContext) {
            const _sourceContext_ = protoscript.SourceContextJSON._writeMessage(msg.sourceContext);
            if (Object.keys(_sourceContext_).length > 0) {
                json["sourceContext"] = _sourceContext_;
            }
        }
        if (msg.mixins?.length) {
            json["mixins"] = msg.mixins.map(MixinJSON._writeMessage);
        }
        if (msg.syntax && protoscript.SyntaxJSON._toInt(msg.syntax)) {
            json["syntax"] = msg.syntax;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name_ = json["name"];
        if (_name_) {
            msg.name = _name_;
        }
        const _methods_ = json["methods"];
        if (_methods_) {
            for (const item of _methods_) {
                const m = MethodJSON.initialize();
                MethodJSON._readMessage(m, item);
                msg.methods.push(m);
            }
        }
        const _options_ = json["options"];
        if (_options_) {
            for (const item of _options_) {
                const m = protoscript.OptionJSON.initialize();
                protoscript.OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _version_ = json["version"];
        if (_version_) {
            msg.version = _version_;
        }
        const _sourceContext_ = json["sourceContext"] ?? json["source_context"];
        if (_sourceContext_) {
            protoscript.SourceContextJSON._readMessage(msg.sourceContext, _sourceContext_);
        }
        const _mixins_ = json["mixins"];
        if (_mixins_) {
            for (const item of _mixins_) {
                const m = MixinJSON.initialize();
                MixinJSON._readMessage(m, item);
                msg.mixins.push(m);
            }
        }
        const _syntax_ = json["syntax"];
        if (_syntax_) {
            msg.syntax = protoscript.Syntax._fromInt(_syntax_);
        }
        return msg;
    },
};
export const MethodJSON = {
    /**
     * Serializes Method to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(MethodJSON._writeMessage(msg));
    },
    /**
     * Deserializes Method from JSON.
     */
    decode: function (json) {
        return MethodJSON._readMessage(MethodJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Method with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            name: "",
            requestTypeUrl: "",
            requestStreaming: false,
            responseTypeUrl: "",
            responseStreaming: false,
            options: [],
            syntax: protoscript.Syntax._fromInt(0),
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.requestTypeUrl) {
            json["requestTypeUrl"] = msg.requestTypeUrl;
        }
        if (msg.requestStreaming) {
            json["requestStreaming"] = msg.requestStreaming;
        }
        if (msg.responseTypeUrl) {
            json["responseTypeUrl"] = msg.responseTypeUrl;
        }
        if (msg.responseStreaming) {
            json["responseStreaming"] = msg.responseStreaming;
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(protoscript.OptionJSON._writeMessage);
        }
        if (msg.syntax && protoscript.SyntaxJSON._toInt(msg.syntax)) {
            json["syntax"] = msg.syntax;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name_ = json["name"];
        if (_name_) {
            msg.name = _name_;
        }
        const _requestTypeUrl_ = json["requestTypeUrl"] ?? json["request_type_url"];
        if (_requestTypeUrl_) {
            msg.requestTypeUrl = _requestTypeUrl_;
        }
        const _requestStreaming_ = json["requestStreaming"] ?? json["request_streaming"];
        if (_requestStreaming_) {
            msg.requestStreaming = _requestStreaming_;
        }
        const _responseTypeUrl_ = json["responseTypeUrl"] ?? json["response_type_url"];
        if (_responseTypeUrl_) {
            msg.responseTypeUrl = _responseTypeUrl_;
        }
        const _responseStreaming_ = json["responseStreaming"] ?? json["response_streaming"];
        if (_responseStreaming_) {
            msg.responseStreaming = _responseStreaming_;
        }
        const _options_ = json["options"];
        if (_options_) {
            for (const item of _options_) {
                const m = protoscript.OptionJSON.initialize();
                protoscript.OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _syntax_ = json["syntax"];
        if (_syntax_) {
            msg.syntax = protoscript.Syntax._fromInt(_syntax_);
        }
        return msg;
    },
};
export const MixinJSON = {
    /**
     * Serializes Mixin to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(MixinJSON._writeMessage(msg));
    },
    /**
     * Deserializes Mixin from JSON.
     */
    decode: function (json) {
        return MixinJSON._readMessage(MixinJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Mixin with all fields set to their default value.
     */
    initialize: function (msg) {
        return {
            name: "",
            root: "",
            ...msg,
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.root) {
            json["root"] = msg.root;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name_ = json["name"];
        if (_name_) {
            msg.name = _name_;
        }
        const _root_ = json["root"];
        if (_root_) {
            msg.root = _root_;
        }
        return msg;
    },
};
