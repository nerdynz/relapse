import "./chunk-SSYGV25P.js";

// node_modules/fabric/dist/index.min.mjs
function t(t3, e2) {
  var s2 = Object.keys(t3);
  if (Object.getOwnPropertySymbols) {
    var i2 = Object.getOwnPropertySymbols(t3);
    e2 && (i2 = i2.filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t3, e3).enumerable;
    })), s2.push.apply(s2, i2);
  }
  return s2;
}
function e(e2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var r2 = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? t(Object(r2), true).forEach(function(t3) {
      s(e2, t3, r2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : t(Object(r2)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
    });
  }
  return e2;
}
function s(t3, e2, s2) {
  return (e2 = n(e2)) in t3 ? Object.defineProperty(t3, e2, { value: s2, enumerable: true, configurable: true, writable: true }) : t3[e2] = s2, t3;
}
function i(t3, e2) {
  if (null == t3)
    return {};
  var s2, i2, r2 = function(t4, e3) {
    if (null == t4)
      return {};
    var s3, i3, r3 = {}, n3 = Object.keys(t4);
    for (i3 = 0; i3 < n3.length; i3++)
      s3 = n3[i3], e3.indexOf(s3) >= 0 || (r3[s3] = t4[s3]);
    return r3;
  }(t3, e2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t3);
    for (i2 = 0; i2 < n2.length; i2++)
      s2 = n2[i2], e2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(t3, s2) && (r2[s2] = t3[s2]);
  }
  return r2;
}
function r(t3, e2) {
  return e2 || (e2 = t3.slice(0)), Object.freeze(Object.defineProperties(t3, { raw: { value: Object.freeze(e2) } }));
}
function n(t3) {
  var e2 = function(t4, e3) {
    if ("object" != typeof t4 || null === t4)
      return t4;
    var s2 = t4[Symbol.toPrimitive];
    if (void 0 !== s2) {
      var i2 = s2.call(t4, e3 || "default");
      if ("object" != typeof i2)
        return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === e3 ? String : Number)(t4);
  }(t3, "string");
  return "symbol" == typeof e2 ? e2 : String(e2);
}
var o = class {
  constructor() {
    s(this, "browserShadowBlurConstant", 1), s(this, "DPI", 96), s(this, "devicePixelRatio", "undefined" != typeof window ? window.devicePixelRatio : 1), s(this, "perfLimitSizeTotal", 2097152), s(this, "maxCacheSideLimit", 4096), s(this, "minCacheSideLimit", 256), s(this, "disableStyleCopyPaste", false), s(this, "enableGLFiltering", true), s(this, "textureSize", 4096), s(this, "forceGLPutImageData", false), s(this, "cachesBoundsOfCurve", true), s(this, "fontPaths", {}), s(this, "NUM_FRACTION_DIGITS", 4);
  }
};
var a = new class extends o {
  constructor(t3) {
    super(), this.configure(t3);
  }
  configure() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    Object.assign(this, t3);
  }
  addFonts() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.fontPaths = e(e({}, this.fontPaths), t3);
  }
  removeFonts() {
    (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((t3) => {
      delete this.fontPaths[t3];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(t3) {
    const e2 = new o(), s2 = (null == t3 ? void 0 : t3.reduce((t4, s3) => (t4[s3] = e2[s3], t4), {})) || e2;
    this.configure(s2);
  }
}();
var h = function(t3) {
  for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), i2 = 1; i2 < e2; i2++)
    s2[i2 - 1] = arguments[i2];
  return console[t3]("fabric", ...s2);
};
var c = class extends Error {
  constructor(t3, e2) {
    super("fabric: ".concat(t3), e2);
  }
};
var l = class extends c {
  constructor(t3) {
    super("".concat(t3, " 'options.signal' is in 'aborted' state"));
  }
};
var u = class {
};
var d = class extends u {
  testPrecision(t3, e2) {
    const s2 = "precision ".concat(e2, " float;\nvoid main(){}"), i2 = t3.createShader(t3.FRAGMENT_SHADER);
    return !!i2 && (t3.shaderSource(i2, s2), t3.compileShader(i2), !!t3.getShaderParameter(i2, t3.COMPILE_STATUS));
  }
  queryWebGL(t3) {
    const e2 = t3.getContext("webgl");
    e2 && (this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((t4) => this.testPrecision(e2, t4)), e2.getExtension("WEBGL_lose_context").loseContext(), h("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(t3) {
    return !!this.maxTextureSize && this.maxTextureSize >= t3;
  }
};
var g = {};
var f;
var p = (t3) => {
  f = t3;
};
var m = () => f || (f = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new d(), dispose() {
}, copyPasteData: g });
var v = () => m().document;
var y = () => m().window;
var _ = () => {
  var t3;
  return Math.max(null !== (t3 = a.devicePixelRatio) && void 0 !== t3 ? t3 : y().devicePixelRatio, 1);
};
var x = new class {
  constructor() {
    s(this, "charWidthsCache", {}), s(this, "boundsOfCurveCache", {});
  }
  getFontCache(t3) {
    let { fontFamily: e2, fontStyle: s2, fontWeight: i2 } = t3;
    e2 = e2.toLowerCase(), this.charWidthsCache[e2] || (this.charWidthsCache[e2] = {});
    const r2 = this.charWidthsCache[e2], n2 = "".concat(s2.toLowerCase(), "_").concat((i2 + "").toLowerCase());
    return r2[n2] || (r2[n2] = {}), r2[n2];
  }
  clearFontCache(t3) {
    (t3 = (t3 || "").toLowerCase()) ? this.charWidthsCache[t3] && delete this.charWidthsCache[t3] : this.charWidthsCache = {};
  }
  limitDimsByArea(t3) {
    const { perfLimitSizeTotal: e2 } = a, s2 = Math.sqrt(e2 * t3);
    return [Math.floor(s2), Math.floor(e2 / s2)];
  }
}();
var C = "6.0.0-rc2";
function b() {
}
var w = Math.PI / 2;
var S = 2 * Math.PI;
var T = Math.PI / 180;
var O = Object.freeze([1, 0, 0, 1, 0, 0]);
var k = 16;
var D = 0.4477152502;
var M = "center";
var P = "left";
var E = "top";
var A = "bottom";
var j = "right";
var F = "none";
var L = /\r?\n/;
var R = "json";
var B = "svg";
var I = new class {
  constructor() {
    this[R] = /* @__PURE__ */ new Map(), this[B] = /* @__PURE__ */ new Map();
  }
  getClass(t3) {
    const e2 = this[R].get(t3);
    if (!e2)
      throw new c("No class registered for ".concat(t3));
    return e2;
  }
  setClass(t3, e2) {
    e2 ? this[R].set(e2, t3) : (this[R].set(t3.type, t3), this[R].set(t3.type.toLowerCase(), t3));
  }
  getSVGClass(t3) {
    return this[B].get(t3);
  }
  setSVGClass(t3, e2) {
    this[B].set(null != e2 ? e2 : t3.type.toLowerCase(), t3);
  }
}();
var X = new class extends Array {
  remove(t3) {
    const e2 = this.indexOf(t3);
    e2 > -1 && this.splice(e2, 1);
  }
  cancelAll() {
    const t3 = this.splice(0);
    return t3.forEach((t4) => t4.abort()), t3;
  }
  cancelByCanvas(t3) {
    if (!t3)
      return [];
    const e2 = this.filter((e3) => {
      var s2;
      return e3.target === t3 || "object" == typeof e3.target && (null === (s2 = e3.target) || void 0 === s2 ? void 0 : s2.canvas) === t3;
    });
    return e2.forEach((t4) => t4.abort()), e2;
  }
  cancelByTarget(t3) {
    if (!t3)
      return [];
    const e2 = this.filter((e3) => e3.target === t3);
    return e2.forEach((t4) => t4.abort()), e2;
  }
}();
var Y = class {
  constructor() {
    s(this, "__eventListeners", {});
  }
  on(t3, e2) {
    if (this.__eventListeners || (this.__eventListeners = {}), "object" == typeof t3)
      return Object.entries(t3).forEach((t4) => {
        let [e3, s2] = t4;
        this.on(e3, s2);
      }), () => this.off(t3);
    if (e2) {
      const s2 = t3;
      return this.__eventListeners[s2] || (this.__eventListeners[s2] = []), this.__eventListeners[s2].push(e2), () => this.off(s2, e2);
    }
    return () => false;
  }
  once(t3, e2) {
    if ("object" == typeof t3) {
      const e3 = [];
      return Object.entries(t3).forEach((t4) => {
        let [s2, i2] = t4;
        e3.push(this.once(s2, i2));
      }), () => e3.forEach((t4) => t4());
    }
    if (e2) {
      const s2 = this.on(t3, function() {
        for (var t4 = arguments.length, i2 = new Array(t4), r2 = 0; r2 < t4; r2++)
          i2[r2] = arguments[r2];
        e2.call(this, ...i2), s2();
      });
      return s2;
    }
    return () => false;
  }
  _removeEventListener(t3, e2) {
    if (this.__eventListeners[t3])
      if (e2) {
        const s2 = this.__eventListeners[t3], i2 = s2.indexOf(e2);
        i2 > -1 && s2.splice(i2, 1);
      } else
        this.__eventListeners[t3] = [];
  }
  off(t3, e2) {
    if (this.__eventListeners)
      if (void 0 === t3)
        for (const t4 in this.__eventListeners)
          this._removeEventListener(t4);
      else
        "object" == typeof t3 ? Object.entries(t3).forEach((t4) => {
          let [e3, s2] = t4;
          this._removeEventListener(e3, s2);
        }) : this._removeEventListener(t3, e2);
  }
  fire(t3, e2) {
    var s2;
    if (!this.__eventListeners)
      return;
    const i2 = null === (s2 = this.__eventListeners[t3]) || void 0 === s2 ? void 0 : s2.concat();
    if (i2)
      for (let t4 = 0; t4 < i2.length; t4++)
        i2[t4].call(this, e2 || {});
  }
};
var W = (t3, e2) => Math.floor(Math.random() * (e2 - t3 + 1)) + t3;
var V = (t3, e2) => isNaN(t3) && "number" == typeof e2 ? e2 : t3;
var z = (t3, e2) => {
  const s2 = t3.indexOf(e2);
  return -1 !== s2 && t3.splice(s2, 1), t3;
};
var H = (t3) => {
  if (0 === t3)
    return 1;
  switch (Math.abs(t3) / w) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(t3);
};
var G = (t3) => {
  if (0 === t3)
    return 0;
  const e2 = t3 / w, s2 = Math.sign(t3);
  switch (e2) {
    case 1:
      return s2;
    case 2:
      return 0;
    case 3:
      return -s2;
  }
  return Math.sin(t3);
};
var U = class _U {
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    "object" == typeof t3 ? (this.x = t3.x, this.y = t3.y) : (this.x = t3, this.y = e2);
  }
  add(t3) {
    return new _U(this.x + t3.x, this.y + t3.y);
  }
  addEquals(t3) {
    return this.x += t3.x, this.y += t3.y, this;
  }
  scalarAdd(t3) {
    return new _U(this.x + t3, this.y + t3);
  }
  scalarAddEquals(t3) {
    return this.x += t3, this.y += t3, this;
  }
  subtract(t3) {
    return new _U(this.x - t3.x, this.y - t3.y);
  }
  subtractEquals(t3) {
    return this.x -= t3.x, this.y -= t3.y, this;
  }
  scalarSubtract(t3) {
    return new _U(this.x - t3, this.y - t3);
  }
  scalarSubtractEquals(t3) {
    return this.x -= t3, this.y -= t3, this;
  }
  multiply(t3) {
    return new _U(this.x * t3.x, this.y * t3.y);
  }
  scalarMultiply(t3) {
    return new _U(this.x * t3, this.y * t3);
  }
  scalarMultiplyEquals(t3) {
    return this.x *= t3, this.y *= t3, this;
  }
  divide(t3) {
    return new _U(this.x / t3.x, this.y / t3.y);
  }
  scalarDivide(t3) {
    return new _U(this.x / t3, this.y / t3);
  }
  scalarDivideEquals(t3) {
    return this.x /= t3, this.y /= t3, this;
  }
  eq(t3) {
    return this.x === t3.x && this.y === t3.y;
  }
  lt(t3) {
    return this.x < t3.x && this.y < t3.y;
  }
  lte(t3) {
    return this.x <= t3.x && this.y <= t3.y;
  }
  gt(t3) {
    return this.x > t3.x && this.y > t3.y;
  }
  gte(t3) {
    return this.x >= t3.x && this.y >= t3.y;
  }
  lerp(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.5;
    return e2 = Math.max(Math.min(1, e2), 0), new _U(this.x + (t3.x - this.x) * e2, this.y + (t3.y - this.y) * e2);
  }
  distanceFrom(t3) {
    const e2 = this.x - t3.x, s2 = this.y - t3.y;
    return Math.sqrt(e2 * e2 + s2 * s2);
  }
  midPointFrom(t3) {
    return this.lerp(t3);
  }
  min(t3) {
    return new _U(Math.min(this.x, t3.x), Math.min(this.y, t3.y));
  }
  max(t3) {
    return new _U(Math.max(this.x, t3.x), Math.max(this.y, t3.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(t3, e2) {
    return this.x = t3, this.y = e2, this;
  }
  setX(t3) {
    return this.x = t3, this;
  }
  setY(t3) {
    return this.y = t3, this;
  }
  setFromPoint(t3) {
    return this.x = t3.x, this.y = t3.y, this;
  }
  swap(t3) {
    const e2 = this.x, s2 = this.y;
    this.x = t3.x, this.y = t3.y, t3.x = e2, t3.y = s2;
  }
  clone() {
    return new _U(this.x, this.y);
  }
  rotate(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N;
    const s2 = G(t3), i2 = H(t3), r2 = this.subtract(e2);
    return new _U(r2.x * i2 - r2.y * s2, r2.x * s2 + r2.y * i2).add(e2);
  }
  transform(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return new _U(t3[0] * this.x + t3[2] * this.y + (e2 ? 0 : t3[4]), t3[1] * this.x + t3[3] * this.y + (e2 ? 0 : t3[5]));
  }
};
var N = new U(0, 0);
var q = (t3) => !!t3 && Array.isArray(t3._objects);
function K(t3) {
  class e2 extends t3 {
    constructor() {
      super(...arguments), s(this, "_objects", []);
    }
    _onObjectAdded(t4) {
    }
    _onObjectRemoved(t4) {
    }
    _onStackOrderChanged(t4) {
    }
    add() {
      for (var t4 = arguments.length, e3 = new Array(t4), s2 = 0; s2 < t4; s2++)
        e3[s2] = arguments[s2];
      const i2 = this._objects.push(...e3);
      return e3.forEach((t5) => this._onObjectAdded(t5)), i2;
    }
    insertAt(t4) {
      for (var e3 = arguments.length, s2 = new Array(e3 > 1 ? e3 - 1 : 0), i2 = 1; i2 < e3; i2++)
        s2[i2 - 1] = arguments[i2];
      return this._objects.splice(t4, 0, ...s2), s2.forEach((t5) => this._onObjectAdded(t5)), this._objects.length;
    }
    remove() {
      const t4 = this._objects, e3 = [];
      for (var s2 = arguments.length, i2 = new Array(s2), r2 = 0; r2 < s2; r2++)
        i2[r2] = arguments[r2];
      return i2.forEach((s3) => {
        const i3 = t4.indexOf(s3);
        -1 !== i3 && (t4.splice(i3, 1), e3.push(s3), this._onObjectRemoved(s3));
      }), e3;
    }
    forEachObject(t4) {
      this.getObjects().forEach((e3, s2, i2) => t4(e3, s2, i2));
    }
    getObjects() {
      for (var t4 = arguments.length, e3 = new Array(t4), s2 = 0; s2 < t4; s2++)
        e3[s2] = arguments[s2];
      return 0 === e3.length ? [...this._objects] : this._objects.filter((t5) => t5.isType(...e3));
    }
    item(t4) {
      return this._objects[t4];
    }
    isEmpty() {
      return 0 === this._objects.length;
    }
    size() {
      return this._objects.length;
    }
    contains(t4, s2) {
      return !!this._objects.includes(t4) || !!s2 && this._objects.some((s3) => s3 instanceof e2 && s3.contains(t4, true));
    }
    complexity() {
      return this._objects.reduce((t4, e3) => t4 += e3.complexity ? e3.complexity() : 0, 0);
    }
    sendObjectToBack(t4) {
      return !(!t4 || t4 === this._objects[0]) && (z(this._objects, t4), this._objects.unshift(t4), this._onStackOrderChanged(t4), true);
    }
    bringObjectToFront(t4) {
      return !(!t4 || t4 === this._objects[this._objects.length - 1]) && (z(this._objects, t4), this._objects.push(t4), this._onStackOrderChanged(t4), true);
    }
    sendObjectBackwards(t4, e3) {
      if (!t4)
        return false;
      const s2 = this._objects.indexOf(t4);
      if (0 !== s2) {
        const i2 = this.findNewLowerIndex(t4, s2, e3);
        return z(this._objects, t4), this._objects.splice(i2, 0, t4), this._onStackOrderChanged(t4), true;
      }
      return false;
    }
    bringObjectForward(t4, e3) {
      if (!t4)
        return false;
      const s2 = this._objects.indexOf(t4);
      if (s2 !== this._objects.length - 1) {
        const i2 = this.findNewUpperIndex(t4, s2, e3);
        return z(this._objects, t4), this._objects.splice(i2, 0, t4), this._onStackOrderChanged(t4), true;
      }
      return false;
    }
    moveObjectTo(t4, e3) {
      return t4 !== this._objects[e3] && (z(this._objects, t4), this._objects.splice(e3, 0, t4), this._onStackOrderChanged(t4), true);
    }
    findNewLowerIndex(t4, e3, s2) {
      let i2;
      if (s2) {
        i2 = e3;
        for (let s3 = e3 - 1; s3 >= 0; --s3)
          if (t4.isOverlapping(this._objects[s3])) {
            i2 = s3;
            break;
          }
      } else
        i2 = e3 - 1;
      return i2;
    }
    findNewUpperIndex(t4, e3, s2) {
      let i2;
      if (s2) {
        i2 = e3;
        for (let s3 = e3 + 1; s3 < this._objects.length; ++s3)
          if (t4.isOverlapping(this._objects[s3])) {
            i2 = s3;
            break;
          }
      } else
        i2 = e3 + 1;
      return i2;
    }
    collectObjects(t4) {
      let { left: e3, top: s2, width: i2, height: r2 } = t4, { includeIntersecting: n2 = true } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const o2 = [], a2 = new U(e3, s2), h2 = a2.add(new U(i2, r2));
      for (let t5 = this._objects.length - 1; t5 >= 0; t5--) {
        const e4 = this._objects[t5];
        e4.selectable && e4.visible && (n2 && e4.intersectsWithRect(a2, h2) || e4.isContainedWithinRect(a2, h2) || n2 && e4.containsPoint(a2) || n2 && e4.containsPoint(h2)) && o2.push(e4);
      }
      return o2;
    }
  }
  return e2;
}
var J = class extends Y {
  _setOptions() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    for (const e2 in t3)
      this.set(e2, t3[e2]);
  }
  _setObject(t3) {
    for (const e2 in t3)
      this._set(e2, t3[e2]);
  }
  set(t3, e2) {
    return "object" == typeof t3 ? this._setObject(t3) : this._set(t3, e2), this;
  }
  _set(t3, e2) {
    this[t3] = e2;
  }
  toggle(t3) {
    const e2 = this.get(t3);
    return "boolean" == typeof e2 && this.set(t3, !e2), this;
  }
  get(t3) {
    return this[t3];
  }
};
function Z(t3) {
  return y().requestAnimationFrame(t3);
}
function Q(t3) {
  return y().cancelAnimationFrame(t3);
}
var $ = 0;
var tt = () => $++;
var et = () => {
  const t3 = v().createElement("canvas");
  if (!t3 || void 0 === t3.getContext)
    throw new c("Failed to create `canvas` element");
  return t3;
};
var st = () => v().createElement("img");
var it = (t3, e2, s2) => t3.toDataURL("image/".concat(e2), s2);
var rt = (t3) => t3 * T;
var nt = (t3) => t3 / T;
var ot = (t3) => t3.every((t4, e2) => t4 === O[e2]);
var at = (t3, e2, s2) => new U(t3).transform(e2, s2);
var ht = (t3) => {
  const e2 = 1 / (t3[0] * t3[3] - t3[1] * t3[2]), s2 = [e2 * t3[3], -e2 * t3[1], -e2 * t3[2], e2 * t3[0], 0, 0], { x: i2, y: r2 } = new U(t3[4], t3[5]).transform(s2, true);
  return s2[4] = -i2, s2[5] = -r2, s2;
};
var ct = (t3, e2, s2) => [t3[0] * e2[0] + t3[2] * e2[1], t3[1] * e2[0] + t3[3] * e2[1], t3[0] * e2[2] + t3[2] * e2[3], t3[1] * e2[2] + t3[3] * e2[3], s2 ? 0 : t3[0] * e2[4] + t3[2] * e2[5] + t3[4], s2 ? 0 : t3[1] * e2[4] + t3[3] * e2[5] + t3[5]];
var lt = (t3, e2) => t3.reduceRight((t4, s2) => s2 && t4 ? ct(s2, t4, e2) : s2 || t4, void 0) || O.concat();
var ut = (t3) => {
  let [e2, s2] = t3;
  return Math.atan2(s2, e2);
};
var dt = (t3) => {
  const e2 = ut(t3), s2 = Math.pow(t3[0], 2) + Math.pow(t3[1], 2), i2 = Math.sqrt(s2), r2 = (t3[0] * t3[3] - t3[2] * t3[1]) / i2, n2 = Math.atan2(t3[0] * t3[2] + t3[1] * t3[3], s2);
  return { angle: nt(e2), scaleX: i2, scaleY: r2, skewX: nt(n2), skewY: 0, translateX: t3[4] || 0, translateY: t3[5] || 0 };
};
var gt = function(t3) {
  return [1, 0, 0, 1, t3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0];
};
function ft() {
  let { angle: t3 = 0 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { x: e2 = 0, y: s2 = 0 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const i2 = rt(t3), r2 = H(i2), n2 = G(i2);
  return [r2, n2, -n2, r2, e2 ? e2 - (r2 * e2 - n2 * s2) : 0, s2 ? s2 - (n2 * e2 + r2 * s2) : 0];
}
var pt = function(t3) {
  return [t3, 0, 0, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t3, 0, 0];
};
var mt = (t3) => Math.tan(rt(t3));
var vt = (t3) => [1, 0, mt(t3), 1, 0, 0];
var yt = (t3) => [1, mt(t3), 0, 1, 0, 0];
var _t = (t3) => {
  let { scaleX: e2 = 1, scaleY: s2 = 1, flipX: i2 = false, flipY: r2 = false, skewX: n2 = 0, skewY: o2 = 0 } = t3, a2 = pt(i2 ? -e2 : e2, r2 ? -s2 : s2);
  return n2 && (a2 = ct(a2, vt(n2), true)), o2 && (a2 = ct(a2, yt(o2), true)), a2;
};
var xt = (t3) => {
  const { translateX: e2 = 0, translateY: s2 = 0, angle: i2 = 0 } = t3;
  let r2 = gt(e2, s2);
  i2 && (r2 = ct(r2, ft({ angle: i2 })));
  const n2 = _t(t3);
  return ot(n2) || (r2 = ct(r2, n2)), r2;
};
var Ct = function(t3) {
  let { signal: e2, crossOrigin: s2 = null } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return new Promise(function(i2, r2) {
    if (e2 && e2.aborted)
      return r2(new l("loadImage"));
    const n2 = st();
    let o2;
    e2 && (o2 = function(t4) {
      n2.src = "", r2(t4);
    }, e2.addEventListener("abort", o2, { once: true }));
    const a2 = function() {
      n2.onload = n2.onerror = null, o2 && (null == e2 || e2.removeEventListener("abort", o2)), i2(n2);
    };
    t3 ? (n2.onload = a2, n2.onerror = function() {
      o2 && (null == e2 || e2.removeEventListener("abort", o2)), r2(new c("Error loading ".concat(n2.src)));
    }, s2 && (n2.crossOrigin = s2), n2.src = t3) : a2();
  });
};
var bt = function(t3) {
  let { signal: e2, reviver: s2 = b } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return new Promise((i2, r2) => {
    const n2 = [];
    e2 && e2.addEventListener("abort", r2, { once: true }), Promise.all(t3.map((t4) => I.getClass(t4.type).fromObject(t4, { signal: e2 }).then((e3) => (s2(t4, e3), n2.push(e3), e3)))).then(i2).catch((t4) => {
      n2.forEach((t5) => {
        t5.dispose && t5.dispose();
      }), r2(t4);
    }).finally(() => {
      e2 && e2.removeEventListener("abort", r2);
    });
  });
};
var wt = function(t3) {
  let { signal: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return new Promise((s2, i2) => {
    const r2 = [];
    e2 && e2.addEventListener("abort", i2, { once: true });
    const n2 = Object.values(t3).map((t4) => t4 ? t4.type ? bt([t4], { signal: e2 }).then((t5) => {
      let [e3] = t5;
      return r2.push(e3), e3;
    }) : t4.source ? I.getClass("pattern").fromObject(t4, { signal: e2 }).then((t5) => (r2.push(t5), t5)) : t4 : t4), o2 = Object.keys(t3);
    Promise.all(n2).then((t4) => t4.reduce((t5, e3, s3) => (t5[o2[s3]] = e3, t5), {})).then(s2).catch((t4) => {
      r2.forEach((t5) => {
        t5.dispose && t5.dispose();
      }), i2(t4);
    }).finally(() => {
      e2 && e2.removeEventListener("abort", i2);
    });
  });
};
var St = function(t3) {
  return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []).reduce((e2, s2) => (s2 in t3 && (e2[s2] = t3[s2]), e2), {});
};
var Tt = (t3, e2) => Object.keys(t3).reduce((s2, i2) => (e2(t3[i2], i2, t3) && (s2[i2] = t3[i2]), s2), {});
var Ot = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" };
var kt = (t3, e2, s2) => (s2 < 0 && (s2 += 1), s2 > 1 && (s2 -= 1), s2 < 1 / 6 ? t3 + 6 * (e2 - t3) * s2 : s2 < 0.5 ? e2 : s2 < 2 / 3 ? t3 + (e2 - t3) * (2 / 3 - s2) * 6 : t3);
var Dt = (t3, e2, s2, i2) => {
  t3 /= 255, e2 /= 255, s2 /= 255;
  const r2 = Math.max(t3, e2, s2), n2 = Math.min(t3, e2, s2);
  let o2, a2;
  const h2 = (r2 + n2) / 2;
  if (r2 === n2)
    o2 = a2 = 0;
  else {
    const i3 = r2 - n2;
    switch (a2 = h2 > 0.5 ? i3 / (2 - r2 - n2) : i3 / (r2 + n2), r2) {
      case t3:
        o2 = (e2 - s2) / i3 + (e2 < s2 ? 6 : 0);
        break;
      case e2:
        o2 = (s2 - t3) / i3 + 2;
        break;
      case s2:
        o2 = (t3 - e2) / i3 + 4;
    }
    o2 /= 6;
  }
  return [Math.round(360 * o2), Math.round(100 * a2), Math.round(100 * h2), i2];
};
var Mt = function() {
  let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "1";
  return parseFloat(t3) / (t3.endsWith("%") ? 100 : 1);
};
var Pt = (t3) => Math.min(Math.round(t3), 255).toString(16).toUpperCase().padStart(2, "0");
var Et = (t3) => {
  let [e2, s2, i2, r2 = 1] = t3;
  const n2 = Math.round(0.3 * e2 + 0.59 * s2 + 0.11 * i2);
  return [n2, n2, n2, r2];
};
var At = class _At {
  constructor(t3) {
    if (t3)
      if (t3 instanceof _At)
        this.setSource([...t3._source]);
      else if (Array.isArray(t3)) {
        const [e2, s2, i2, r2 = 1] = t3;
        this.setSource([e2, s2, i2, r2]);
      } else
        this.setSource(this._tryParsingColor(t3));
    else
      this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(t3) {
    return t3 in Ot && (t3 = Ot[t3]), "transparent" === t3 ? [255, 255, 255, 0] : _At.sourceFromHex(t3) || _At.sourceFromRgb(t3) || _At.sourceFromHsl(t3) || [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(t3) {
    this._source = t3;
  }
  toRgb() {
    const [t3, e2, s2] = this.getSource();
    return "rgb(".concat(t3, ",").concat(e2, ",").concat(s2, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [t3, e2, s2] = Dt(...this.getSource());
    return "hsl(".concat(t3, ",").concat(e2, "%,").concat(s2, "%)");
  }
  toHsla() {
    const [t3, e2, s2, i2] = Dt(...this.getSource());
    return "hsla(".concat(t3, ",").concat(e2, "%,").concat(s2, "%,").concat(i2, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [t3, e2, s2, i2] = this.getSource();
    return "".concat(Pt(t3)).concat(Pt(e2)).concat(Pt(s2)).concat(Pt(Math.round(255 * i2)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(t3) {
    return this._source[3] = t3, this;
  }
  toGrayscale() {
    return this.setSource(Et(this.getSource())), this;
  }
  toBlackWhite(t3) {
    const [e2, , , s2] = Et(this.getSource()), i2 = e2 < (t3 || 127) ? 0 : 255;
    return this.setSource([i2, i2, i2, s2]), this;
  }
  overlayWith(t3) {
    t3 instanceof _At || (t3 = new _At(t3));
    const e2 = this.getSource(), s2 = t3.getSource(), [i2, r2, n2] = e2.map((t4, e3) => Math.round(0.5 * t4 + 0.5 * s2[e3]));
    return this.setSource([i2, r2, n2, e2[3]]), this;
  }
  static fromRgb(t3) {
    return _At.fromRgba(t3);
  }
  static fromRgba(t3) {
    return new _At(_At.sourceFromRgb(t3));
  }
  static sourceFromRgb(t3) {
    const e2 = t3.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);
    if (e2) {
      const [t4, s2, i2] = e2.slice(1, 4).map((t5) => {
        const e3 = parseFloat(t5);
        return t5.endsWith("%") ? Math.round(2.55 * e3) : e3;
      });
      return [t4, s2, i2, Mt(e2[4])];
    }
  }
  static fromHsl(t3) {
    return _At.fromHsla(t3);
  }
  static fromHsla(t3) {
    return new _At(_At.sourceFromHsl(t3));
  }
  static sourceFromHsl(t3) {
    const e2 = t3.match(/^hsla?\(\s*([+-]?\d{1,3})\s*[\s|,]\s*(\d{1,3}%)\s*[\s|,]\s*(\d{1,3}%)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);
    if (!e2)
      return;
    const s2 = (parseFloat(e2[1]) % 360 + 360) % 360 / 360, i2 = parseFloat(e2[2]) / 100, r2 = parseFloat(e2[3]) / 100;
    let n2, o2, a2;
    if (0 === i2)
      n2 = o2 = a2 = r2;
    else {
      const t4 = r2 <= 0.5 ? r2 * (i2 + 1) : r2 + i2 - r2 * i2, e3 = 2 * r2 - t4;
      n2 = kt(e3, t4, s2 + 1 / 3), o2 = kt(e3, t4, s2), a2 = kt(e3, t4, s2 - 1 / 3);
    }
    return [Math.round(255 * n2), Math.round(255 * o2), Math.round(255 * a2), Mt(e2[4])];
  }
  static fromHex(t3) {
    return new _At(_At.sourceFromHex(t3));
  }
  static sourceFromHex(t3) {
    if (t3.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const e2 = t3.slice(t3.indexOf("#") + 1);
      let s2;
      s2 = e2.length <= 4 ? e2.split("").map((t4) => t4 + t4) : e2.match(/.{2}/g);
      const [i2, r2, n2, o2 = 255] = s2.map((t4) => parseInt(t4, 16));
      return [i2, r2, n2, o2 / 255];
    }
  }
};
var jt = (t3, e2) => parseFloat(Number(t3).toFixed(e2));
var Ft = function(t3) {
  let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : k;
  const s2 = /\D{0,2}$/.exec(t3), i2 = parseFloat(t3), r2 = a.DPI;
  switch (null == s2 ? void 0 : s2[0]) {
    case "mm":
      return i2 * r2 / 25.4;
    case "cm":
      return i2 * r2 / 2.54;
    case "in":
      return i2 * r2;
    case "pt":
      return i2 * r2 / 72;
    case "pc":
      return i2 * r2 / 72 * 12;
    case "em":
      return i2 * e2;
    default:
      return i2;
  }
};
var Lt = (t3) => {
  const [e2, s2] = t3.trim().split(" "), [i2, r2] = (n2 = e2) && n2 !== F ? [n2.slice(1, 4), n2.slice(5, 8)] : n2 === F ? [n2, n2] : ["Mid", "Mid"];
  var n2;
  return { meetOrSlice: s2 || "meet", alignX: i2, alignY: r2 };
};
var Rt = (t3) => "matrix(" + t3.map((t4) => jt(t4, a.NUM_FRACTION_DIGITS)).join(" ") + ")";
var Bt = function(t3, e2) {
  let s2, i2, r2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
  if (e2)
    if (e2.toLive)
      s2 = "url(#SVGID_".concat(e2.id, ")");
    else {
      const t4 = new At(e2), r3 = t4.getAlpha();
      s2 = t4.toRgb(), 1 !== r3 && (i2 = r3.toString());
    }
  else
    s2 = "none";
  return r2 ? "".concat(t3, ": ").concat(s2, "; ").concat(i2 ? "".concat(t3, "-opacity: ").concat(i2, "; ") : "") : "".concat(t3, '="').concat(s2, '" ').concat(i2 ? "".concat(t3, '-opacity="').concat(i2, '" ') : "");
};
var It = (t3) => !!t3 && void 0 !== t3.toLive;
var Xt = (t3) => !!t3 && "function" == typeof t3.toObject;
var Yt = (t3) => !!t3 && void 0 !== t3.offsetX && "source" in t3;
var Wt = (t3) => !!t3 && "function" == typeof t3._renderText;
var Vt = (t3) => !!t3 && "multiSelectionStacking" in t3;
function zt(t3) {
  const e2 = t3 && Ht(t3);
  let s2 = 0, i2 = 0;
  if (!t3 || !e2)
    return { left: s2, top: i2 };
  const r2 = e2.documentElement, n2 = e2.body || { scrollLeft: 0, scrollTop: 0 };
  for (; t3 && (t3.parentNode || t3.host) && ((t3 = t3.parentNode || t3.host) === e2 ? (s2 = n2.scrollLeft || r2.scrollLeft || 0, i2 = n2.scrollTop || r2.scrollTop || 0) : (s2 += t3.scrollLeft || 0, i2 += t3.scrollTop || 0), 1 !== t3.nodeType || "fixed" !== t3.style.position); )
    ;
  return { left: s2, top: i2 };
}
var Ht = (t3) => t3.ownerDocument || null;
var Gt = (t3) => {
  var e2;
  return (null === (e2 = t3.ownerDocument) || void 0 === e2 ? void 0 : e2.defaultView) || null;
};
function Ut(t3, e2) {
  const s2 = t3.style;
  s2 && ("string" == typeof e2 ? t3.style.cssText += ";" + e2 : Object.entries(e2).forEach((t4) => {
    let [e3, i2] = t4;
    return s2.setProperty(e3, i2);
  }));
}
var Nt = function(t3, e2, s2) {
  let { width: i2, height: r2 } = s2, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
  t3.width = i2, t3.height = r2, n2 > 1 && (t3.setAttribute("width", (i2 * n2).toString()), t3.setAttribute("height", (r2 * n2).toString()), e2.scale(n2, n2));
};
var qt = (t3, e2) => {
  let { width: s2, height: i2 } = e2;
  s2 && (t3.style.width = "number" == typeof s2 ? "".concat(s2, "px") : s2), i2 && (t3.style.height = "number" == typeof i2 ? "".concat(i2, "px") : i2);
};
function Kt(t3) {
  return void 0 !== t3.onselectstart && (t3.onselectstart = () => false), t3.style.userSelect = F, t3;
}
var Jt = class {
  constructor(t3) {
    s(this, "_originalCanvasStyle", void 0), s(this, "lower", void 0);
    const e2 = this.createLowerCanvas(t3);
    this.lower = { el: e2, ctx: e2.getContext("2d") };
  }
  createLowerCanvas(t3) {
    const e2 = (s2 = t3) && void 0 !== s2.getContext ? t3 : t3 && v().getElementById(t3) || et();
    var s2;
    if (e2.hasAttribute("data-fabric"))
      throw new c("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = e2.style.cssText, e2.setAttribute("data-fabric", "main"), e2.classList.add("lower-canvas"), e2;
  }
  cleanupDOM(t3) {
    let { width: e2, height: s2 } = t3;
    const { el: i2 } = this.lower;
    i2.classList.remove("lower-canvas"), i2.removeAttribute("data-fabric"), i2.setAttribute("width", "".concat(e2)), i2.setAttribute("height", "".concat(s2)), i2.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(t3, e2) {
    const { el: s2, ctx: i2 } = this.lower;
    Nt(s2, i2, t3, e2);
  }
  setCSSDimensions(t3) {
    qt(this.lower.el, t3);
  }
  calcOffset() {
    return function(t3) {
      var e2;
      let s2 = { left: 0, top: 0 };
      const i2 = t3 && Ht(t3), r2 = { left: 0, top: 0 }, n2 = { borderLeftWidth: P, borderTopWidth: E, paddingLeft: P, paddingTop: E };
      if (!i2)
        return r2;
      const o2 = (null === (e2 = Gt(t3)) || void 0 === e2 ? void 0 : e2.getComputedStyle(t3, null)) || {};
      for (const t4 in n2)
        r2[n2[t4]] += parseInt(o2[t4], 10) || 0;
      const a2 = i2.documentElement;
      void 0 !== t3.getBoundingClientRect && (s2 = t3.getBoundingClientRect());
      const h2 = zt(t3);
      return { left: s2.left + h2.left - (a2.clientLeft || 0) + r2.left, top: s2.top + h2.top - (a2.clientTop || 0) + r2.top };
    }(this.lower.el);
  }
  dispose() {
    m().dispose(this.lower.el), delete this.lower;
  }
};
var Zt = { backgroundVpt: true, backgroundColor: "", overlayVpt: true, overlayColor: "", includeDefaultValues: true, svgViewportTransformation: true, renderOnAddRemove: true, skipOffscreen: true, enableRetinaScaling: true, imageSmoothingEnabled: true, controlsAboveOverlay: false, allowTouchScrolling: false, viewportTransform: [...O] };
var Qt = class _Qt extends K(J) {
  get lowerCanvasEl() {
    var t3;
    return null === (t3 = this.elements.lower) || void 0 === t3 ? void 0 : t3.el;
  }
  get contextContainer() {
    var t3;
    return null === (t3 = this.elements.lower) || void 0 === t3 ? void 0 : t3.ctx;
  }
  static getDefaults() {
    return _Qt.ownDefaults;
  }
  constructor(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(e2), this.initElements(t3), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = false, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(t3) {
    this.elements = new Jt(t3);
  }
  add() {
    const t3 = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t3;
  }
  insertAt(t3) {
    for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), i2 = 1; i2 < e2; i2++)
      s2[i2 - 1] = arguments[i2];
    const r2 = super.insertAt(t3, ...s2);
    return s2.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), r2;
  }
  remove() {
    const t3 = super.remove(...arguments);
    return t3.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t3;
  }
  _onObjectAdded(t3) {
    t3.canvas && t3.canvas !== this && (h("warn", "Canvas is trying to add an object that belongs to a different canvas.\nResulting to default behavior: removing object from previous canvas and adding to new canvas"), t3.canvas.remove(t3)), t3._set("canvas", this), t3.setCoords(), this.fire("object:added", { target: t3 }), t3.fire("added", { target: this });
  }
  _onObjectRemoved(t3) {
    t3._set("canvas", void 0), this.fire("object:removed", { target: t3 }), t3.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? _() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(t3, e2) {
    return this.setDimensions({ width: t3 }, e2);
  }
  setHeight(t3, e2) {
    return this.setDimensions({ height: t3 }, e2);
  }
  _setDimensionsImpl(t3) {
    let { cssOnly: s2 = false, backstoreOnly: i2 = false } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!s2) {
      const s3 = e({ width: this.width, height: this.height }, t3);
      this.elements.setDimensions(s3, this.getRetinaScaling()), this.hasLostContext = true, this.width = s3.width, this.height = s3.height;
    }
    i2 || this.elements.setCSSDimensions(t3), this.calcOffset();
  }
  setDimensions(t3, e2) {
    this._setDimensionsImpl(t3, e2), e2 && e2.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(t3) {
    const e2 = this.backgroundImage, s2 = this.overlayImage, i2 = this._objects.length;
    this.viewportTransform = t3;
    for (let t4 = 0; t4 < i2; t4++) {
      const e3 = this._objects[t4];
      e3.group || e3.setCoords();
    }
    e2 && e2.setCoords(), s2 && s2.setCoords(), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(t3, e2) {
    const s2 = t3, i2 = [...this.viewportTransform], r2 = at(t3, ht(i2));
    i2[0] = e2, i2[3] = e2;
    const n2 = at(r2, i2);
    i2[4] += s2.x - n2.x, i2[5] += s2.y - n2.y, this.setViewportTransform(i2);
  }
  setZoom(t3) {
    this.zoomToPoint(new U(0, 0), t3);
  }
  absolutePan(t3) {
    const e2 = [...this.viewportTransform];
    return e2[4] = -t3.x, e2[5] = -t3.y, this.setViewportTransform(e2);
  }
  relativePan(t3) {
    return this.absolutePan(new U(-t3.x - this.viewportTransform[4], -t3.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(t3) {
    t3.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = Z(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const t3 = this.width, e2 = this.height, s2 = ht(this.viewportTransform), i2 = at({ x: 0, y: 0 }, s2), r2 = at({ x: t3, y: e2 }, s2), n2 = i2.min(r2), o2 = i2.max(r2);
    return this.vptCoords = { tl: n2, tr: new U(o2.x, n2.y), bl: new U(n2.x, o2.y), br: o2 };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (Q(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(t3) {
  }
  renderCanvas(t3, e2) {
    if (this.destroyed)
      return;
    const s2 = this.viewportTransform, i2 = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(t3), t3.imageSmoothingEnabled = this.imageSmoothingEnabled, t3.patternQuality = "best", this.fire("before:render", { ctx: t3 }), this._renderBackground(t3), t3.save(), t3.transform(s2[0], s2[1], s2[2], s2[3], s2[4], s2[5]), this._renderObjects(t3, e2), t3.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(t3), i2 && (i2._set("canvas", this), i2.shouldCache(), i2._transformDone = true, i2.renderCache({ forClipping: true }), this.drawClipPathOnCanvas(t3, i2)), this._renderOverlay(t3), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(t3), this.fire("after:render", { ctx: t3 }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(t3, e2) {
    const s2 = this.viewportTransform;
    t3.save(), t3.transform(...s2), t3.globalCompositeOperation = "destination-in", e2.transform(t3), t3.scale(1 / e2.zoomX, 1 / e2.zoomY), t3.drawImage(e2._cacheCanvas, -e2.cacheTranslationX, -e2.cacheTranslationY), t3.restore();
  }
  _renderObjects(t3, e2) {
    for (let s2 = 0, i2 = e2.length; s2 < i2; ++s2)
      e2[s2] && e2[s2].render(t3);
  }
  _renderBackgroundOrOverlay(t3, e2) {
    const s2 = this["".concat(e2, "Color")], i2 = this["".concat(e2, "Image")], r2 = this.viewportTransform, n2 = this["".concat(e2, "Vpt")];
    if (!s2 && !i2)
      return;
    const o2 = It(s2);
    if (s2) {
      if (t3.save(), t3.beginPath(), t3.moveTo(0, 0), t3.lineTo(this.width, 0), t3.lineTo(this.width, this.height), t3.lineTo(0, this.height), t3.closePath(), t3.fillStyle = o2 ? s2.toLive(t3) : s2, n2 && t3.transform(...r2), o2) {
        t3.transform(1, 0, 0, 1, s2.offsetX || 0, s2.offsetY || 0);
        const e3 = s2.gradientTransform || s2.patternTransform;
        e3 && t3.transform(...e3);
      }
      t3.fill(), t3.restore();
    }
    if (i2) {
      t3.save();
      const { skipOffscreen: e3 } = this;
      this.skipOffscreen = n2, n2 && t3.transform(...r2), i2.render(t3), this.skipOffscreen = e3, t3.restore();
    }
  }
  _renderBackground(t3) {
    this._renderBackgroundOrOverlay(t3, "background");
  }
  _renderOverlay(t3) {
    this._renderBackgroundOrOverlay(t3, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new U(this.width / 2, this.height / 2);
  }
  centerObjectH(t3) {
    return this._centerObject(t3, new U(this.getCenterPoint().x, t3.getCenterPoint().y));
  }
  centerObjectV(t3) {
    return this._centerObject(t3, new U(t3.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(t3) {
    return this._centerObject(t3, this.getCenterPoint());
  }
  viewportCenterObject(t3) {
    return this._centerObject(t3, this.getVpCenter());
  }
  viewportCenterObjectH(t3) {
    return this._centerObject(t3, new U(this.getVpCenter().x, t3.getCenterPoint().y));
  }
  viewportCenterObjectV(t3) {
    return this._centerObject(t3, new U(t3.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return at(this.getCenterPoint(), ht(this.viewportTransform));
  }
  _centerObject(t3, e2) {
    t3.setXY(e2, M, M), t3.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(t3) {
    return this.toDatalessObject(t3);
  }
  toObject(t3) {
    return this._toObjectMethod("toObject", t3);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(t3) {
    return this._toObjectMethod("toDatalessObject", t3);
  }
  _toObjectMethod(t3, s2) {
    const i2 = this.clipPath, r2 = i2 && !i2.excludeFromExport ? this._toObject(i2, t3, s2) : null;
    return e(e(e({ version: C }, St(this, s2)), {}, { objects: this._objects.filter((t4) => !t4.excludeFromExport).map((e2) => this._toObject(e2, t3, s2)) }, this.__serializeBgOverlay(t3, s2)), r2 ? { clipPath: r2 } : null);
  }
  _toObject(t3, e2, s2) {
    let i2;
    this.includeDefaultValues || (i2 = t3.includeDefaultValues, t3.includeDefaultValues = false);
    const r2 = t3[e2](s2);
    return this.includeDefaultValues || (t3.includeDefaultValues = !!i2), r2;
  }
  __serializeBgOverlay(t3, e2) {
    const s2 = {}, i2 = this.backgroundImage, r2 = this.overlayImage, n2 = this.backgroundColor, o2 = this.overlayColor;
    return It(n2) ? n2.excludeFromExport || (s2.background = n2.toObject(e2)) : n2 && (s2.background = n2), It(o2) ? o2.excludeFromExport || (s2.overlay = o2.toObject(e2)) : o2 && (s2.overlay = o2), i2 && !i2.excludeFromExport && (s2.backgroundImage = this._toObject(i2, t3, e2)), r2 && !r2.excludeFromExport && (s2.overlayImage = this._toObject(r2, t3, e2)), s2;
  }
  toSVG() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 ? arguments[1] : void 0;
    t3.reviver = e2;
    const s2 = [];
    return this._setSVGPreamble(s2, t3), this._setSVGHeader(s2, t3), this.clipPath && s2.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, ')" >\n')), this._setSVGBgOverlayColor(s2, "background"), this._setSVGBgOverlayImage(s2, "backgroundImage", e2), this._setSVGObjects(s2, e2), this.clipPath && s2.push("</g>\n"), this._setSVGBgOverlayColor(s2, "overlay"), this._setSVGBgOverlayImage(s2, "overlayImage", e2), s2.push("</svg>"), s2.join("");
  }
  _setSVGPreamble(t3, e2) {
    e2.suppressPreamble || t3.push('<?xml version="1.0" encoding="', e2.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n');
  }
  _setSVGHeader(t3, e2) {
    const s2 = e2.width || "".concat(this.width), i2 = e2.height || "".concat(this.height), r2 = a.NUM_FRACTION_DIGITS, n2 = e2.viewBox;
    let o2;
    if (n2)
      o2 = 'viewBox="'.concat(n2.x, " ").concat(n2.y, " ").concat(n2.width, " ").concat(n2.height, '" ');
    else if (this.svgViewportTransformation) {
      const t4 = this.viewportTransform;
      o2 = 'viewBox="'.concat(jt(-t4[4] / t4[0], r2), " ").concat(jt(-t4[5] / t4[3], r2), " ").concat(jt(this.width / t4[0], r2), " ").concat(jt(this.height / t4[3], r2), '" ');
    } else
      o2 = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    t3.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', s2, '" ', 'height="', i2, '" ', o2, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", C, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e2), "</defs>\n");
  }
  createSVGClipPathMarkup(t3) {
    const e2 = this.clipPath;
    return e2 ? (e2.clipPathId = "CLIPPATH_".concat(tt()), '<clipPath id="'.concat(e2.clipPathId, '" >\n').concat(e2.toClipPathSVG(t3.reviver), "</clipPath>\n")) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((t3) => {
      const e2 = this["".concat(t3, "Color")];
      if (It(e2)) {
        const s2 = this["".concat(t3, "Vpt")], i2 = this.viewportTransform, r2 = { isType: () => false, width: this.width / (s2 ? i2[0] : 1), height: this.height / (s2 ? i2[3] : 1) };
        return e2.toSVG(r2, { additionalTransform: s2 ? Rt(i2) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const t3 = [], e2 = {}, s2 = a.fontPaths;
    this._objects.forEach(function e3(s3) {
      t3.push(s3), q(s3) && s3._objects.forEach(e3);
    }), t3.forEach((t4) => {
      if (!Wt(t4))
        return;
      const { styles: i3, fontFamily: r2 } = t4;
      !e2[r2] && s2[r2] && (e2[r2] = true, i3 && Object.values(i3).forEach((t5) => {
        Object.values(t5).forEach((t6) => {
          let { fontFamily: i4 = "" } = t6;
          !e2[i4] && s2[i4] && (e2[i4] = true);
        });
      }));
    });
    const i2 = Object.keys(e2).map((t4) => "		@font-face {\n			font-family: '".concat(t4, "';\n			src: url('").concat(s2[t4], "');\n		}\n")).join("");
    return i2 ? '	<style type="text/css"><![CDATA[\n'.concat(i2, "]]></style>\n") : "";
  }
  _setSVGObjects(t3, e2) {
    this.forEachObject((s2) => {
      s2.excludeFromExport || this._setSVGObject(t3, s2, e2);
    });
  }
  _setSVGObject(t3, e2, s2) {
    t3.push(e2.toSVG(s2));
  }
  _setSVGBgOverlayImage(t3, e2, s2) {
    const i2 = this[e2];
    i2 && !i2.excludeFromExport && i2.toSVG && t3.push(i2.toSVG(s2));
  }
  _setSVGBgOverlayColor(t3, e2) {
    const s2 = this["".concat(e2, "Color")];
    if (s2)
      if (It(s2)) {
        const i2 = s2.repeat || "", r2 = this.width, n2 = this.height, o2 = this["".concat(e2, "Vpt")] ? Rt(ht(this.viewportTransform)) : "";
        t3.push('<rect transform="'.concat(o2, " translate(").concat(r2 / 2, ",").concat(n2 / 2, ')" x="').concat(s2.offsetX - r2 / 2, '" y="').concat(s2.offsetY - n2 / 2, '" width="').concat("repeat-y" !== i2 && "no-repeat" !== i2 || !Yt(s2) ? r2 : s2.source.width, '" height="').concat("repeat-x" !== i2 && "no-repeat" !== i2 || !Yt(s2) ? n2 : s2.source.height, '" fill="url(#SVGID_').concat(s2.id, ')"></rect>\n'));
      } else
        t3.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', s2, '"', "></rect>\n");
  }
  loadFromJSON(t3, e2) {
    let { signal: s2 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!t3)
      return Promise.reject(new c("`json` is undefined"));
    const i2 = "string" == typeof t3 ? JSON.parse(t3) : t3, { objects: r2 = [], backgroundImage: n2, background: o2, overlayImage: a2, overlay: h2, clipPath: l2 } = i2, u2 = this.renderOnAddRemove;
    return this.renderOnAddRemove = false, Promise.all([bt(r2, { reviver: e2, signal: s2 }), wt({ backgroundImage: n2, backgroundColor: o2, overlayImage: a2, overlayColor: h2, clipPath: l2 }, { signal: s2 })]).then((t4) => {
      let [e3, s3] = t4;
      return this.clear(), this.add(...e3), this.set(i2), this.set(s3), this.renderOnAddRemove = u2, this;
    });
  }
  clone(t3) {
    const e2 = this.toObject(t3);
    return this.cloneWithoutData().loadFromJSON(e2);
  }
  cloneWithoutData() {
    const t3 = et();
    return t3.width = this.width, t3.height = this.height, new this.constructor(t3);
  }
  toDataURL() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const { format: e2 = "png", quality: s2 = 1, multiplier: i2 = 1, enableRetinaScaling: r2 = false } = t3, n2 = i2 * (r2 ? this.getRetinaScaling() : 1);
    return it(this.toCanvasElement(n2, t3), e2, s2);
  }
  toCanvasElement() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, { width: e2, height: s2, left: i2, top: r2, filter: n2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const o2 = (e2 || this.width) * t3, a2 = (s2 || this.height) * t3, h2 = this.getZoom(), c2 = this.width, l2 = this.height, u2 = this.skipControlsDrawing, d2 = h2 * t3, g2 = this.viewportTransform, f2 = [d2, 0, 0, d2, (g2[4] - (i2 || 0)) * t3, (g2[5] - (r2 || 0)) * t3], p2 = this.enableRetinaScaling, m2 = et(), v2 = n2 ? this._objects.filter((t4) => n2(t4)) : this._objects;
    return m2.width = o2, m2.height = a2, this.enableRetinaScaling = false, this.viewportTransform = f2, this.width = o2, this.height = a2, this.skipControlsDrawing = true, this.calcViewportBoundaries(), this.renderCanvas(m2.getContext("2d"), v2), this.viewportTransform = g2, this.width = c2, this.height = l2, this.calcViewportBoundaries(), this.enableRetinaScaling = p2, this.skipControlsDrawing = u2, m2;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), X.cancelByCanvas(this), this.disposed = true, new Promise((t3, e2) => {
      const s2 = () => {
        this.destroy(), t3(true);
      };
      s2.kill = e2, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? t3(false) : this.nextRenderHandle ? this.__cleanupTask = s2 : s2();
    });
  }
  destroy() {
    this.destroyed = true, this.cancelRequestedRender(), this.forEachObject((t3) => t3.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
};
s(Qt, "ownDefaults", Zt);
var $t = ["touchstart", "touchmove", "touchend"];
var te = (t3) => {
  const e2 = zt(t3.target), s2 = function(t4) {
    const e3 = t4.changedTouches;
    return e3 && e3[0] ? e3[0] : t4;
  }(t3);
  return new U(s2.clientX + e2.left, s2.clientY + e2.top);
};
var ee = (t3) => $t.includes(t3.type) || "touch" === t3.pointerType;
var se = (t3) => {
  t3.preventDefault(), t3.stopPropagation();
};
var ie = (t3) => {
  if (0 === t3.length)
    return { left: 0, top: 0, width: 0, height: 0 };
  const { min: e2, max: s2 } = t3.reduce((t4, e3) => {
    let { min: s3, max: i3 } = t4;
    return { min: s3.min(e3), max: i3.max(e3) };
  }, { min: new U(t3[0]), max: new U(t3[0]) }), i2 = s2.subtract(e2);
  return { left: e2.x, top: e2.y, width: i2.x, height: i2.y };
};
var re = ["translateX", "translateY", "scaleX", "scaleY"];
var ne = (t3, e2) => oe(t3, ct(e2, t3.calcOwnMatrix()));
var oe = (t3, e2) => {
  const s2 = dt(e2), { translateX: r2, translateY: n2, scaleX: o2, scaleY: a2 } = s2, h2 = i(s2, re), c2 = new U(r2, n2);
  t3.flipX = false, t3.flipY = false, Object.assign(t3, h2), t3.set({ scaleX: o2, scaleY: a2 }), t3.setPositionByOrigin(c2, M, M);
};
var ae = (t3) => {
  t3.scaleX = 1, t3.scaleY = 1, t3.skewX = 0, t3.skewY = 0, t3.flipX = false, t3.flipY = false, t3.rotate(0);
};
var he = (t3) => ({ scaleX: t3.scaleX, scaleY: t3.scaleY, skewX: t3.skewX, skewY: t3.skewY, angle: t3.angle, left: t3.left, flipX: t3.flipX, flipY: t3.flipY, top: t3.top });
var ce = (t3, e2, s2) => {
  const i2 = t3 / 2, r2 = e2 / 2, n2 = [new U(-i2, -r2), new U(i2, -r2), new U(-i2, r2), new U(i2, r2)].map((t4) => t4.transform(s2)), o2 = ie(n2);
  return new U(o2.width, o2.height);
};
var le = function() {
  let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : O;
  return ct(ht(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O), t3);
};
var ue = function(t3) {
  let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : O;
  return t3.transform(le(e2, s2));
};
var de = function(t3) {
  let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : O;
  return t3.transform(le(e2, s2), true);
};
var ge = (t3, e2, s2) => {
  const i2 = le(e2, s2);
  return oe(t3, ct(i2, t3.calcOwnMatrix())), i2;
};
var fe = (t3, s2) => {
  var i2;
  const { transform: { target: r2 } } = s2;
  null === (i2 = r2.canvas) || void 0 === i2 || i2.fire("object:".concat(t3), e(e({}, s2), {}, { target: r2 })), r2.fire(t3, s2);
};
var pe = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 };
var me = (t3) => "string" == typeof t3 ? pe[t3] : t3 - 0.5;
var ve = "not-allowed";
function ye(t3) {
  return t3.originX === M && t3.originY === M;
}
function _e(t3) {
  return 0.5 - me(t3);
}
var xe = (t3, e2) => t3[e2];
var Ce = (t3, e2, s2, i2) => ({ e: t3, transform: e2, pointer: new U(s2, i2) });
function be(t3, e2) {
  const s2 = t3.getTotalAngle() + nt(Math.atan2(e2.y, e2.x)) + 360;
  return Math.round(s2 % 360 / 45);
}
function we(t3, e2, s2, i2, r2) {
  var n2;
  let { target: o2, corner: a2 } = t3;
  const h2 = o2.controls[a2], c2 = (null === (n2 = o2.canvas) || void 0 === n2 ? void 0 : n2.getZoom()) || 1, l2 = o2.padding / c2, u2 = function(t4, e3, s3, i3) {
    const r3 = t4.getRelativeCenterPoint(), n3 = void 0 !== s3 && void 0 !== i3 ? t4.translateToGivenOrigin(r3, M, M, s3, i3) : new U(t4.left, t4.top);
    return (t4.angle ? e3.rotate(-rt(t4.angle), r3) : e3).subtract(n3);
  }(o2, new U(i2, r2), e2, s2);
  return u2.x >= l2 && (u2.x -= l2), u2.x <= -l2 && (u2.x += l2), u2.y >= l2 && (u2.y -= l2), u2.y <= l2 && (u2.y += l2), u2.x -= h2.offsetX, u2.y -= h2.offsetY, u2;
}
var Se = (t3, e2, s2, i2) => {
  const { target: r2, offsetX: n2, offsetY: o2 } = e2, a2 = s2 - n2, h2 = i2 - o2, c2 = !xe(r2, "lockMovementX") && r2.left !== a2, l2 = !xe(r2, "lockMovementY") && r2.top !== h2;
  return c2 && r2.set(P, a2), l2 && r2.set(E, h2), (c2 || l2) && fe("moving", Ce(t3, e2, s2, i2)), c2 || l2;
};
var Te = class {
  getSvgStyles(t3) {
    const e2 = this.fillRule ? this.fillRule : "nonzero", s2 = this.strokeWidth ? this.strokeWidth : "0", i2 = this.strokeDashArray ? this.strokeDashArray.join(" ") : F, r2 = this.strokeDashOffset ? this.strokeDashOffset : "0", n2 = this.strokeLineCap ? this.strokeLineCap : "butt", o2 = this.strokeLineJoin ? this.strokeLineJoin : "miter", a2 = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h2 = void 0 !== this.opacity ? this.opacity : "1", c2 = this.visible ? "" : " visibility: hidden;", l2 = t3 ? "" : this.getSvgFilter(), u2 = Bt("fill", this.fill);
    return [Bt("stroke", this.stroke), "stroke-width: ", s2, "; ", "stroke-dasharray: ", i2, "; ", "stroke-linecap: ", n2, "; ", "stroke-dashoffset: ", r2, "; ", "stroke-linejoin: ", o2, "; ", "stroke-miterlimit: ", a2, "; ", u2, "fill-rule: ", e2, "; ", "opacity: ", h2, ";", l2, c2].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    const s2 = t3 ? this.calcTransformMatrix() : this.calcOwnMatrix(), i2 = 'transform="'.concat(Rt(s2));
    return "".concat(i2).concat(e2, '" ');
  }
  _toSVG(t3) {
    return [""];
  }
  toSVG(t3) {
    return this._createBaseSVGMarkup(this._toSVG(t3), { reviver: t3 });
  }
  toClipPathSVG(t3) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(t3), { reviver: t3 });
  }
  _createBaseClipPathSVGMarkup(t3) {
    let { reviver: e2, additionalTransform: s2 = "" } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const i2 = [this.getSvgTransform(true, s2), this.getSvgCommons()].join(""), r2 = t3.indexOf("COMMON_PARTS");
    return t3[r2] = i2, e2 ? e2(t3.join("")) : t3.join("");
  }
  _createBaseSVGMarkup(t3) {
    let { noStyle: e2, reviver: s2, withShadow: i2, additionalTransform: r2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const n2 = e2 ? "" : 'style="'.concat(this.getSvgStyles(), '" '), o2 = i2 ? 'style="'.concat(this.getSvgFilter(), '" ') : "", a2 = this.clipPath, h2 = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", c2 = a2 && a2.absolutePositioned, l2 = this.stroke, u2 = this.fill, d2 = this.shadow, g2 = [], f2 = t3.indexOf("COMMON_PARTS");
    let p2;
    a2 && (a2.clipPathId = "CLIPPATH_".concat(tt()), p2 = '<clipPath id="'.concat(a2.clipPathId, '" >\n').concat(a2.toClipPathSVG(s2), "</clipPath>\n")), c2 && g2.push("<g ", o2, this.getSvgCommons(), " >\n"), g2.push("<g ", this.getSvgTransform(false), c2 ? "" : o2 + this.getSvgCommons(), " >\n");
    const m2 = [n2, h2, e2 ? "" : this.addPaintOrder(), " ", r2 ? 'transform="'.concat(r2, '" ') : ""].join("");
    return t3[f2] = m2, It(u2) && g2.push(u2.toSVG(this)), It(l2) && g2.push(l2.toSVG(this)), d2 && g2.push(d2.toSVG(this)), a2 && g2.push(p2), g2.push(t3.join("")), g2.push("</g>\n"), c2 && g2.push("</g>\n"), s2 ? s2(g2.join("")) : g2.join("");
  }
  addPaintOrder() {
    return "fill" !== this.paintFirst ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
};
var Oe = (t3, e2, s2, i2) => (t3 < Math.abs(e2) ? (t3 = e2, i2 = s2 / 4) : i2 = 0 === e2 && 0 === t3 ? s2 / S * Math.asin(1) : s2 / S * Math.asin(e2 / t3), { a: t3, c: e2, p: s2, s: i2 });
var ke = (t3, e2, s2, i2, r2) => t3 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * r2 - e2) * S / s2);
var De = (t3, e2, s2, i2) => -s2 * Math.cos(t3 / i2 * w) + s2 + e2;
var Me = (t3, e2, s2, i2) => (t3 /= i2) < 1 / 2.75 ? s2 * (7.5625 * t3 * t3) + e2 : t3 < 2 / 2.75 ? s2 * (7.5625 * (t3 -= 1.5 / 2.75) * t3 + 0.75) + e2 : t3 < 2.5 / 2.75 ? s2 * (7.5625 * (t3 -= 2.25 / 2.75) * t3 + 0.9375) + e2 : s2 * (7.5625 * (t3 -= 2.625 / 2.75) * t3 + 0.984375) + e2;
var Pe = (t3, e2, s2, i2) => s2 - Me(i2 - t3, 0, s2, i2) + e2;
var Ee = Object.freeze({ __proto__: null, defaultEasing: De, easeInBack: function(t3, e2, s2, i2) {
  let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1.70158;
  return s2 * (t3 /= i2) * t3 * ((r2 + 1) * t3 - r2) + e2;
}, easeInBounce: Pe, easeInCirc: (t3, e2, s2, i2) => -s2 * (Math.sqrt(1 - (t3 /= i2) * t3) - 1) + e2, easeInCubic: (t3, e2, s2, i2) => s2 * (t3 / i2) ** 3 + e2, easeInElastic: (t3, e2, s2, i2) => {
  const r2 = s2;
  let n2 = 0;
  if (0 === t3)
    return e2;
  if (1 === (t3 /= i2))
    return e2 + s2;
  n2 || (n2 = 0.3 * i2);
  const { a: o2, s: a2, p: h2 } = Oe(r2, s2, n2, 1.70158);
  return -ke(o2, a2, h2, t3, i2) + e2;
}, easeInExpo: (t3, e2, s2, i2) => 0 === t3 ? e2 : s2 * 2 ** (10 * (t3 / i2 - 1)) + e2, easeInOutBack: function(t3, e2, s2, i2) {
  let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1.70158;
  return (t3 /= i2 / 2) < 1 ? s2 / 2 * (t3 * t3 * ((1 + (r2 *= 1.525)) * t3 - r2)) + e2 : s2 / 2 * ((t3 -= 2) * t3 * ((1 + (r2 *= 1.525)) * t3 + r2) + 2) + e2;
}, easeInOutBounce: (t3, e2, s2, i2) => t3 < i2 / 2 ? 0.5 * Pe(2 * t3, 0, s2, i2) + e2 : 0.5 * Me(2 * t3 - i2, 0, s2, i2) + 0.5 * s2 + e2, easeInOutCirc: (t3, e2, s2, i2) => (t3 /= i2 / 2) < 1 ? -s2 / 2 * (Math.sqrt(1 - t3 ** 2) - 1) + e2 : s2 / 2 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1) + e2, easeInOutCubic: (t3, e2, s2, i2) => (t3 /= i2 / 2) < 1 ? s2 / 2 * t3 ** 3 + e2 : s2 / 2 * ((t3 - 2) ** 3 + 2) + e2, easeInOutElastic: (t3, e2, s2, i2) => {
  const r2 = s2;
  let n2 = 0;
  if (0 === t3)
    return e2;
  if (2 === (t3 /= i2 / 2))
    return e2 + s2;
  n2 || (n2 = i2 * (0.3 * 1.5));
  const { a: o2, s: a2, p: h2, c: c2 } = Oe(r2, s2, n2, 1.70158);
  return t3 < 1 ? -0.5 * ke(o2, a2, h2, t3, i2) + e2 : o2 * Math.pow(2, -10 * (t3 -= 1)) * Math.sin((t3 * i2 - a2) * S / h2) * 0.5 + c2 + e2;
}, easeInOutExpo: (t3, e2, s2, i2) => 0 === t3 ? e2 : t3 === i2 ? e2 + s2 : (t3 /= i2 / 2) < 1 ? s2 / 2 * 2 ** (10 * (t3 - 1)) + e2 : s2 / 2 * -(2 ** (-10 * --t3) + 2) + e2, easeInOutQuad: (t3, e2, s2, i2) => (t3 /= i2 / 2) < 1 ? s2 / 2 * t3 ** 2 + e2 : -s2 / 2 * (--t3 * (t3 - 2) - 1) + e2, easeInOutQuart: (t3, e2, s2, i2) => (t3 /= i2 / 2) < 1 ? s2 / 2 * t3 ** 4 + e2 : -s2 / 2 * ((t3 -= 2) * t3 ** 3 - 2) + e2, easeInOutQuint: (t3, e2, s2, i2) => (t3 /= i2 / 2) < 1 ? s2 / 2 * t3 ** 5 + e2 : s2 / 2 * ((t3 - 2) ** 5 + 2) + e2, easeInOutSine: (t3, e2, s2, i2) => -s2 / 2 * (Math.cos(Math.PI * t3 / i2) - 1) + e2, easeInQuad: (t3, e2, s2, i2) => s2 * (t3 /= i2) * t3 + e2, easeInQuart: (t3, e2, s2, i2) => s2 * (t3 /= i2) * t3 ** 3 + e2, easeInQuint: (t3, e2, s2, i2) => s2 * (t3 / i2) ** 5 + e2, easeInSine: (t3, e2, s2, i2) => -s2 * Math.cos(t3 / i2 * w) + s2 + e2, easeOutBack: function(t3, e2, s2, i2) {
  let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1.70158;
  return s2 * ((t3 = t3 / i2 - 1) * t3 * ((r2 + 1) * t3 + r2) + 1) + e2;
}, easeOutBounce: Me, easeOutCirc: (t3, e2, s2, i2) => s2 * Math.sqrt(1 - (t3 = t3 / i2 - 1) * t3) + e2, easeOutCubic: (t3, e2, s2, i2) => s2 * ((t3 / i2 - 1) ** 3 + 1) + e2, easeOutElastic: (t3, e2, s2, i2) => {
  const r2 = s2;
  let n2 = 0;
  if (0 === t3)
    return e2;
  if (1 === (t3 /= i2))
    return e2 + s2;
  n2 || (n2 = 0.3 * i2);
  const { a: o2, s: a2, p: h2, c: c2 } = Oe(r2, s2, n2, 1.70158);
  return o2 * 2 ** (-10 * t3) * Math.sin((t3 * i2 - a2) * S / h2) + c2 + e2;
}, easeOutExpo: (t3, e2, s2, i2) => t3 === i2 ? e2 + s2 : s2 * -(2 ** (-10 * t3 / i2) + 1) + e2, easeOutQuad: (t3, e2, s2, i2) => -s2 * (t3 /= i2) * (t3 - 2) + e2, easeOutQuart: (t3, e2, s2, i2) => -s2 * ((t3 = t3 / i2 - 1) * t3 ** 3 - 1) + e2, easeOutQuint: (t3, e2, s2, i2) => s2 * ((t3 / i2 - 1) ** 5 + 1) + e2, easeOutSine: (t3, e2, s2, i2) => s2 * Math.sin(t3 / i2 * w) + e2 });
var Ae = () => false;
var je = class {
  constructor(t3) {
    let { startValue: e2, byValue: i2, duration: r2 = 500, delay: n2 = 0, easing: o2 = De, onStart: a2 = b, onChange: h2 = b, onComplete: c2 = b, abort: l2 = Ae, target: u2 } = t3;
    s(this, "_state", "pending"), s(this, "durationProgress", 0), s(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = r2, this.delay = n2, this.easing = o2, this._onStart = a2, this._onChange = h2, this._onComplete = c2, this._abort = l2, this.target = u2, this.startValue = e2, this.byValue = i2, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return "aborted" === this._state || "completed" === this._state;
  }
  start() {
    const t3 = (t4) => {
      "pending" === this._state && (this.startTime = t4 || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => Z(t3), this.delay) : Z(t3);
  }
  tick(t3) {
    const e2 = (t3 || +/* @__PURE__ */ new Date()) - this.startTime, s2 = Math.min(e2, this.duration);
    this.durationProgress = s2 / this.duration;
    const { value: i2, valueProgress: r2 } = this.calculate(s2);
    this.value = Object.freeze(i2), this.valueProgress = r2, "aborted" !== this._state && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : e2 >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), Z(this.tick)));
  }
  register() {
    X.push(this);
  }
  unregister() {
    X.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
};
var Fe = ["startValue", "endValue"];
var Le = class extends je {
  constructor(t3) {
    let { startValue: s2 = 0, endValue: r2 = 100 } = t3;
    super(e(e({}, i(t3, Fe)), {}, { startValue: s2, byValue: r2 - s2 }));
  }
  calculate(t3) {
    const e2 = this.easing(t3, this.startValue, this.byValue, this.duration);
    return { value: e2, valueProgress: Math.abs((e2 - this.startValue) / this.byValue) };
  }
};
var Re = ["startValue", "endValue"];
var Be = class extends je {
  constructor(t3) {
    let { startValue: s2 = [0], endValue: r2 = [100] } = t3;
    super(e(e({}, i(t3, Re)), {}, { startValue: s2, byValue: r2.map((t4, e2) => t4 - s2[e2]) }));
  }
  calculate(t3) {
    const e2 = this.startValue.map((e3, s2) => this.easing(t3, e3, this.byValue[s2], this.duration, s2));
    return { value: e2, valueProgress: Math.abs((e2[0] - this.startValue[0]) / this.byValue[0]) };
  }
};
var Ie = (t3, e2, s2) => Math.max(t3, Math.min(e2, s2));
var Xe = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"];
var Ye = (t3, e2, s2, i2) => e2 + s2 * (1 - Math.cos(t3 / i2 * w));
var We = (t3) => t3 && ((e2, s2, i2) => t3(new At(e2).toRgba(), s2, i2));
var Ve = class extends je {
  constructor(t3) {
    let { startValue: s2, endValue: r2, easing: n2 = Ye, onChange: o2, onComplete: a2, abort: h2 } = t3, c2 = i(t3, Xe);
    const l2 = new At(s2).getSource(), u2 = new At(r2).getSource();
    super(e(e({}, c2), {}, { startValue: l2, byValue: u2.map((t4, e2) => t4 - l2[e2]), easing: n2, onChange: We(o2), onComplete: We(a2), abort: We(h2) }));
  }
  calculate(t3) {
    const [e2, s2, i2, r2] = this.startValue.map((e3, s3) => this.easing(t3, e3, this.byValue[s3], this.duration, s3)), n2 = [...[e2, s2, i2].map(Math.round), Ie(0, r2, 1)];
    return { value: n2, valueProgress: n2.map((t4, e3) => 0 !== this.byValue[e3] ? Math.abs((t4 - this.startValue[e3]) / this.byValue[e3]) : 0).find((t4) => 0 !== t4) || 0 };
  }
};
function ze(t3) {
  const e2 = ((t4) => Array.isArray(t4.startValue) || Array.isArray(t4.endValue))(t3) ? new Be(t3) : new Le(t3);
  return e2.start(), e2;
}
function He(t3) {
  const e2 = new Ve(t3);
  return e2.start(), e2;
}
var Ge = new U(1, 0);
var Ue = new U();
var Ne = (t3, e2) => t3.rotate(e2);
var qe = (t3, e2) => new U(e2).subtract(t3);
var Ke = (t3) => t3.distanceFrom(Ue);
var Je = (t3, e2) => Math.atan2(ts(t3, e2), es(t3, e2));
var Ze = (t3) => Je(Ge, t3);
var Qe = (t3) => t3.eq(Ue) ? t3 : t3.scalarDivide(Ke(t3));
var $e = function(t3) {
  let e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  return Qe(new U(-t3.y, t3.x).scalarMultiply(e2 ? 1 : -1));
};
var ts = (t3, e2) => t3.x * e2.y - t3.y * e2.x;
var es = (t3, e2) => t3.x * e2.x + t3.y * e2.y;
var ss = (t3, e2, s2) => {
  if (t3.eq(e2) || t3.eq(s2))
    return true;
  const i2 = ts(e2, s2), r2 = ts(e2, t3), n2 = ts(s2, t3);
  return i2 >= 0 ? r2 >= 0 && n2 <= 0 : !(r2 <= 0 && n2 >= 0);
};
var is = class _is {
  constructor(t3) {
    this.status = t3, this.points = [];
  }
  includes(t3) {
    return this.points.some((e2) => e2.eq(t3));
  }
  append() {
    for (var t3 = arguments.length, e2 = new Array(t3), s2 = 0; s2 < t3; s2++)
      e2[s2] = arguments[s2];
    return this.points = this.points.concat(e2.filter((t4) => !this.includes(t4))), this;
  }
  static isPointContained(t3, e2, s2) {
    let i2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    if (e2.eq(s2))
      return t3.eq(e2);
    if (e2.x === s2.x)
      return t3.x === e2.x && (i2 || t3.y >= Math.min(e2.y, s2.y) && t3.y <= Math.max(e2.y, s2.y));
    if (e2.y === s2.y)
      return t3.y === e2.y && (i2 || t3.x >= Math.min(e2.x, s2.x) && t3.x <= Math.max(e2.x, s2.x));
    {
      const r2 = qe(e2, s2), n2 = qe(e2, t3).divide(r2);
      return i2 ? Math.abs(n2.x) === Math.abs(n2.y) : n2.x === n2.y && n2.x >= 0 && n2.x <= 1;
    }
  }
  static isPointInPolygon(t3, e2) {
    const s2 = new U(t3).setX(Math.min(t3.x - 1, ...e2.map((t4) => t4.x)));
    let i2 = 0;
    for (let r2 = 0; r2 < e2.length; r2++) {
      const n2 = this.intersectSegmentSegment(e2[r2], e2[(r2 + 1) % e2.length], t3, s2);
      if (n2.includes(t3))
        return true;
      i2 += Number("Intersection" === n2.status);
    }
    return i2 % 2 == 1;
  }
  static intersectLineLine(t3, e2, s2, i2) {
    let r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], n2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5];
    const o2 = e2.x - t3.x, a2 = e2.y - t3.y, h2 = i2.x - s2.x, c2 = i2.y - s2.y, l2 = t3.x - s2.x, u2 = t3.y - s2.y, d2 = h2 * u2 - c2 * l2, g2 = o2 * u2 - a2 * l2, f2 = c2 * o2 - h2 * a2;
    if (0 !== f2) {
      const e3 = d2 / f2, s3 = g2 / f2;
      return (r2 || 0 <= e3 && e3 <= 1) && (n2 || 0 <= s3 && s3 <= 1) ? new _is("Intersection").append(new U(t3.x + e3 * o2, t3.y + e3 * a2)) : new _is();
    }
    if (0 === d2 || 0 === g2) {
      const o3 = r2 || n2 || _is.isPointContained(t3, s2, i2) || _is.isPointContained(e2, s2, i2) || _is.isPointContained(s2, t3, e2) || _is.isPointContained(i2, t3, e2);
      return new _is(o3 ? "Coincident" : void 0);
    }
    return new _is("Parallel");
  }
  static intersectSegmentLine(t3, e2, s2, i2) {
    return _is.intersectLineLine(t3, e2, s2, i2, false, true);
  }
  static intersectSegmentSegment(t3, e2, s2, i2) {
    return _is.intersectLineLine(t3, e2, s2, i2, false, false);
  }
  static intersectLinePolygon(t3, e2, s2) {
    let i2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    const r2 = new _is(), n2 = s2.length;
    for (let o2, a2, h2, c2 = 0; c2 < n2; c2++) {
      if (o2 = s2[c2], a2 = s2[(c2 + 1) % n2], h2 = _is.intersectLineLine(t3, e2, o2, a2, i2, false), "Coincident" === h2.status)
        return h2;
      r2.append(...h2.points);
    }
    return r2.points.length > 0 && (r2.status = "Intersection"), r2;
  }
  static intersectSegmentPolygon(t3, e2, s2) {
    return _is.intersectLinePolygon(t3, e2, s2, false);
  }
  static intersectPolygonPolygon(t3, e2) {
    const s2 = new _is(), i2 = t3.length, r2 = [];
    for (let n2 = 0; n2 < i2; n2++) {
      const o2 = t3[n2], a2 = t3[(n2 + 1) % i2], h2 = _is.intersectSegmentPolygon(o2, a2, e2);
      "Coincident" === h2.status ? (r2.push(h2), s2.append(o2, a2)) : s2.append(...h2.points);
    }
    return r2.length > 0 && r2.length === t3.length ? new _is("Coincident") : (s2.points.length > 0 && (s2.status = "Intersection"), s2);
  }
  static intersectPolygonRectangle(t3, e2, s2) {
    const i2 = e2.min(s2), r2 = e2.max(s2), n2 = new U(r2.x, i2.y), o2 = new U(i2.x, r2.y);
    return _is.intersectPolygonPolygon(t3, [i2, n2, r2, o2]);
  }
};
var rs = class extends J {
  _getTransformedDimensions() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const s2 = e({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, t3), i2 = s2.strokeWidth;
    let r2 = i2, n2 = 0;
    this.strokeUniform && (r2 = 0, n2 = i2);
    const o2 = s2.width + r2, a2 = s2.height + r2;
    let h2;
    return h2 = 0 === s2.skewX && 0 === s2.skewY ? new U(o2 * s2.scaleX, a2 * s2.scaleY) : ce(o2, a2, _t(s2)), h2.scalarAdd(n2);
  }
  translateToGivenOrigin(t3, e2, s2, i2, r2) {
    let n2 = t3.x, o2 = t3.y;
    const a2 = me(i2) - me(e2), h2 = me(r2) - me(s2);
    if (a2 || h2) {
      const t4 = this._getTransformedDimensions();
      n2 += a2 * t4.x, o2 += h2 * t4.y;
    }
    return new U(n2, o2);
  }
  translateToCenterPoint(t3, e2, s2) {
    const i2 = this.translateToGivenOrigin(t3, e2, s2, M, M);
    return this.angle ? i2.rotate(rt(this.angle), t3) : i2;
  }
  translateToOriginPoint(t3, e2, s2) {
    const i2 = this.translateToGivenOrigin(t3, M, M, e2, s2);
    return this.angle ? i2.rotate(rt(this.angle), t3) : i2;
  }
  getCenterPoint() {
    const t3 = this.getRelativeCenterPoint();
    return this.group ? at(t3, this.group.calcTransformMatrix()) : t3;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new U(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(t3, e2) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), t3, e2);
  }
  setPositionByOrigin(t3, e2, s2) {
    const i2 = this.translateToCenterPoint(t3, e2, s2), r2 = this.translateToOriginPoint(i2, this.originX, this.originY);
    this.set({ left: r2.x, top: r2.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), P, E);
  }
};
var ns = class extends rs {
  getX() {
    return this.getXY().x;
  }
  setX(t3) {
    this.setXY(this.getXY().setX(t3));
  }
  getY() {
    return this.getXY().y;
  }
  setY(t3) {
    this.setXY(this.getXY().setY(t3));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(t3) {
    this.left = t3;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(t3) {
    this.top = t3;
  }
  getXY() {
    const t3 = this.getRelativeXY();
    return this.group ? at(t3, this.group.calcTransformMatrix()) : t3;
  }
  setXY(t3, e2, s2) {
    this.group && (t3 = at(t3, ht(this.group.calcTransformMatrix()))), this.setRelativeXY(t3, e2, s2);
  }
  getRelativeXY() {
    return new U(this.left, this.top);
  }
  setRelativeXY(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.originX, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.originY;
    this.setPositionByOrigin(t3, e2, s2);
  }
  isStrokeAccountedForInDimensions() {
    return false;
  }
  getCoords() {
    const { tl: t3, tr: e2, br: s2, bl: i2 } = this.aCoords || (this.aCoords = this.calcACoords()), r2 = [t3, e2, s2, i2];
    if (this.group) {
      const t4 = this.group.calcTransformMatrix();
      return r2.map((e3) => at(e3, t4));
    }
    return r2;
  }
  intersectsWithRect(t3, e2) {
    return "Intersection" === is.intersectPolygonRectangle(this.getCoords(), t3, e2).status;
  }
  intersectsWithObject(t3) {
    const e2 = is.intersectPolygonPolygon(this.getCoords(), t3.getCoords());
    return "Intersection" === e2.status || "Coincident" === e2.status || t3.isContainedWithinObject(this) || this.isContainedWithinObject(t3);
  }
  isContainedWithinObject(t3) {
    return this.getCoords().every((e2) => t3.containsPoint(e2));
  }
  isContainedWithinRect(t3, e2) {
    const { left: s2, top: i2, width: r2, height: n2 } = this.getBoundingRect();
    return s2 >= t3.x && s2 + r2 <= e2.x && i2 >= t3.y && i2 + n2 <= e2.y;
  }
  isOverlapping(t3) {
    return this.intersectsWithObject(t3) || this.isContainedWithinObject(t3) || t3.isContainedWithinObject(this);
  }
  containsPoint(t3) {
    return is.isPointInPolygon(t3, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas)
      return false;
    const { tl: t3, br: e2 } = this.canvas.vptCoords;
    return !!this.getCoords().some((s2) => s2.x <= e2.x && s2.x >= t3.x && s2.y <= e2.y && s2.y >= t3.y) || (!!this.intersectsWithRect(t3, e2) || this.containsPoint(t3.midPointFrom(e2)));
  }
  isPartiallyOnScreen() {
    if (!this.canvas)
      return false;
    const { tl: t3, br: e2 } = this.canvas.vptCoords;
    if (this.intersectsWithRect(t3, e2))
      return true;
    return this.getCoords().every((s2) => (s2.x >= e2.x || s2.x <= t3.x) && (s2.y >= e2.y || s2.y <= t3.y)) && this.containsPoint(t3.midPointFrom(e2));
  }
  getBoundingRect() {
    return ie(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(t3) {
    this._set("scaleX", t3), this._set("scaleY", t3), this.setCoords();
  }
  scaleToWidth(t3) {
    const e2 = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(t3 / this.width / e2);
  }
  scaleToHeight(t3) {
    const e2 = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(t3 / this.height / e2);
  }
  getCanvasRetinaScaling() {
    var t3;
    return (null === (t3 = this.canvas) || void 0 === t3 ? void 0 : t3.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? nt(ut(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var t3;
    return (null === (t3 = this.canvas) || void 0 === t3 ? void 0 : t3.viewportTransform) || O.concat();
  }
  calcACoords() {
    const t3 = ft({ angle: this.angle }), { x: e2, y: s2 } = this.getRelativeCenterPoint(), i2 = gt(e2, s2), r2 = ct(i2, t3), n2 = this._getTransformedDimensions(), o2 = n2.x / 2, a2 = n2.y / 2;
    return { tl: at({ x: -o2, y: -a2 }, r2), tr: at({ x: o2, y: -a2 }, r2), bl: at({ x: -o2, y: a2 }, r2), br: at({ x: o2, y: a2 }, r2) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e2 = [];
    return !t3 && this.group && (e2 = this.group.transformMatrixKey(t3)), e2.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, me(this.originX), me(this.originY)), e2;
  }
  calcTransformMatrix() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e2 = this.calcOwnMatrix();
    if (t3 || !this.group)
      return e2;
    const s2 = this.transformMatrixKey(t3), i2 = this.matrixCache;
    return i2 && i2.key.every((t4, e3) => t4 === s2[e3]) ? i2.value : (this.group && (e2 = ct(this.group.calcTransformMatrix(false), e2)), this.matrixCache = { key: s2, value: e2 }, e2);
  }
  calcOwnMatrix() {
    const t3 = this.transformMatrixKey(true), e2 = this.ownMatrixCache;
    if (e2 && e2.key === t3)
      return e2.value;
    const s2 = this.getRelativeCenterPoint(), i2 = { angle: this.angle, translateX: s2.x, translateY: s2.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, r2 = xt(i2);
    return this.ownMatrixCache = { key: t3, value: r2 }, r2;
  }
  _getNonTransformedDimensions() {
    return new U(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(t3) {
    return this._getTransformedDimensions(t3).transform(this.getViewportTransform(), true).scalarAdd(2 * this.padding);
  }
};
var os = class _os extends ns {
  isDescendantOf(t3) {
    const { parent: e2, group: s2 } = this;
    return e2 === t3 || s2 === t3 || this.canvas === t3 || !!e2 && e2.isDescendantOf(t3) || !!s2 && s2 !== e2 && s2.isDescendantOf(t3);
  }
  getAncestors(t3) {
    const e2 = [];
    let s2 = this;
    do {
      var i2;
      s2 = s2 instanceof _os ? null !== (i2 = s2.parent) && void 0 !== i2 ? i2 : t3 ? void 0 : s2.canvas : void 0, s2 && e2.push(s2);
    } while (s2);
    return e2;
  }
  findCommonAncestors(t3, e2) {
    if (this === t3)
      return { fork: [], otherFork: [], common: [this, ...this.getAncestors(e2)] };
    const s2 = this.getAncestors(e2), i2 = t3.getAncestors(e2);
    if (0 === s2.length && i2.length > 0 && this === i2[i2.length - 1])
      return { fork: [], otherFork: [t3, ...i2.slice(0, i2.length - 1)], common: [this] };
    for (let e3, r2 = 0; r2 < s2.length; r2++) {
      if (e3 = s2[r2], e3 === t3)
        return { fork: [this, ...s2.slice(0, r2)], otherFork: [], common: s2.slice(r2) };
      for (let n2 = 0; n2 < i2.length; n2++) {
        if (this === i2[n2])
          return { fork: [], otherFork: [t3, ...i2.slice(0, n2)], common: [this, ...s2] };
        if (e3 === i2[n2])
          return { fork: [this, ...s2.slice(0, r2)], otherFork: [t3, ...i2.slice(0, n2)], common: s2.slice(r2) };
      }
    }
    return { fork: [this, ...s2], otherFork: [t3, ...i2], common: [] };
  }
  hasCommonAncestors(t3, e2) {
    const s2 = this.findCommonAncestors(t3, e2);
    return s2 && !!s2.common.length;
  }
  isInFrontOf(t3) {
    if (this === t3)
      return;
    const e2 = this.findCommonAncestors(t3);
    if (!e2)
      return;
    if (e2.fork.includes(t3))
      return true;
    if (e2.otherFork.includes(this))
      return false;
    const s2 = e2.common[0];
    if (!s2)
      return;
    const i2 = e2.fork.pop(), r2 = e2.otherFork.pop(), n2 = s2._objects.indexOf(i2), o2 = s2._objects.indexOf(r2);
    return n2 > -1 && n2 > o2;
  }
};
var as = class extends os {
  animate(t3, e2) {
    return Object.entries(t3).reduce((t4, s2) => {
      let [i2, r2] = s2;
      return t4[i2] = this._animate(i2, r2, e2), t4;
    }, {});
  }
  _animate(t3, s2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const r2 = t3.split("."), n2 = this.constructor.colorProperties.includes(r2[r2.length - 1]), { abort: o2, startValue: a2, onChange: h2, onComplete: c2 } = i2, l2 = e(e({}, i2), {}, { target: this, startValue: null != a2 ? a2 : r2.reduce((t4, e2) => t4[e2], this), endValue: s2, abort: null == o2 ? void 0 : o2.bind(this), onChange: (t4, e2, s3) => {
      r2.reduce((e3, s4, i3) => (i3 === r2.length - 1 && (e3[s4] = t4), e3[s4]), this), h2 && h2(t4, e2, s3);
    }, onComplete: (t4, e2, s3) => {
      this.setCoords(), c2 && c2(t4, e2, s3);
    } });
    return n2 ? He(l2) : ze(l2);
  }
};
function hs(t3) {
  return new RegExp("^(" + t3.join("|") + ")\\b", "i");
}
var cs;
var ls;
s(as, "colorProperties", ["fill", "stroke", "backgroundColor"]);
var us = String.raw(cs || (cs = r(["(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)"], ["(?:[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?)"])));
var ds = "http://www.w3.org/2000/svg";
String.raw(ls || (ls = r(["(?:s+,?s*|,s*|$)"], ["(?:\\s+,?\\s*|,\\s*|$)"])));
var gs = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + us + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + us + "))?\\s+(.*)");
var fs = { cx: P, x: P, r: "radius", cy: E, y: E, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" };
var ps = "font-size";
var ms = "clip-path";
var vs = hs(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
var ys = hs(["symbol", "image", "marker", "pattern", "view", "svg"]);
var _s = hs(["symbol", "g", "a", "svg", "clipPath", "defs"]);
var xs = new RegExp("^\\s*(" + us + "+)\\s*,?\\s*(" + us + "+)\\s*,?\\s*(" + us + "+)\\s*,?\\s*(" + us + "+)\\s*$");
var Cs = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?";
var bs = new RegExp("(?:\\s|^)" + Cs + Cs + "(" + us + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
var ws = class _ws {
  constructor(t3) {
    const e2 = "string" == typeof t3 ? _ws.parseShadow(t3) : t3;
    Object.assign(this, _ws.ownDefaults);
    for (const t4 in e2)
      this[t4] = e2[t4];
    this.id = tt();
  }
  static parseShadow(t3) {
    const e2 = t3.trim(), [, s2 = 0, i2 = 0, r2 = 0] = (bs.exec(e2) || []).map((t4) => parseFloat(t4) || 0);
    return { color: (e2.replace(bs, "") || "rgb(0,0,0)").trim(), offsetX: s2, offsetY: i2, blur: r2 };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(t3) {
    const e2 = Ne(new U(this.offsetX, this.offsetY), rt(-t3.angle)), s2 = new At(this.color);
    let i2 = 40, r2 = 40;
    return t3.width && t3.height && (i2 = 100 * jt((Math.abs(e2.x) + this.blur) / t3.width, a.NUM_FRACTION_DIGITS) + 20, r2 = 100 * jt((Math.abs(e2.y) + this.blur) / t3.height, a.NUM_FRACTION_DIGITS) + 20), t3.flipX && (e2.x *= -1), t3.flipY && (e2.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(r2, '%" height="').concat(100 + 2 * r2, '%" x="-').concat(i2, '%" width="').concat(100 + 2 * i2, '%" >\n	<feGaussianBlur in="SourceAlpha" stdDeviation="').concat(jt(this.blur ? this.blur / 2 : 0, a.NUM_FRACTION_DIGITS), '"></feGaussianBlur>\n	<feOffset dx="').concat(jt(e2.x, a.NUM_FRACTION_DIGITS), '" dy="').concat(jt(e2.y, a.NUM_FRACTION_DIGITS), '" result="oBlur" ></feOffset>\n	<feFlood flood-color="').concat(s2.toRgb(), '" flood-opacity="').concat(s2.getAlpha(), '"/>\n	<feComposite in2="oBlur" operator="in" />\n	<feMerge>\n		<feMergeNode></feMergeNode>\n		<feMergeNode in="SourceGraphic"></feMergeNode>\n	</feMerge>\n</filter>\n');
  }
  toObject() {
    const t3 = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, e2 = _ws.ownDefaults;
    return this.includeDefaultValues ? t3 : Tt(t3, (t4, s2) => t4 !== e2[s2]);
  }
  static async fromObject(t3) {
    return new this(t3);
  }
};
s(ws, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: false, includeDefaultValues: true, nonScaling: false }), s(ws, "type", "shadow"), I.setClass(ws, "shadow");
var Ss = (t3) => JSON.parse(JSON.stringify(t3));
var Ts = [E, P, "scaleX", "scaleY", "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", "skewX", "skewY"];
var Os = ["fill", "stroke", "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"];
var ks = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: false, flipY: false, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: P, originY: E, strokeWidth: 1, strokeUniform: false, padding: 0, opacity: 1, paintFirst: "fill", fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: true, includeDefaultValues: true, excludeFromExport: false, objectCaching: true, clipPath: void 0, inverted: false, absolutePositioned: false, centeredRotation: true, centeredScaling: false, dirty: true };
var Ds = ["type"];
var Ms = ["extraParam"];
var Ps = class t2 extends as {
  static getDefaults() {
    return t2.ownDefaults;
  }
  get type() {
    const t3 = this.constructor.type;
    return "FabricObject" === t3 ? "object" : t3.toLowerCase();
  }
  set type(t3) {
    h("warn", "Setting type has no effect", t3);
  }
  constructor(e2) {
    super(), s(this, "_cacheContext", null), Object.assign(this, t2.ownDefaults), this.setOptions(e2);
  }
  _createCacheCanvas() {
    this._cacheCanvas = et(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = true;
  }
  _limitCacheSize(t3) {
    const e2 = t3.width, s2 = t3.height, i2 = a.maxCacheSideLimit, r2 = a.minCacheSideLimit;
    if (e2 <= i2 && s2 <= i2 && e2 * s2 <= a.perfLimitSizeTotal)
      return e2 < r2 && (t3.width = r2), s2 < r2 && (t3.height = r2), t3;
    const n2 = e2 / s2, [o2, h2] = x.limitDimsByArea(n2), c2 = Ie(r2, o2, i2), l2 = Ie(r2, h2, i2);
    return e2 > c2 && (t3.zoomX /= e2 / c2, t3.width = c2, t3.capped = true), s2 > l2 && (t3.zoomY /= s2 / l2, t3.height = l2, t3.capped = true), t3;
  }
  _getCacheCanvasDimensions() {
    const t3 = this.getTotalObjectScaling(), e2 = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), s2 = e2.x * t3.x / this.scaleX, i2 = e2.y * t3.y / this.scaleY;
    return { width: s2 + 2, height: i2 + 2, zoomX: t3.x, zoomY: t3.y, x: s2, y: i2 };
  }
  _updateCacheCanvas() {
    const t3 = this._cacheCanvas, e2 = this._cacheContext, s2 = this._limitCacheSize(this._getCacheCanvasDimensions()), i2 = a.minCacheSideLimit, r2 = s2.width, n2 = s2.height, o2 = s2.zoomX, h2 = s2.zoomY, c2 = r2 !== this.cacheWidth || n2 !== this.cacheHeight, l2 = this.zoomX !== o2 || this.zoomY !== h2;
    if (!t3 || !e2)
      return false;
    let u2, d2, g2 = c2 || l2, f2 = 0, p2 = 0, m2 = false;
    if (c2) {
      const t4 = this._cacheCanvas.width, e3 = this._cacheCanvas.height, o3 = r2 > t4 || n2 > e3;
      m2 = o3 || (r2 < 0.9 * t4 || n2 < 0.9 * e3) && t4 > i2 && e3 > i2, o3 && !s2.capped && (r2 > i2 || n2 > i2) && (f2 = 0.1 * r2, p2 = 0.1 * n2);
    }
    return Wt(this) && this.path && (g2 = true, m2 = true, f2 += this.getHeightOfLine(0) * this.zoomX, p2 += this.getHeightOfLine(0) * this.zoomY), !!g2 && (m2 ? (t3.width = Math.ceil(r2 + f2), t3.height = Math.ceil(n2 + p2)) : (e2.setTransform(1, 0, 0, 1, 0, 0), e2.clearRect(0, 0, t3.width, t3.height)), u2 = s2.x / 2, d2 = s2.y / 2, this.cacheTranslationX = Math.round(t3.width / 2 - u2) + u2, this.cacheTranslationY = Math.round(t3.height / 2 - d2) + d2, this.cacheWidth = r2, this.cacheHeight = n2, e2.translate(this.cacheTranslationX, this.cacheTranslationY), e2.scale(o2, h2), this.zoomX = o2, this.zoomY = h2, true);
  }
  setOptions() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this._setOptions(t3);
  }
  transform(t3) {
    const e2 = this.group && !this.group._transformDone || this.group && this.canvas && t3 === this.canvas.contextTop, s2 = this.calcTransformMatrix(!e2);
    t3.transform(s2[0], s2[1], s2[2], s2[3], s2[4], s2[5]);
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const s2 = a.NUM_FRACTION_DIGITS, i2 = this.clipPath && !this.clipPath.excludeFromExport ? e(e({}, this.clipPath.toObject(t3)), {}, { inverted: this.clipPath.inverted, absolutePositioned: this.clipPath.absolutePositioned }) : null, r2 = e(e({}, St(this, t3)), {}, { type: this.constructor.type, version: C, originX: this.originX, originY: this.originY, left: jt(this.left, s2), top: jt(this.top, s2), width: jt(this.width, s2), height: jt(this.height, s2), fill: Xt(this.fill) ? this.fill.toObject() : this.fill, stroke: Xt(this.stroke) ? this.stroke.toObject() : this.stroke, strokeWidth: jt(this.strokeWidth, s2), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeDashOffset: this.strokeDashOffset, strokeLineJoin: this.strokeLineJoin, strokeUniform: this.strokeUniform, strokeMiterLimit: jt(this.strokeMiterLimit, s2), scaleX: jt(this.scaleX, s2), scaleY: jt(this.scaleY, s2), angle: jt(this.angle, s2), flipX: this.flipX, flipY: this.flipY, opacity: jt(this.opacity, s2), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, backgroundColor: this.backgroundColor, fillRule: this.fillRule, paintFirst: this.paintFirst, globalCompositeOperation: this.globalCompositeOperation, skewX: jt(this.skewX, s2), skewY: jt(this.skewY, s2) }, i2 ? { clipPath: i2 } : null);
    return this.includeDefaultValues ? r2 : this._removeDefaultValues(r2);
  }
  toDatalessObject(t3) {
    return this.toObject(t3);
  }
  _removeDefaultValues(t3) {
    const e2 = this.constructor.getDefaults(), s2 = Object.keys(e2).length > 0 ? e2 : Object.getPrototypeOf(this);
    return Tt(t3, (t4, e3) => {
      if (e3 === P || e3 === E || "type" === e3)
        return true;
      const i2 = s2[e3];
      return t4 !== i2 && !(Array.isArray(t4) && Array.isArray(i2) && 0 === t4.length && 0 === i2.length);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  getObjectScaling() {
    if (!this.group)
      return new U(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const t3 = dt(this.calcTransformMatrix());
    return new U(Math.abs(t3.scaleX), Math.abs(t3.scaleY));
  }
  getTotalObjectScaling() {
    const t3 = this.getObjectScaling();
    if (this.canvas) {
      const e2 = this.canvas.getZoom(), s2 = this.getCanvasRetinaScaling();
      return t3.scalarMultiply(e2 * s2);
    }
    return t3;
  }
  getObjectOpacity() {
    let t3 = this.opacity;
    return this.group && (t3 *= this.group.getObjectOpacity()), t3;
  }
  _constrainScale(t3) {
    return Math.abs(t3) < this.minScaleLimit ? t3 < 0 ? -this.minScaleLimit : this.minScaleLimit : 0 === t3 ? 1e-4 : t3;
  }
  _set(t3, e2) {
    "scaleX" !== t3 && "scaleY" !== t3 || (e2 = this._constrainScale(e2)), "scaleX" === t3 && e2 < 0 ? (this.flipX = !this.flipX, e2 *= -1) : "scaleY" === t3 && e2 < 0 ? (this.flipY = !this.flipY, e2 *= -1) : "shadow" !== t3 || !e2 || e2 instanceof ws || (e2 = new ws(e2));
    const s2 = this[t3] !== e2;
    return this[t3] = e2, s2 && this.constructor.cacheProperties.includes(t3) && (this.dirty = true), this.parent && (this.dirty || s2 && this.constructor.stateProperties.includes(t3)) && this.parent._set("dirty", true), this;
  }
  isNotVisible() {
    return 0 === this.opacity || !this.width && !this.height && 0 === this.strokeWidth || !this.visible;
  }
  render(t3) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t3.save(), this._setupCompositeOperation(t3), this.drawSelectionBackground(t3), this.transform(t3), this._setOpacity(t3), this._setShadow(t3), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t3)) : (this._removeCacheCanvas(), this.drawObject(t3), this.dirty = false), t3.restore());
  }
  drawSelectionBackground(t3) {
  }
  renderCache(t3) {
    t3 = t3 || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext && (this.drawObject(this._cacheContext, t3.forClipping), this.dirty = false);
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0;
  }
  hasStroke() {
    return this.stroke && "transparent" !== this.stroke && 0 !== this.strokeWidth;
  }
  hasFill() {
    return this.fill && "transparent" !== this.fill;
  }
  needsItsOwnCache() {
    return !!("stroke" === this.paintFirst && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.parent || !this.parent.isOnACache()), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY);
  }
  drawClipPathOnCache(t3, e2) {
    if (t3.save(), e2.inverted ? t3.globalCompositeOperation = "destination-out" : t3.globalCompositeOperation = "destination-in", e2.absolutePositioned) {
      const e3 = ht(this.calcTransformMatrix());
      t3.transform(e3[0], e3[1], e3[2], e3[3], e3[4], e3[5]);
    }
    e2.transform(t3), t3.scale(1 / e2.zoomX, 1 / e2.zoomY), t3.drawImage(e2._cacheCanvas, -e2.cacheTranslationX, -e2.cacheTranslationY), t3.restore();
  }
  drawObject(t3, e2) {
    const s2 = this.fill, i2 = this.stroke;
    e2 ? (this.fill = "black", this.stroke = "", this._setClippingProperties(t3)) : this._renderBackground(t3), this._render(t3), this._drawClipPath(t3, this.clipPath), this.fill = s2, this.stroke = i2;
  }
  _drawClipPath(t3, e2) {
    e2 && (e2._set("canvas", this.canvas), e2.shouldCache(), e2._transformDone = true, e2.renderCache({ forClipping: true }), this.drawClipPathOnCache(t3, e2));
  }
  drawCacheOnCanvas(t3) {
    t3.scale(1 / this.zoomX, 1 / this.zoomY), t3.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    if (this.isNotVisible())
      return false;
    if (this._cacheCanvas && this._cacheContext && !t3 && this._updateCacheCanvas())
      return true;
    if (this.dirty || this.clipPath && this.clipPath.absolutePositioned) {
      if (this._cacheCanvas && this._cacheContext && !t3) {
        const t4 = this.cacheWidth / this.zoomX, e2 = this.cacheHeight / this.zoomY;
        this._cacheContext.clearRect(-t4 / 2, -e2 / 2, t4, e2);
      }
      return true;
    }
    return false;
  }
  _renderBackground(t3) {
    if (!this.backgroundColor)
      return;
    const e2 = this._getNonTransformedDimensions();
    t3.fillStyle = this.backgroundColor, t3.fillRect(-e2.x / 2, -e2.y / 2, e2.x, e2.y), this._removeShadow(t3);
  }
  _setOpacity(t3) {
    this.group && !this.group._transformDone ? t3.globalAlpha = this.getObjectOpacity() : t3.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(t3, e2) {
    const s2 = e2.stroke;
    s2 && (t3.lineWidth = e2.strokeWidth, t3.lineCap = e2.strokeLineCap, t3.lineDashOffset = e2.strokeDashOffset, t3.lineJoin = e2.strokeLineJoin, t3.miterLimit = e2.strokeMiterLimit, It(s2) ? "percentage" === s2.gradientUnits || s2.gradientTransform || s2.patternTransform ? this._applyPatternForTransformedGradient(t3, s2) : (t3.strokeStyle = s2.toLive(t3), this._applyPatternGradientTransform(t3, s2)) : t3.strokeStyle = e2.stroke);
  }
  _setFillStyles(t3, e2) {
    let { fill: s2 } = e2;
    s2 && (It(s2) ? (t3.fillStyle = s2.toLive(t3), this._applyPatternGradientTransform(t3, s2)) : t3.fillStyle = s2);
  }
  _setClippingProperties(t3) {
    t3.globalAlpha = 1, t3.strokeStyle = "transparent", t3.fillStyle = "#000000";
  }
  _setLineDash(t3, e2) {
    e2 && 0 !== e2.length && (1 & e2.length && e2.push(...e2), t3.setLineDash(e2));
  }
  _setShadow(t3) {
    if (!this.shadow)
      return;
    const e2 = this.shadow, s2 = this.canvas, i2 = this.getCanvasRetinaScaling(), [r2, , , n2] = (null == s2 ? void 0 : s2.viewportTransform) || O, o2 = r2 * i2, h2 = n2 * i2, c2 = e2.nonScaling ? new U(1, 1) : this.getObjectScaling();
    t3.shadowColor = e2.color, t3.shadowBlur = e2.blur * a.browserShadowBlurConstant * (o2 + h2) * (c2.x + c2.y) / 4, t3.shadowOffsetX = e2.offsetX * o2 * c2.x, t3.shadowOffsetY = e2.offsetY * h2 * c2.y;
  }
  _removeShadow(t3) {
    this.shadow && (t3.shadowColor = "", t3.shadowBlur = t3.shadowOffsetX = t3.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(t3, e2) {
    if (!It(e2))
      return { offsetX: 0, offsetY: 0 };
    const s2 = e2.gradientTransform || e2.patternTransform, i2 = -this.width / 2 + e2.offsetX || 0, r2 = -this.height / 2 + e2.offsetY || 0;
    return "percentage" === e2.gradientUnits ? t3.transform(this.width, 0, 0, this.height, i2, r2) : t3.transform(1, 0, 0, 1, i2, r2), s2 && t3.transform(s2[0], s2[1], s2[2], s2[3], s2[4], s2[5]), { offsetX: i2, offsetY: r2 };
  }
  _renderPaintInOrder(t3) {
    "stroke" === this.paintFirst ? (this._renderStroke(t3), this._renderFill(t3)) : (this._renderFill(t3), this._renderStroke(t3));
  }
  _render(t3) {
  }
  _renderFill(t3) {
    this.fill && (t3.save(), this._setFillStyles(t3, this), "evenodd" === this.fillRule ? t3.fill("evenodd") : t3.fill(), t3.restore());
  }
  _renderStroke(t3) {
    if (this.stroke && 0 !== this.strokeWidth) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t3), t3.save(), this.strokeUniform) {
        const e2 = this.getObjectScaling();
        t3.scale(1 / e2.x, 1 / e2.y);
      }
      this._setLineDash(t3, this.strokeDashArray), this._setStrokeStyles(t3, this), t3.stroke(), t3.restore();
    }
  }
  _applyPatternForTransformedGradient(t3, e2) {
    var s2;
    const i2 = this._limitCacheSize(this._getCacheCanvasDimensions()), r2 = et(), n2 = this.getCanvasRetinaScaling(), o2 = i2.x / this.scaleX / n2, a2 = i2.y / this.scaleY / n2;
    r2.width = Math.ceil(o2), r2.height = Math.ceil(a2);
    const h2 = r2.getContext("2d");
    h2 && (h2.beginPath(), h2.moveTo(0, 0), h2.lineTo(o2, 0), h2.lineTo(o2, a2), h2.lineTo(0, a2), h2.closePath(), h2.translate(o2 / 2, a2 / 2), h2.scale(i2.zoomX / this.scaleX / n2, i2.zoomY / this.scaleY / n2), this._applyPatternGradientTransform(h2, e2), h2.fillStyle = e2.toLive(t3), h2.fill(), t3.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t3.scale(n2 * this.scaleX / i2.zoomX, n2 * this.scaleY / i2.zoomY), t3.strokeStyle = null !== (s2 = h2.createPattern(r2, "no-repeat")) && void 0 !== s2 ? s2 : "");
  }
  _findCenterFromElement() {
    return new U(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(t3) {
    const e2 = this.toObject(t3);
    return this.constructor.fromObject(e2);
  }
  cloneAsImage(t3) {
    const e2 = this.toCanvasElement(t3);
    return new (I.getClass("image"))(e2);
  }
  toCanvasElement() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const e2 = he(this), s2 = this.group, i2 = this.shadow, r2 = Math.abs, n2 = t3.enableRetinaScaling ? _() : 1, o2 = (t3.multiplier || 1) * n2, a2 = t3.canvasProvider || ((t4) => new Qt(t4, { enableRetinaScaling: false, renderOnAddRemove: false, skipOffscreen: false }));
    delete this.group, t3.withoutTransform && ae(this), t3.withoutShadow && (this.shadow = null), t3.viewportTransform && ge(this, this.getViewportTransform()), this.setCoords();
    const h2 = et(), c2 = this.getBoundingRect(), l2 = this.shadow, u2 = new U();
    if (l2) {
      const t4 = l2.blur, e3 = l2.nonScaling ? new U(1, 1) : this.getObjectScaling();
      u2.x = 2 * Math.round(r2(l2.offsetX) + t4) * r2(e3.x), u2.y = 2 * Math.round(r2(l2.offsetY) + t4) * r2(e3.y);
    }
    const d2 = c2.width + u2.x, g2 = c2.height + u2.y;
    h2.width = Math.ceil(d2), h2.height = Math.ceil(g2);
    const f2 = a2(h2);
    "jpeg" === t3.format && (f2.backgroundColor = "#fff"), this.setPositionByOrigin(new U(f2.width / 2, f2.height / 2), M, M);
    const p2 = this.canvas;
    f2._objects = [this], this.set("canvas", f2), this.setCoords();
    const m2 = f2.toCanvasElement(o2 || 1, t3);
    return this.set("canvas", p2), this.shadow = i2, s2 && (this.group = s2), this.set(e2), this.setCoords(), f2._objects = [], f2.destroy(), m2;
  }
  toDataURL() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return it(this.toCanvasElement(t3), t3.format || "png", t3.quality || 1);
  }
  isType() {
    for (var t3 = arguments.length, e2 = new Array(t3), s2 = 0; s2 < t3; s2++)
      e2[s2] = arguments[s2];
    return e2.includes(this.constructor.type) || e2.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(t3) {
    const { centeredRotation: e2, originX: s2, originY: i2 } = this;
    if (e2) {
      const { x: t4, y: e3 } = this.getRelativeCenterPoint();
      this.originX = M, this.originY = M, this.left = t4, this.top = e3;
    }
    if (this.set("angle", t3), e2) {
      const { x: t4, y: e3 } = this.translateToOriginPoint(this.getRelativeCenterPoint(), s2, i2);
      this.left = t4, this.top = e3, this.originX = s2, this.originY = i2;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(t3) {
    this.globalCompositeOperation && (t3.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    X.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && m().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  static _fromObject(t3) {
    let s2 = i(t3, Ds), r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { extraParam: o2 } = r2, a2 = i(r2, Ms);
    return wt(Ss(s2), a2).then((t4) => {
      const s3 = e(e({}, a2), t4);
      if (o2) {
        const { [o2]: t5 } = s3;
        return new this(t5, i(s3, [o2].map(n)));
      }
      return new this(s3);
    });
  }
  static fromObject(t3, e2) {
    return this._fromObject(t3, e2);
  }
};
s(Ps, "stateProperties", Ts), s(Ps, "cacheProperties", Os), s(Ps, "ownDefaults", ks), s(Ps, "type", "FabricObject"), I.setClass(Ps), I.setClass(Ps, "object");
var Es = (t3, e2) => (s2, i2, r2, n2) => {
  const o2 = e2(s2, i2, r2, n2);
  return o2 && fe(t3, Ce(s2, i2, r2, n2)), o2;
};
function As(t3) {
  return (e2, s2, i2, r2) => {
    const { target: n2, originX: o2, originY: a2 } = s2, h2 = n2.getRelativeCenterPoint(), c2 = n2.translateToOriginPoint(h2, o2, a2), l2 = t3(e2, s2, i2, r2);
    return n2.setPositionByOrigin(c2, s2.originX, s2.originY), l2;
  };
}
var js = Es("resizing", As((t3, e2, s2, i2) => {
  const r2 = we(e2, e2.originX, e2.originY, s2, i2);
  if (e2.originX === M || e2.originX === j && r2.x < 0 || e2.originX === P && r2.x > 0) {
    const { target: t4 } = e2, s3 = t4.strokeWidth / (t4.strokeUniform ? t4.scaleX : 1), i3 = ye(e2) ? 2 : 1, n2 = t4.width, o2 = Math.ceil(Math.abs(r2.x * i3 / t4.scaleX) - s3);
    return t4.set("width", Math.max(o2, 0)), n2 !== t4.width;
  }
  return false;
}));
function Fs(t3, e2, s2, i2, r2) {
  i2 = i2 || {};
  const n2 = this.sizeX || i2.cornerSize || r2.cornerSize, o2 = this.sizeY || i2.cornerSize || r2.cornerSize, a2 = void 0 !== i2.transparentCorners ? i2.transparentCorners : r2.transparentCorners, h2 = a2 ? "stroke" : "fill", c2 = !a2 && (i2.cornerStrokeColor || r2.cornerStrokeColor);
  let l2, u2 = e2, d2 = s2;
  t3.save(), t3.fillStyle = i2.cornerColor || r2.cornerColor || "", t3.strokeStyle = i2.cornerStrokeColor || r2.cornerStrokeColor || "", n2 > o2 ? (l2 = n2, t3.scale(1, o2 / n2), d2 = s2 * n2 / o2) : o2 > n2 ? (l2 = o2, t3.scale(n2 / o2, 1), u2 = e2 * o2 / n2) : l2 = n2, t3.lineWidth = 1, t3.beginPath(), t3.arc(u2, d2, l2 / 2, 0, S, false), t3[h2](), c2 && t3.stroke(), t3.restore();
}
function Ls(t3, e2, s2, i2, r2) {
  i2 = i2 || {};
  const n2 = this.sizeX || i2.cornerSize || r2.cornerSize, o2 = this.sizeY || i2.cornerSize || r2.cornerSize, a2 = void 0 !== i2.transparentCorners ? i2.transparentCorners : r2.transparentCorners, h2 = a2 ? "stroke" : "fill", c2 = !a2 && (i2.cornerStrokeColor || r2.cornerStrokeColor), l2 = n2 / 2, u2 = o2 / 2;
  t3.save(), t3.fillStyle = i2.cornerColor || r2.cornerColor || "", t3.strokeStyle = i2.cornerStrokeColor || r2.cornerStrokeColor || "", t3.lineWidth = 1, t3.translate(e2, s2);
  const d2 = r2.getTotalAngle();
  t3.rotate(rt(d2)), t3["".concat(h2, "Rect")](-l2, -u2, n2, o2), c2 && t3.strokeRect(-l2, -u2, n2, o2), t3.restore();
}
var Rs = class {
  constructor(t3) {
    s(this, "visible", true), s(this, "actionName", "scale"), s(this, "angle", 0), s(this, "x", 0), s(this, "y", 0), s(this, "offsetX", 0), s(this, "offsetY", 0), s(this, "sizeX", 0), s(this, "sizeY", 0), s(this, "touchSizeX", 0), s(this, "touchSizeY", 0), s(this, "cursorStyle", "crosshair"), s(this, "withConnection", false), Object.assign(this, t3);
  }
  shouldActivate(t3, e2, s2, i2) {
    var r2;
    let { tl: n2, tr: o2, br: a2, bl: h2 } = i2;
    return (null === (r2 = e2.canvas) || void 0 === r2 ? void 0 : r2.getActiveObject()) === e2 && e2.isControlVisible(t3) && is.isPointInPolygon(s2, [n2, o2, a2, h2]);
  }
  getActionHandler(t3, e2, s2) {
    return this.actionHandler;
  }
  getMouseDownHandler(t3, e2, s2) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(t3, e2, s2) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(t3, e2, s2) {
    return e2.cursorStyle;
  }
  getActionName(t3, e2, s2) {
    return e2.actionName;
  }
  getVisibility(t3, e2) {
    var s2, i2;
    return null !== (s2 = null === (i2 = t3._controlsVisibility) || void 0 === i2 ? void 0 : i2[e2]) && void 0 !== s2 ? s2 : this.visible;
  }
  setVisibility(t3, e2, s2) {
    this.visible = t3;
  }
  positionHandler(t3, e2, s2, i2) {
    return new U(this.x * t3.x + this.offsetX, this.y * t3.y + this.offsetY).transform(e2);
  }
  calcCornerCoords(t3, e2, s2, i2, r2, n2) {
    const o2 = lt([gt(s2, i2), ft({ angle: t3 }), pt((r2 ? this.touchSizeX : this.sizeX) || e2, (r2 ? this.touchSizeY : this.sizeY) || e2)]);
    return { tl: new U(-0.5, -0.5).transform(o2), tr: new U(0.5, -0.5).transform(o2), br: new U(0.5, 0.5).transform(o2), bl: new U(-0.5, 0.5).transform(o2) };
  }
  render(t3, e2, s2, i2, r2) {
    if ("circle" === ((i2 = i2 || {}).cornerStyle || r2.cornerStyle))
      Fs.call(this, t3, e2, s2, i2, r2);
    else
      Ls.call(this, t3, e2, s2, i2, r2);
  }
};
var Bs = (t3, e2, s2) => s2.lockRotation ? ve : e2.cursorStyle;
var Is = Es("rotating", As((t3, e2, s2, i2) => {
  let { target: r2, ex: n2, ey: o2, theta: a2, originX: h2, originY: c2 } = e2;
  const l2 = r2.translateToOriginPoint(r2.getRelativeCenterPoint(), h2, c2);
  if (xe(r2, "lockRotation"))
    return false;
  const u2 = Math.atan2(o2 - l2.y, n2 - l2.x), d2 = Math.atan2(i2 - l2.y, s2 - l2.x);
  let g2 = nt(d2 - u2 + a2);
  if (r2.snapAngle && r2.snapAngle > 0) {
    const t4 = r2.snapAngle, e3 = r2.snapThreshold || t4, s3 = Math.ceil(g2 / t4) * t4, i3 = Math.floor(g2 / t4) * t4;
    Math.abs(g2 - i3) < e3 ? g2 = i3 : Math.abs(g2 - s3) < e3 && (g2 = s3);
  }
  g2 < 0 && (g2 = 360 + g2), g2 %= 360;
  const f2 = r2.angle !== g2;
  return r2.angle = g2, f2;
}));
function Xs(t3, e2) {
  const s2 = e2.canvas, i2 = t3[s2.uniScaleKey];
  return s2.uniformScaling && !i2 || !s2.uniformScaling && i2;
}
function Ys(t3, e2, s2) {
  const i2 = xe(t3, "lockScalingX"), r2 = xe(t3, "lockScalingY");
  if (i2 && r2)
    return true;
  if (!e2 && (i2 || r2) && s2)
    return true;
  if (i2 && "x" === e2)
    return true;
  if (r2 && "y" === e2)
    return true;
  const { width: n2, height: o2, strokeWidth: a2 } = t3;
  return 0 === n2 && 0 === a2 && "y" !== e2 || 0 === o2 && 0 === a2 && "x" !== e2;
}
var Ws = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"];
var Vs = (t3, e2, s2) => {
  const i2 = Xs(t3, s2);
  if (Ys(s2, 0 !== e2.x && 0 === e2.y ? "x" : 0 === e2.x && 0 !== e2.y ? "y" : "", i2))
    return ve;
  const r2 = be(s2, e2);
  return "".concat(Ws[r2], "-resize");
};
function zs(t3, e2, s2, i2) {
  let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
  const n2 = e2.target, o2 = r2.by, a2 = Xs(t3, n2);
  let h2, c2, l2, u2, d2, g2;
  if (Ys(n2, o2, a2))
    return false;
  if (e2.gestureScale)
    c2 = e2.scaleX * e2.gestureScale, l2 = e2.scaleY * e2.gestureScale;
  else {
    if (h2 = we(e2, e2.originX, e2.originY, s2, i2), d2 = "y" !== o2 ? Math.sign(h2.x || e2.signX || 1) : 1, g2 = "x" !== o2 ? Math.sign(h2.y || e2.signY || 1) : 1, e2.signX || (e2.signX = d2), e2.signY || (e2.signY = g2), xe(n2, "lockScalingFlip") && (e2.signX !== d2 || e2.signY !== g2))
      return false;
    if (u2 = n2._getTransformedDimensions(), a2 && !o2) {
      const t4 = Math.abs(h2.x) + Math.abs(h2.y), { original: s3 } = e2, i3 = t4 / (Math.abs(u2.x * s3.scaleX / n2.scaleX) + Math.abs(u2.y * s3.scaleY / n2.scaleY));
      c2 = s3.scaleX * i3, l2 = s3.scaleY * i3;
    } else
      c2 = Math.abs(h2.x * n2.scaleX / u2.x), l2 = Math.abs(h2.y * n2.scaleY / u2.y);
    ye(e2) && (c2 *= 2, l2 *= 2), e2.signX !== d2 && "y" !== o2 && (e2.originX = _e(e2.originX), c2 *= -1, e2.signX = d2), e2.signY !== g2 && "x" !== o2 && (e2.originY = _e(e2.originY), l2 *= -1, e2.signY = g2);
  }
  const f2 = n2.scaleX, p2 = n2.scaleY;
  return o2 ? ("x" === o2 && n2.set("scaleX", c2), "y" === o2 && n2.set("scaleY", l2)) : (!xe(n2, "lockScalingX") && n2.set("scaleX", c2), !xe(n2, "lockScalingY") && n2.set("scaleY", l2)), f2 !== n2.scaleX || p2 !== n2.scaleY;
}
var Hs = Es("scaling", As((t3, e2, s2, i2) => zs(t3, e2, s2, i2)));
var Gs = Es("scaling", As((t3, e2, s2, i2) => zs(t3, e2, s2, i2, { by: "x" })));
var Us = Es("scaling", As((t3, e2, s2, i2) => zs(t3, e2, s2, i2, { by: "y" })));
var Ns = ["target", "ex", "ey", "skewingSide"];
var qs = { x: { counterAxis: "y", scale: "scaleX", skew: "skewX", lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: "scaleY", skew: "skewY", lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } };
var Ks = ["ns", "nesw", "ew", "nwse"];
var Js = (t3, e2, s2) => {
  if (0 !== e2.x && xe(s2, "lockSkewingY"))
    return ve;
  if (0 !== e2.y && xe(s2, "lockSkewingX"))
    return ve;
  const i2 = be(s2, e2) % 4;
  return "".concat(Ks[i2], "-resize");
};
function Zs(t3, s2, r2, n2, o2) {
  const { target: a2 } = r2, { counterAxis: h2, origin: c2, lockSkewing: l2, skew: u2, flip: d2 } = qs[t3];
  if (xe(a2, l2))
    return false;
  const { origin: g2, flip: f2 } = qs[h2], p2 = me(r2[g2]) * (a2[f2] ? -1 : 1), m2 = -Math.sign(p2) * (a2[d2] ? -1 : 1), v2 = 0.5 * -((0 === a2[u2] && we(r2, M, M, n2, o2)[t3] > 0 || a2[u2] > 0 ? 1 : -1) * m2) + 0.5, y2 = Es("skewing", As((e2, s3, r3, n3) => function(t4, e3, s4) {
    let { target: r4, ex: n4, ey: o3, skewingSide: a3 } = e3, h3 = i(e3, Ns);
    const { skew: c3 } = qs[t4], l3 = s4.subtract(new U(n4, o3)).divide(new U(r4.scaleX, r4.scaleY))[t4], u3 = r4[c3], d3 = h3[c3], g3 = Math.tan(rt(d3)), f3 = "y" === t4 ? r4._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : r4._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, p3 = 2 * l3 * a3 / Math.max(f3, 1) + g3, m3 = nt(Math.atan(p3));
    r4.set(c3, m3);
    const v3 = u3 !== r4[c3];
    if (v3 && "y" === t4) {
      const { skewX: t5, scaleX: e4 } = r4, s5 = r4._getTransformedDimensions({ skewY: u3 }), i2 = r4._getTransformedDimensions(), n5 = 0 !== t5 ? s5.x / i2.x : 1;
      1 !== n5 && r4.set("scaleX", n5 * e4);
    }
    return v3;
  }(t3, s3, new U(r3, n3))));
  return y2(s2, e(e({}, r2), {}, { [c2]: v2, skewingSide: m2 }), n2, o2);
}
var Qs = (t3, e2, s2, i2) => Zs("x", t3, e2, s2, i2);
var $s = (t3, e2, s2, i2) => Zs("y", t3, e2, s2, i2);
function ti(t3, e2) {
  return t3[e2.canvas.altActionKey];
}
var ei = (t3, e2, s2) => {
  const i2 = ti(t3, s2);
  return 0 === e2.x ? i2 ? "skewX" : "scaleY" : 0 === e2.y ? i2 ? "skewY" : "scaleX" : "";
};
var si = (t3, e2, s2) => ti(t3, s2) ? Js(0, e2, s2) : Vs(t3, e2, s2);
var ii = (t3, e2, s2, i2) => ti(t3, e2.target) ? $s(t3, e2, s2, i2) : Gs(t3, e2, s2, i2);
var ri = (t3, e2, s2, i2) => ti(t3, e2.target) ? Qs(t3, e2, s2, i2) : Us(t3, e2, s2, i2);
var ni = () => ({ ml: new Rs({ x: -0.5, y: 0, cursorStyleHandler: si, actionHandler: ii, getActionName: ei }), mr: new Rs({ x: 0.5, y: 0, cursorStyleHandler: si, actionHandler: ii, getActionName: ei }), mb: new Rs({ x: 0, y: 0.5, cursorStyleHandler: si, actionHandler: ri, getActionName: ei }), mt: new Rs({ x: 0, y: -0.5, cursorStyleHandler: si, actionHandler: ri, getActionName: ei }), tl: new Rs({ x: -0.5, y: -0.5, cursorStyleHandler: Vs, actionHandler: Hs }), tr: new Rs({ x: 0.5, y: -0.5, cursorStyleHandler: Vs, actionHandler: Hs }), bl: new Rs({ x: -0.5, y: 0.5, cursorStyleHandler: Vs, actionHandler: Hs }), br: new Rs({ x: 0.5, y: 0.5, cursorStyleHandler: Vs, actionHandler: Hs }), mtr: new Rs({ x: 0, y: -0.5, actionHandler: Is, cursorStyleHandler: Bs, offsetY: -40, withConnection: true, actionName: "rotate" }) });
var oi = () => ({ mr: new Rs({ x: 0.5, y: 0, actionHandler: js, cursorStyleHandler: si, actionName: "resizing" }), ml: new Rs({ x: -0.5, y: 0, actionHandler: js, cursorStyleHandler: si, actionName: "resizing" }) });
var ai = () => e(e({}, ni()), oi());
var hi = class _hi extends Ps {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _hi.ownDefaults);
  }
  constructor(t3) {
    super(), Object.assign(this, this.constructor.createControls(), _hi.ownDefaults), this.setOptions(t3);
  }
  static createControls() {
    return { controls: ni() };
  }
  _updateCacheCanvas() {
    const t3 = this.canvas;
    if (this.noScaleCache && t3 && t3._currentTransform) {
      const e2 = t3._currentTransform, s2 = e2.target, i2 = e2.action;
      if (this === s2 && i2 && i2.startsWith("scale"))
        return false;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const t3 = this.__corner;
    return t3 ? { key: t3, control: this.controls[t3], coord: this.oCoords[t3] } : void 0;
  }
  findControl(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (!this.hasControls || !this.canvas)
      return;
    this.__corner = void 0;
    const s2 = Object.entries(this.oCoords);
    for (let i2 = s2.length - 1; i2 >= 0; i2--) {
      const [r2, n2] = s2[i2], o2 = this.controls[r2];
      if (o2.shouldActivate(r2, this, t3, e2 ? n2.touchCorner : n2.corner))
        return this.__corner = r2, { key: r2, control: o2, coord: this.oCoords[r2] };
    }
  }
  calcOCoords() {
    const t3 = this.getViewportTransform(), e2 = this.getCenterPoint(), s2 = gt(e2.x, e2.y), i2 = ft({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), r2 = ct(s2, i2), n2 = ct(t3, r2), o2 = ct(n2, [1 / t3[0], 0, 0, 1 / t3[3], 0, 0]), a2 = this.group ? dt(this.calcTransformMatrix()) : void 0;
    a2 && (a2.scaleX = Math.abs(a2.scaleX), a2.scaleY = Math.abs(a2.scaleY));
    const h2 = this._calculateCurrentDimensions(a2), c2 = {};
    return this.forEachControl((t4, e3) => {
      const s3 = t4.positionHandler(h2, o2, this, t4);
      c2[e3] = Object.assign(s3, this._calcCornerCoords(t4, s3));
    }), c2;
  }
  _calcCornerCoords(t3, e2) {
    const s2 = this.getTotalAngle();
    return { corner: t3.calcCornerCoords(s2, this.cornerSize, e2.x, e2.y, false, this), touchCorner: t3.calcCornerCoords(s2, this.touchCornerSize, e2.x, e2.y, true, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(t3) {
    for (const e2 in this.controls)
      t3(this.controls[e2], e2, this);
  }
  drawSelectionBackground(t3) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this)
      return;
    t3.save();
    const e2 = this.getRelativeCenterPoint(), s2 = this._calculateCurrentDimensions(), i2 = this.getViewportTransform();
    t3.translate(e2.x, e2.y), t3.scale(1 / i2[0], 1 / i2[3]), t3.rotate(rt(this.angle)), t3.fillStyle = this.selectionBackgroundColor, t3.fillRect(-s2.x / 2, -s2.y / 2, s2.x, s2.y), t3.restore();
  }
  strokeBorders(t3, e2) {
    t3.strokeRect(-e2.x / 2, -e2.y / 2, e2.x, e2.y);
  }
  _drawBorders(t3, s2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const r2 = e({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, i2);
    t3.save(), t3.strokeStyle = r2.borderColor, this._setLineDash(t3, r2.borderDashArray), this.strokeBorders(t3, s2), r2.hasControls && this.drawControlsConnectingLines(t3, s2), t3.restore();
  }
  _renderControls(t3) {
    let s2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const { hasBorders: i2, hasControls: r2 } = this, n2 = e({ hasBorders: i2, hasControls: r2 }, s2), o2 = this.getViewportTransform(), a2 = n2.hasBorders, h2 = n2.hasControls, c2 = ct(o2, this.calcTransformMatrix()), l2 = dt(c2);
    t3.save(), t3.translate(l2.translateX, l2.translateY), t3.lineWidth = 1 * this.borderScaleFactor, this.group === this.parent && (t3.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (l2.angle -= 180), t3.rotate(rt(this.group ? l2.angle : this.angle)), a2 && this.drawBorders(t3, l2, s2), h2 && this.drawControls(t3, s2), t3.restore();
  }
  drawBorders(t3, e2, s2) {
    let i2;
    if (s2 && s2.forActiveSelection || this.group) {
      const t4 = ce(this.width, this.height, _t(e2)), s3 = this.isStrokeAccountedForInDimensions() ? N : (this.strokeUniform ? new U().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new U(e2.scaleX, e2.scaleY)).scalarMultiply(this.strokeWidth);
      i2 = t4.add(s3).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else
      i2 = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(t3, i2, s2);
  }
  drawControlsConnectingLines(t3, e2) {
    let s2 = false;
    t3.beginPath(), this.forEachControl((i2, r2) => {
      i2.withConnection && i2.getVisibility(this, r2) && (s2 = true, t3.moveTo(i2.x * e2.x, i2.y * e2.y), t3.lineTo(i2.x * e2.x + i2.offsetX, i2.y * e2.y + i2.offsetY));
    }), s2 && t3.stroke();
  }
  drawControls(t3) {
    let s2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    t3.save();
    const i2 = this.getCanvasRetinaScaling(), { cornerStrokeColor: r2, cornerDashArray: n2, cornerColor: o2 } = this, a2 = e({ cornerStrokeColor: r2, cornerDashArray: n2, cornerColor: o2 }, s2);
    t3.setTransform(i2, 0, 0, i2, 0, 0), t3.strokeStyle = t3.fillStyle = a2.cornerColor, this.transparentCorners || (t3.strokeStyle = a2.cornerStrokeColor), this._setLineDash(t3, a2.cornerDashArray), this.setCoords(), this.forEachControl((e2, s3) => {
      if (e2.getVisibility(this, s3)) {
        const i3 = this.oCoords[s3];
        e2.render(t3, i3.x, i3.y, a2, this);
      }
    }), t3.restore();
  }
  isControlVisible(t3) {
    return this.controls[t3] && this.controls[t3].getVisibility(this, t3);
  }
  setControlVisible(t3, e2) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t3] = e2;
  }
  setControlsVisibility() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    Object.entries(t3).forEach((t4) => {
      let [e2, s2] = t4;
      return this.setControlVisible(e2, s2);
    });
  }
  clearContextTop(t3) {
    if (!this.canvas)
      return;
    const e2 = this.canvas.contextTop;
    if (!e2)
      return;
    const s2 = this.canvas.viewportTransform;
    e2.save(), e2.transform(s2[0], s2[1], s2[2], s2[3], s2[4], s2[5]), this.transform(e2);
    const i2 = this.width + 4, r2 = this.height + 4;
    return e2.clearRect(-i2 / 2, -r2 / 2, i2, r2), t3 || e2.restore(), e2;
  }
  onDeselect(t3) {
    return false;
  }
  onSelect(t3) {
    return false;
  }
  shouldStartDragging(t3) {
    return false;
  }
  onDragStart(t3) {
    return false;
  }
  canDrop(t3) {
    return false;
  }
  renderDragSourceEffect(t3) {
  }
  renderDropTargetEffect(t3) {
  }
};
function ci(t3, e2) {
  return e2.forEach((e3) => {
    Object.getOwnPropertyNames(e3.prototype).forEach((s2) => {
      "constructor" !== s2 && Object.defineProperty(t3.prototype, s2, Object.getOwnPropertyDescriptor(e3.prototype, s2) || /* @__PURE__ */ Object.create(null));
    });
  }), t3;
}
s(hi, "ownDefaults", { noScaleCache: true, lockMovementX: false, lockMovementY: false, lockRotation: false, lockScalingX: false, lockScalingY: false, lockSkewingX: false, lockSkewingY: false, lockScalingFlip: false, cornerSize: 13, touchCornerSize: 24, transparentCorners: true, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: true, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: true, selectionBackgroundColor: "", selectable: true, evented: true, perPixelTargetFind: false, activeOn: "down", hoverCursor: null, moveCursor: null });
var li = class extends hi {
};
ci(li, [Te]), I.setClass(li), I.setClass(li, "object");
var ui = (t3, e2, s2, i2) => {
  const r2 = 2 * (i2 = Math.round(i2)) + 1, { data: n2 } = t3.getImageData(e2 - i2, s2 - i2, r2, r2);
  for (let t4 = 3; t4 < n2.length; t4 += 4) {
    if (n2[t4] > 0)
      return false;
  }
  return true;
};
var di = class {
  constructor(t3) {
    this.options = t3, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new U(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new U(1 / this.options.scaleX, 1 / this.options.scaleY) : new U(1, 1);
  }
  createSideVector(t3, e2) {
    const s2 = qe(t3, e2);
    return this.options.strokeUniform ? s2.multiply(this.scale) : s2;
  }
  projectOrthogonally(t3, e2, s2) {
    return this.applySkew(t3.add(this.calcOrthogonalProjection(t3, e2, s2)));
  }
  isSkewed() {
    return 0 !== this.options.skewX || 0 !== this.options.skewY;
  }
  applySkew(t3) {
    const e2 = new U(t3);
    return e2.y += e2.x * Math.tan(rt(this.options.skewY)), e2.x += e2.y * Math.tan(rt(this.options.skewX)), e2;
  }
  scaleUnitVector(t3, e2) {
    return t3.multiply(this.strokeUniformScalar).scalarMultiply(e2);
  }
};
var gi = new U();
var fi = class _fi extends di {
  static getOrthogonalRotationFactor(t3, e2) {
    const s2 = e2 ? Je(t3, e2) : Ze(t3);
    return Math.abs(s2) < w ? -1 : 1;
  }
  constructor(t3, e2, i2, r2) {
    super(r2), s(this, "AB", void 0), s(this, "AC", void 0), s(this, "alpha", void 0), s(this, "bisector", void 0), this.A = new U(t3), this.B = new U(e2), this.C = new U(i2), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = Je(this.AB, this.AC), this.bisector = Qe(Ne(this.AB.eq(gi) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(t3, e2) {
    let s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.strokeProjectionMagnitude;
    const i2 = this.createSideVector(t3, e2), r2 = $e(i2), n2 = _fi.getOrthogonalRotationFactor(r2, this.bisector);
    return this.scaleUnitVector(r2, s2 * n2);
  }
  projectBevel() {
    const t3 = [];
    return (this.alpha % S == 0 ? [this.B] : [this.B, this.C]).forEach((e2) => {
      t3.push(this.projectOrthogonally(this.A, e2)), t3.push(this.projectOrthogonally(this.A, e2, -this.strokeProjectionMagnitude));
    }), t3;
  }
  projectMiter() {
    const t3 = [], e2 = Math.abs(this.alpha), s2 = 1 / Math.sin(e2 / 2), i2 = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * s2), r2 = this.options.strokeUniform ? Ke(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return Ke(i2) / this.strokeProjectionMagnitude <= r2 && t3.push(this.applySkew(this.A.add(i2))), t3.push(...this.projectBevel()), t3;
  }
  projectRoundNoSkew(t3, e2) {
    const s2 = [], i2 = new U(_fi.getOrthogonalRotationFactor(this.bisector), _fi.getOrthogonalRotationFactor(new U(this.bisector.y, this.bisector.x)));
    return [new U(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i2), new U(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i2)].forEach((i3) => {
      ss(i3, t3, e2) && s2.push(this.A.add(i3));
    }), s2;
  }
  projectRoundWithSkew(t3, e2) {
    const s2 = [], { skewX: i2, skewY: r2, scaleX: n2, scaleY: o2, strokeUniform: a2 } = this.options, h2 = new U(Math.tan(rt(i2)), Math.tan(rt(r2))), c2 = this.strokeProjectionMagnitude, l2 = a2 ? c2 / o2 / Math.sqrt(1 / o2 ** 2 + 1 / n2 ** 2 * h2.y ** 2) : c2 / Math.sqrt(1 + h2.y ** 2), u2 = new U(Math.sqrt(Math.max(c2 ** 2 - l2 ** 2, 0)), l2), d2 = a2 ? c2 / Math.sqrt(1 + h2.x ** 2 * (1 / o2) ** 2 / (1 / n2 + 1 / n2 * h2.x * h2.y) ** 2) : c2 / Math.sqrt(1 + h2.x ** 2 / (1 + h2.x * h2.y) ** 2), g2 = new U(d2, Math.sqrt(Math.max(c2 ** 2 - d2 ** 2, 0)));
    return [g2, g2.scalarMultiply(-1), u2, u2.scalarMultiply(-1)].map((t4) => this.applySkew(a2 ? t4.multiply(this.strokeUniformScalar) : t4)).forEach((i3) => {
      ss(i3, t3, e2) && s2.push(this.applySkew(this.A).add(i3));
    }), s2;
  }
  projectRound() {
    const t3 = [];
    t3.push(...this.projectBevel());
    const e2 = this.alpha % S == 0, s2 = this.applySkew(this.A), i2 = t3[e2 ? 0 : 2].subtract(s2), r2 = t3[e2 ? 1 : 0].subtract(s2), n2 = e2 ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), o2 = ts(i2, n2) > 0, a2 = o2 ? i2 : r2, h2 = o2 ? r2 : i2;
    return this.isSkewed() ? t3.push(...this.projectRoundWithSkew(a2, h2)) : t3.push(...this.projectRoundNoSkew(a2, h2)), t3;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((t3) => ({ originPoint: this.A, projectedPoint: t3, angle: this.alpha, bisector: this.bisector }));
  }
};
var pi = class extends di {
  constructor(t3, e2, s2) {
    super(s2), this.A = new U(t3), this.T = new U(e2);
  }
  calcOrthogonalProjection(t3, e2) {
    let s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.strokeProjectionMagnitude;
    const i2 = this.createSideVector(t3, e2);
    return this.scaleUnitVector($e(i2), s2);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const t3 = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const e2 = new U(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      t3.push(this.applySkew(this.A.add(e2)), this.applySkew(this.A.subtract(e2)));
    } else
      t3.push(...new fi(this.A, this.T, this.T, this.options).projectRound());
    return t3;
  }
  projectSquare() {
    const t3 = [];
    if (this.A.eq(this.T)) {
      const e2 = new U(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      t3.push(this.A.add(e2), this.A.subtract(e2));
    } else {
      const e2 = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), s2 = this.scaleUnitVector(Qe(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), i2 = this.A.add(s2);
      t3.push(i2.add(e2), i2.subtract(e2));
    }
    return t3.map((t4) => this.applySkew(t4));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((t3) => ({ originPoint: this.A, projectedPoint: t3 }));
  }
};
var mi = function(t3, e2) {
  let s2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  const i2 = [];
  if (0 === t3.length)
    return i2;
  const r2 = t3.reduce((t4, e3) => (t4[t4.length - 1].eq(e3) || t4.push(new U(e3)), t4), [new U(t3[0])]);
  if (1 === r2.length)
    s2 = true;
  else if (!s2) {
    const t4 = r2[0], e3 = ((t5, e4) => {
      for (let s3 = t5.length - 1; s3 >= 0; s3--)
        if (e4(t5[s3], s3, t5))
          return s3;
      return -1;
    })(r2, (e4) => !e4.eq(t4));
    r2.splice(e3 + 1);
  }
  return r2.forEach((t4, r3, n2) => {
    let o2, a2;
    0 === r3 ? (a2 = n2[1], o2 = s2 ? t4 : n2[n2.length - 1]) : r3 === n2.length - 1 ? (o2 = n2[r3 - 1], a2 = s2 ? t4 : n2[0]) : (o2 = n2[r3 - 1], a2 = n2[r3 + 1]), s2 && 1 === n2.length ? i2.push(...new pi(t4, t4, e2).project()) : !s2 || 0 !== r3 && r3 !== n2.length - 1 ? i2.push(...new fi(t4, o2, a2, e2).project()) : i2.push(...new pi(t4, 0 === r3 ? a2 : o2, e2).project());
  }), i2;
};
var vi = (t3) => t3.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var yi = (t3) => {
  const e2 = [];
  for (let s2, i2 = 0; i2 < t3.length; i2++)
    false !== (s2 = _i(t3, i2)) && e2.push(s2);
  return e2;
};
var _i = (t3, e2) => {
  const s2 = t3.charCodeAt(e2);
  if (isNaN(s2))
    return "";
  if (s2 < 55296 || s2 > 57343)
    return t3.charAt(e2);
  if (55296 <= s2 && s2 <= 56319) {
    if (t3.length <= e2 + 1)
      throw "High surrogate without following low surrogate";
    const s3 = t3.charCodeAt(e2 + 1);
    if (56320 > s3 || s3 > 57343)
      throw "High surrogate without following low surrogate";
    return t3.charAt(e2) + t3.charAt(e2 + 1);
  }
  if (0 === e2)
    throw "Low surrogate without preceding high surrogate";
  const i2 = t3.charCodeAt(e2 - 1);
  if (55296 > i2 || i2 > 56319)
    throw "Low surrogate without preceding high surrogate";
  return false;
};
var xi = Object.freeze({ __proto__: null, capitalize: function(t3) {
  let e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
  return "".concat(t3.charAt(0).toUpperCase()).concat(e2 ? t3.slice(1) : t3.slice(1).toLowerCase());
}, escapeXml: vi, graphemeSplit: yi });
var Ci = function(t3, e2) {
  let s2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  return t3.fill !== e2.fill || t3.stroke !== e2.stroke || t3.strokeWidth !== e2.strokeWidth || t3.fontSize !== e2.fontSize || t3.fontFamily !== e2.fontFamily || t3.fontWeight !== e2.fontWeight || t3.fontStyle !== e2.fontStyle || t3.textBackgroundColor !== e2.textBackgroundColor || t3.deltaY !== e2.deltaY || s2 && (t3.overline !== e2.overline || t3.underline !== e2.underline || t3.linethrough !== e2.linethrough);
};
var bi = (t3, e2) => {
  const s2 = e2.split("\n"), i2 = [];
  let r2 = -1, n2 = {};
  t3 = Ss(t3);
  for (let e3 = 0; e3 < s2.length; e3++) {
    const o2 = yi(s2[e3]);
    if (t3[e3])
      for (let s3 = 0; s3 < o2.length; s3++) {
        r2++;
        const o3 = t3[e3][s3];
        o3 && Object.keys(o3).length > 0 && (Ci(n2, o3, true) ? i2.push({ start: r2, end: r2 + 1, style: o3 }) : i2[i2.length - 1].end++), n2 = o3 || {};
      }
    else
      r2 += o2.length, n2 = {};
  }
  return i2;
};
var wi = (t3, s2) => {
  if (!Array.isArray(t3))
    return Ss(t3);
  const i2 = s2.split(L), r2 = {};
  let n2 = -1, o2 = 0;
  for (let s3 = 0; s3 < i2.length; s3++) {
    const a2 = yi(i2[s3]);
    for (let i3 = 0; i3 < a2.length; i3++)
      n2++, t3[o2] && t3[o2].start <= n2 && n2 < t3[o2].end && (r2[s3] = r2[s3] || {}, r2[s3][i3] = e({}, t3[o2].style), n2 === t3[o2].end - 1 && o2++);
  }
  return r2;
};
var Si = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function Ti(t3, e2) {
  const s2 = t3.nodeName, i2 = t3.getAttribute("class"), r2 = t3.getAttribute("id"), n2 = "(?![a-zA-Z\\-]+)";
  let o2;
  if (o2 = new RegExp("^" + s2, "i"), e2 = e2.replace(o2, ""), r2 && e2.length && (o2 = new RegExp("#" + r2 + n2, "i"), e2 = e2.replace(o2, "")), i2 && e2.length) {
    const t4 = i2.split(" ");
    for (let s3 = t4.length; s3--; )
      o2 = new RegExp("\\." + t4[s3] + n2, "i"), e2 = e2.replace(o2, "");
  }
  return 0 === e2.length;
}
function Oi(t3, e2) {
  let s2 = true;
  const i2 = Ti(t3, e2.pop());
  return i2 && e2.length && (s2 = function(t4, e3) {
    let s3, i3 = true;
    for (; t4.parentElement && 1 === t4.parentElement.nodeType && e3.length; )
      i3 && (s3 = e3.pop()), i3 = Ti(t4 = t4.parentElement, s3);
    return 0 === e3.length;
  }(t3, e2)), i2 && s2 && 0 === e2.length;
}
var ki = (t3) => {
  var e2;
  return null !== (e2 = fs[t3]) && void 0 !== e2 ? e2 : t3;
};
var Di = new RegExp("(".concat(us, ")"), "gi");
var Mi = (t3) => t3.replace(Di, " $1 ").replace(/,/gi, " ").replace(/\s+/gi, " ");
var Pi;
var Ei;
var Ai;
var ji;
var Fi;
var Li;
var Ri;
var Bi = "(".concat(us, ")");
var Ii = String.raw(Pi || (Pi = r(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), Bi);
var Xi = String.raw(Ei || (Ei = r(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), Bi);
var Yi = String.raw(Ai || (Ai = r(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), Bi, Bi, Bi);
var Wi = String.raw(ji || (ji = r(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), Bi, Bi);
var Vi = String.raw(Fi || (Fi = r(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), Bi, Bi);
var zi = String.raw(Li || (Li = r(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), Bi, Bi, Bi, Bi, Bi, Bi);
var Hi = "(?:".concat(zi, "|").concat(Vi, "|").concat(Yi, "|").concat(Wi, "|").concat(Ii, "|").concat(Xi, ")");
var Gi = "(?:".concat(Hi, "*)");
var Ui = String.raw(Ri || (Ri = r(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), Gi);
var Ni = new RegExp(Ui);
var qi = new RegExp(Hi);
var Ki = new RegExp(Hi, "g");
function Ji(t3) {
  const e2 = [];
  if (!(t3 = Mi(t3).replace(/\s*([()])\s*/gi, "$1")) || t3 && !Ni.test(t3))
    return [...O];
  for (const s2 of t3.matchAll(Ki)) {
    const t4 = qi.exec(s2[0]);
    if (!t4)
      continue;
    let i2 = O;
    const r2 = t4.filter((t5) => !!t5), [, n2, ...o2] = r2, [a2, h2, c2, l2, u2, d2] = o2.map((t5) => parseFloat(t5));
    switch (n2) {
      case "translate":
        i2 = gt(a2, h2);
        break;
      case "rotate":
        i2 = ft({ angle: a2 }, { x: h2, y: c2 });
        break;
      case "scale":
        i2 = pt(a2, h2);
        break;
      case "skewX":
        i2 = vt(a2);
        break;
      case "skewY":
        i2 = yt(a2);
        break;
      case "matrix":
        i2 = [a2, h2, c2, l2, u2, d2];
    }
    e2.push(i2);
  }
  return lt(e2);
}
function Zi(t3, e2, s2, i2) {
  const r2 = Array.isArray(e2);
  let n2, o2 = e2;
  if ("fill" !== t3 && "stroke" !== t3 || e2 !== F) {
    if ("strokeUniform" === t3)
      return "non-scaling-stroke" === e2;
    if ("strokeDashArray" === t3)
      o2 = e2 === F ? null : e2.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if ("transformMatrix" === t3)
      o2 = s2 && s2.transformMatrix ? ct(s2.transformMatrix, Ji(e2)) : Ji(e2);
    else if ("visible" === t3)
      o2 = e2 !== F && "hidden" !== e2, s2 && false === s2.visible && (o2 = false);
    else if ("opacity" === t3)
      o2 = parseFloat(e2), s2 && void 0 !== s2.opacity && (o2 *= s2.opacity);
    else if ("textAnchor" === t3)
      o2 = "start" === e2 ? P : "end" === e2 ? j : M;
    else if ("charSpacing" === t3)
      n2 = Ft(e2, i2) / i2 * 1e3;
    else if ("paintFirst" === t3) {
      const t4 = e2.indexOf("fill"), s3 = e2.indexOf("stroke");
      o2 = "fill", (t4 > -1 && s3 > -1 && s3 < t4 || -1 === t4 && s3 > -1) && (o2 = "stroke");
    } else {
      if ("href" === t3 || "xlink:href" === t3 || "font" === t3)
        return e2;
      if ("imageSmoothing" === t3)
        return "optimizeQuality" === e2;
      n2 = r2 ? e2.map(Ft) : Ft(e2, i2);
    }
  } else
    o2 = "";
  return !r2 && isNaN(n2) ? o2 : n2;
}
function Qi(t3, e2) {
  const s2 = t3.match(gs);
  if (!s2)
    return;
  const i2 = s2[1], r2 = s2[3], n2 = s2[4], o2 = s2[5], a2 = s2[6];
  i2 && (e2.fontStyle = i2), r2 && (e2.fontWeight = isNaN(parseFloat(r2)) ? r2 : parseFloat(r2)), n2 && (e2.fontSize = Ft(n2)), a2 && (e2.fontFamily = a2), o2 && (e2.lineHeight = "normal" === o2 ? 1 : o2);
}
function $i(t3) {
  const e2 = {}, s2 = t3.getAttribute("style");
  return s2 ? ("string" == typeof s2 ? function(t4, e3) {
    t4.replace(/;\s*$/, "").split(";").forEach((t5) => {
      const [s3, i2] = t5.split(":");
      e3[s3.trim().toLowerCase()] = i2.trim();
    });
  }(s2, e2) : function(t4, e3) {
    Object.entries(t4).forEach((t5) => {
      let [s3, i2] = t5;
      void 0 !== i2 && (e3[s3.toLowerCase()] = i2);
    });
  }(s2, e2), e2) : e2;
}
var tr = { stroke: "strokeOpacity", fill: "fillOpacity" };
function er(t3, s2, i2) {
  if (!t3)
    return {};
  let r2, n2 = {}, o2 = k;
  t3.parentNode && _s.test(t3.parentNode.nodeName) && (n2 = er(t3.parentElement, s2, i2), n2.fontSize && (r2 = o2 = Ft(n2.fontSize)));
  const a2 = e(e(e({}, s2.reduce((e2, s3) => {
    const i3 = t3.getAttribute(s3);
    return i3 && (e2[s3] = i3), e2;
  }, {})), function(t4) {
    let s3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = {};
    for (const r3 in s3)
      Oi(t4, r3.split(" ")) && (i3 = e(e({}, i3), s3[r3]));
    return i3;
  }(t3, i2)), $i(t3));
  a2[ms] && t3.setAttribute(ms, a2[ms]), a2[ps] && (r2 = Ft(a2[ps], o2), a2[ps] = "".concat(r2));
  const h2 = {};
  for (const t4 in a2) {
    const e2 = ki(t4), s3 = Zi(e2, a2[t4], n2, r2);
    h2[e2] = s3;
  }
  h2 && h2.font && Qi(h2.font, h2);
  const c2 = e(e({}, n2), h2);
  return _s.test(t3.nodeName) ? c2 : function(t4) {
    const e2 = li.getDefaults();
    return Object.entries(tr).forEach((s3) => {
      let [i3, r3] = s3;
      if (void 0 === t4[r3] || "" === t4[i3])
        return;
      if (void 0 === t4[i3]) {
        if (!e2[i3])
          return;
        t4[i3] = e2[i3];
      }
      if (0 === t4[i3].indexOf("url("))
        return;
      const n3 = new At(t4[i3]);
      t4[i3] = n3.setAlpha(jt(n3.getAlpha() * t4[r3], 2)).toRgba();
    }), t4;
  }(c2);
}
var sr = ["left", "top", "width", "height", "visible"];
var ir = ["rx", "ry"];
var rr = class _rr extends li {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _rr.ownDefaults);
  }
  constructor(t3) {
    super(), Object.assign(this, _rr.ownDefaults), this.setOptions(t3), this._initRxRy();
  }
  _initRxRy() {
    const { rx: t3, ry: e2 } = this;
    t3 && !e2 ? this.ry = t3 : e2 && !t3 && (this.rx = e2);
  }
  _render(t3) {
    const { width: e2, height: s2 } = this, i2 = -e2 / 2, r2 = -s2 / 2, n2 = this.rx ? Math.min(this.rx, e2 / 2) : 0, o2 = this.ry ? Math.min(this.ry, s2 / 2) : 0, a2 = 0 !== n2 || 0 !== o2;
    t3.beginPath(), t3.moveTo(i2 + n2, r2), t3.lineTo(i2 + e2 - n2, r2), a2 && t3.bezierCurveTo(i2 + e2 - D * n2, r2, i2 + e2, r2 + D * o2, i2 + e2, r2 + o2), t3.lineTo(i2 + e2, r2 + s2 - o2), a2 && t3.bezierCurveTo(i2 + e2, r2 + s2 - D * o2, i2 + e2 - D * n2, r2 + s2, i2 + e2 - n2, r2 + s2), t3.lineTo(i2 + n2, r2 + s2), a2 && t3.bezierCurveTo(i2 + D * n2, r2 + s2, i2, r2 + s2 - D * o2, i2, r2 + s2 - o2), t3.lineTo(i2, r2 + o2), a2 && t3.bezierCurveTo(i2, r2 + D * o2, i2 + D * n2, r2, i2 + n2, r2), t3.closePath(), this._renderPaintInOrder(t3);
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return super.toObject([...ir, ...t3]);
  }
  _toSVG() {
    const { width: t3, height: e2, rx: s2, ry: i2 } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-t3 / 2, '" y="').concat(-e2 / 2, '" rx="').concat(s2, '" ry="').concat(i2, '" width="').concat(t3, '" height="').concat(e2, '" />\n')];
  }
  static async fromElement(t3, s2, r2) {
    const n2 = er(t3, this.ATTRIBUTE_NAMES, r2), { left: o2 = 0, top: a2 = 0, width: h2 = 0, height: c2 = 0, visible: l2 = true } = n2, u2 = i(n2, sr);
    return new this(e(e(e({}, s2), u2), {}, { left: o2, top: a2, width: h2, height: c2, visible: Boolean(l2 && h2 && c2) }));
  }
};
s(rr, "type", "Rect"), s(rr, "cacheProperties", [...Os, ...ir]), s(rr, "ownDefaults", { rx: 0, ry: 0 }), s(rr, "ATTRIBUTE_NAMES", [...Si, "x", "y", "rx", "ry", "width", "height"]), I.setClass(rr), I.setSVGClass(rr);
var nr = "initialization";
var or = "added";
var ar = "removed";
var hr = "imperative";
var cr = (t3, e2) => {
  const { strokeUniform: s2, strokeWidth: i2, width: r2, height: n2, group: o2 } = e2, a2 = o2 && o2 !== t3 ? le(o2.calcTransformMatrix(), t3.calcTransformMatrix()) : null, h2 = a2 ? e2.getRelativeCenterPoint().transform(a2) : e2.getRelativeCenterPoint(), c2 = !e2.isStrokeAccountedForInDimensions(), l2 = s2 && c2 ? de(new U(i2, i2), void 0, t3.calcTransformMatrix()) : N, u2 = !s2 && c2 ? i2 : 0, d2 = ce(r2 + u2, n2 + u2, lt([a2, e2.calcOwnMatrix()], true)).add(l2).scalarDivide(2);
  return [h2.subtract(d2), h2.add(d2)];
};
var lr = class {
  calcLayoutResult(t3, e2) {
    if (this.shouldPerformLayout(t3))
      return this.calcBoundingBox(e2, t3);
  }
  shouldPerformLayout(t3) {
    return t3.type === nr || t3.type === hr || !!t3.prevStrategy && t3.strategy !== t3.prevStrategy;
  }
  shouldLayoutClipPath(t3) {
    let { type: e2, target: { clipPath: s2 } } = t3;
    return e2 !== nr && s2 && !s2.absolutePositioned;
  }
  getInitialSize(t3, e2) {
    return e2.size;
  }
  calcBoundingBox(t3, e2) {
    if (e2.type === hr && e2.overrides)
      return e2.overrides;
    if (0 === t3.length)
      return;
    const { target: s2 } = e2, { left: i2, top: r2, width: n2, height: o2 } = ie(t3.map((t4) => cr(s2, t4)).reduce((t4, e3) => t4.concat(e3), [])), a2 = new U(n2, o2), h2 = new U(i2, r2).add(a2.scalarDivide(2));
    if (e2.type === nr) {
      const t4 = this.getInitialSize(e2, { size: a2, center: h2 });
      return { center: h2, relativeCorrection: new U(0, 0), size: t4 };
    }
    return { center: h2.transform(s2.calcOwnMatrix()), size: a2 };
  }
};
s(lr, "type", "strategy");
var ur = class extends lr {
  shouldPerformLayout(t3) {
    return true;
  }
};
s(ur, "type", "fit-content"), I.setClass(ur);
var dr = ["strategy"];
var gr = ["target", "strategy", "bubbles", "prevStrategy"];
var fr = "layoutManager";
var pr = class {
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ur();
    s(this, "strategy", void 0), this.strategy = t3, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(t3) {
    const s2 = e(e({ bubbles: true, strategy: this.strategy }, t3), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = false;
    } });
    this.onBeforeLayout(s2);
    const i2 = this.getLayoutResult(s2);
    i2 && this.commitLayout(s2, i2), this.onAfterLayout(s2, i2), this._prevLayoutStrategy = s2.strategy;
  }
  attachHandlers(t3, e2) {
    const { target: s2 } = e2;
    return ["modified", "moving", "resizing", "rotating", "scaling", "skewing", "changed", "modifyPoly"].map((e3) => t3.on(e3, (t4) => this.performLayout("modified" === e3 ? { type: "object_modified", trigger: e3, e: t4, target: s2 } : { type: "object_modifying", trigger: e3, e: t4, target: s2 })));
  }
  subscribe(t3, e2) {
    this.unsubscribe(t3, e2);
    const s2 = this.attachHandlers(t3, e2);
    this._subscriptions.set(t3, s2);
  }
  unsubscribe(t3, e2) {
    (this._subscriptions.get(t3) || []).forEach((t4) => t4()), this._subscriptions.delete(t3);
  }
  unsubscribeTargets(t3) {
    t3.targets.forEach((e2) => this.unsubscribe(e2, t3));
  }
  subscribeTargets(t3) {
    t3.targets.forEach((e2) => this.subscribe(e2, t3));
  }
  onBeforeLayout(t3) {
    const { target: s2, type: r2 } = t3, { canvas: n2 } = s2;
    if (r2 === nr || r2 === or ? this.subscribeTargets(t3) : r2 === ar && this.unsubscribeTargets(t3), s2.fire("layout:before", { context: t3 }), n2 && n2.fire("object:layout:before", { target: s2, context: t3 }), r2 === hr && t3.deep) {
      const r3 = i(t3, dr);
      s2.forEachObject((t4) => t4.layoutManager && t4.layoutManager.performLayout(e(e({}, r3), {}, { bubbles: false, target: t4 })));
    }
  }
  getLayoutResult(t3) {
    const { target: e2 } = t3, s2 = t3.strategy.calcLayoutResult(t3, e2.getObjects());
    if (!s2)
      return;
    const i2 = t3.type === nr ? new U() : e2.getRelativeCenterPoint(), { center: r2, correction: n2 = new U(), relativeCorrection: o2 = new U() } = s2, a2 = i2.subtract(r2).add(n2).transform(t3.type === nr ? O : ht(e2.calcOwnMatrix()), true).add(o2);
    return { result: s2, prevCenter: i2, nextCenter: r2, offset: a2 };
  }
  commitLayout(t3, e2) {
    const { target: s2 } = t3, { result: { size: i2 }, nextCenter: r2 } = e2;
    var n2, o2;
    (s2.set({ width: i2.x, height: i2.y }), this.layoutObjects(t3, e2), t3.type === nr) ? s2.set({ left: null !== (n2 = t3.x) && void 0 !== n2 ? n2 : r2.x + i2.x * me(s2.originX), top: null !== (o2 = t3.y) && void 0 !== o2 ? o2 : r2.y + i2.y * me(s2.originY) }) : (s2.setPositionByOrigin(r2, M, M), s2.setCoords(), s2.set("dirty", true));
  }
  layoutObjects(t3, e2) {
    const { target: s2 } = t3;
    s2.forEachObject((i2) => {
      i2.group === s2 && this.layoutObject(t3, e2, i2);
    }), t3.strategy.shouldLayoutClipPath(t3) && this.layoutObject(t3, e2, s2.clipPath);
  }
  layoutObject(t3, e2, s2) {
    let { offset: i2 } = e2;
    s2.set({ left: s2.left + i2.x, top: s2.top + i2.y });
  }
  onAfterLayout(t3, s2) {
    const { target: r2, strategy: n2, bubbles: o2, prevStrategy: a2 } = t3, h2 = i(t3, gr), { canvas: c2 } = r2;
    r2.fire("layout:after", { context: t3, result: s2 }), c2 && c2.fire("object:layout:after", { context: t3, result: s2, target: r2 });
    const l2 = r2.parent;
    o2 && null != l2 && l2.layoutManager && ((h2.path || (h2.path = [])).push(r2), l2.layoutManager.performLayout(e(e({}, h2), {}, { target: l2 }))), r2.set("dirty", true);
  }
  dispose() {
    this._subscriptions.forEach((t3) => t3.forEach((t4) => t4())), this._subscriptions.clear();
  }
  toObject() {
    return { type: fr, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
};
I.setClass(pr, fr);
var mr = ["type", "objects", "layoutManager"];
var vr = class extends pr {
  performLayout() {
  }
};
var yr = class _yr extends K(li) {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _yr.ownDefaults);
  }
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(), s(this, "_activeObjects", []), s(this, "__objectSelectionTracker", void 0), s(this, "__objectSelectionDisposer", void 0), Object.assign(this, _yr.ownDefaults), this.setOptions(e2), this._objects = [...t3], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, true), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, false), this.forEachObject((t4) => {
      this.enterGroup(t4, false);
    }), this.layoutManager = e2.layoutManager || new pr(), this.layoutManager.performLayout({ type: nr, target: this, targets: [...t3], x: e2.left, y: e2.top });
  }
  canEnterGroup(t3) {
    return t3 === this || this.isDescendantOf(t3) ? (h("error", "Group: circular object trees are not supported, this call has no effect"), false) : -1 === this._objects.indexOf(t3) || (h("error", "Group: duplicate objects are not supported inside group, this call has no effect"), false);
  }
  _filterObjectsBeforeEnteringGroup(t3) {
    return t3.filter((t4, e2, s2) => this.canEnterGroup(t4) && s2.indexOf(t4) === e2);
  }
  add() {
    for (var t3 = arguments.length, e2 = new Array(t3), s2 = 0; s2 < t3; s2++)
      e2[s2] = arguments[s2];
    const i2 = this._filterObjectsBeforeEnteringGroup(e2), r2 = super.add(...i2);
    return this._onAfterObjectsChange(or, i2), r2;
  }
  insertAt(t3) {
    for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), i2 = 1; i2 < e2; i2++)
      s2[i2 - 1] = arguments[i2];
    const r2 = this._filterObjectsBeforeEnteringGroup(s2), n2 = super.insertAt(t3, ...r2);
    return this._onAfterObjectsChange(or, r2), n2;
  }
  remove() {
    const t3 = super.remove(...arguments);
    return this._onAfterObjectsChange(ar, t3), t3;
  }
  _onObjectAdded(t3) {
    this.enterGroup(t3, true), this.fire("object:added", { target: t3 }), t3.fire("added", { target: this });
  }
  _onObjectRemoved(t3, e2) {
    this.exitGroup(t3, e2), this.fire("object:removed", { target: t3 }), t3.fire("removed", { target: this });
  }
  _onAfterObjectsChange(t3, e2) {
    this.layoutManager.performLayout({ type: t3, targets: e2, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", true);
  }
  _set(t3, e2) {
    const s2 = this[t3];
    return super._set(t3, e2), "canvas" === t3 && s2 !== e2 && (this._objects || []).forEach((s3) => {
      s3._set(t3, e2);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(t3, e2) {
    let { target: s2 } = e2;
    const i2 = this._activeObjects;
    if (t3)
      i2.push(s2), this._set("dirty", true);
    else if (i2.length > 0) {
      const t4 = i2.indexOf(s2);
      t4 > -1 && (i2.splice(t4, 1), this._set("dirty", true));
    }
  }
  _watchObject(t3, e2) {
    t3 && this._watchObject(false, e2), t3 ? (e2.on("selected", this.__objectSelectionTracker), e2.on("deselected", this.__objectSelectionDisposer)) : (e2.off("selected", this.__objectSelectionTracker), e2.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(t3, e2) {
    t3.group && t3.group.remove(t3), t3._set("parent", this), this._enterGroup(t3, e2);
  }
  _enterGroup(t3, e2) {
    e2 && oe(t3, ct(ht(this.calcTransformMatrix()), t3.calcTransformMatrix())), this._shouldSetNestedCoords() && t3.setCoords(), t3._set("group", this), t3._set("canvas", this.canvas), this._watchObject(true, t3);
    const s2 = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    s2 && (s2 === t3 || t3.isDescendantOf(s2)) && this._activeObjects.push(t3);
  }
  exitGroup(t3, e2) {
    this._exitGroup(t3, e2), t3._set("parent", void 0), t3._set("canvas", void 0);
  }
  _exitGroup(t3, e2) {
    t3._set("group", void 0), e2 || (oe(t3, ct(this.calcTransformMatrix(), t3.calcTransformMatrix())), t3.setCoords()), this._watchObject(false, t3);
    const s2 = this._activeObjects.length > 0 ? this._activeObjects.indexOf(t3) : -1;
    s2 > -1 && this._activeObjects.splice(s2, 1);
  }
  shouldCache() {
    const t3 = li.prototype.shouldCache.call(this);
    if (t3) {
      for (let t4 = 0; t4 < this._objects.length; t4++)
        if (this._objects[t4].willDrawShadow())
          return this.ownCaching = false, false;
    }
    return t3;
  }
  willDrawShadow() {
    if (super.willDrawShadow())
      return true;
    for (let t3 = 0; t3 < this._objects.length; t3++)
      if (this._objects[t3].willDrawShadow())
        return true;
    return false;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(t3) {
    this._renderBackground(t3);
    for (let s2 = 0; s2 < this._objects.length; s2++) {
      var e2;
      null !== (e2 = this.canvas) && void 0 !== e2 && e2.preserveObjectStacking && this._objects[s2].group !== this ? (t3.save(), t3.transform(...ht(this.calcTransformMatrix())), this._objects[s2].render(t3), t3.restore()) : this._objects[s2].group === this && this._objects[s2].render(t3);
    }
    this._drawClipPath(t3, this.clipPath);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((t3) => t3.setCoords());
  }
  triggerLayout() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.layoutManager.performLayout(e({ target: this, type: hr }, t3));
  }
  render(t3) {
    this._transformDone = true, super.render(t3), this._transformDone = false;
  }
  __serializeObjects(t3, e2) {
    const s2 = this.includeDefaultValues;
    return this._objects.filter(function(t4) {
      return !t4.excludeFromExport;
    }).map(function(i2) {
      const r2 = i2.includeDefaultValues;
      i2.includeDefaultValues = s2;
      const n2 = i2[t3 || "toObject"](e2);
      return i2.includeDefaultValues = r2, n2;
    });
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const s2 = this.layoutManager.toObject();
    return e(e(e({}, super.toObject(["subTargetCheck", "interactive", ...t3])), "fit-content" !== s2.strategy || this.includeDefaultValues ? { layoutManager: s2 } : {}), {}, { objects: this.__serializeObjects("toObject", t3) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((t3) => {
      this._watchObject(false, t3), t3.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(t3) {
    if (!this.backgroundColor)
      return "";
    const e2 = rr.prototype._toSVG.call(this), s2 = e2.indexOf("COMMON_PARTS");
    e2[s2] = 'for="group" ';
    const i2 = e2.join("");
    return t3 ? t3(i2) : i2;
  }
  _toSVG(t3) {
    const e2 = ["<g ", "COMMON_PARTS", " >\n"], s2 = this._createSVGBgRect(t3);
    s2 && e2.push("		", s2);
    for (let s3 = 0; s3 < this._objects.length; s3++)
      e2.push("		", this._objects[s3].toSVG(t3));
    return e2.push("</g>\n"), e2;
  }
  getSvgStyles() {
    const t3 = void 0 !== this.opacity && 1 !== this.opacity ? "opacity: ".concat(this.opacity, ";") : "", e2 = this.visible ? "" : " visibility: hidden;";
    return [t3, this.getSvgFilter(), e2].join("");
  }
  toClipPathSVG(t3) {
    const e2 = [], s2 = this._createSVGBgRect(t3);
    s2 && e2.push("	", s2);
    for (let s3 = 0; s3 < this._objects.length; s3++)
      e2.push("	", this._objects[s3].toClipPathSVG(t3));
    return this._createBaseClipPathSVGMarkup(e2, { reviver: t3 });
  }
  static fromObject(t3, s2) {
    let { type: r2, objects: n2 = [], layoutManager: o2 } = t3, a2 = i(t3, mr);
    return Promise.all([bt(n2, s2), wt(a2, s2)]).then((t4) => {
      let [s3, i2] = t4;
      const r3 = new this(s3, e(e(e({}, a2), i2), {}, { layoutManager: new vr() }));
      if (o2) {
        const t5 = I.getClass(o2.type), e2 = I.getClass(o2.strategy);
        r3.layoutManager = new t5(new e2());
      } else
        r3.layoutManager = new pr();
      return r3.layoutManager.subscribeTargets({ type: nr, target: r3, targets: r3.getObjects() }), r3.setCoords(), r3;
    });
  }
};
s(yr, "type", "Group"), s(yr, "ownDefaults", { strokeWidth: 0, subTargetCheck: false, interactive: false }), I.setClass(yr);
var _r = (t3, e2) => Math.min(e2.width / t3.width, e2.height / t3.height);
var xr = (t3, e2) => Math.max(e2.width / t3.width, e2.height / t3.height);
var Cr;
var br = "(".concat(us, ")");
var wr = "(M) (?:".concat(br, " ").concat(br, " ?)+");
var Sr = "(L) (?:".concat(br, " ").concat(br, " ?)+");
var Tr = "(H) (?:".concat(br, " ?)+");
var Or = "(V) (?:".concat(br, " ?)+");
var kr = String.raw(Cr || (Cr = r(["(Z)s*"], ["(Z)\\s*"])));
var Dr = "(C) (?:".concat(br, " ").concat(br, " ").concat(br, " ").concat(br, " ").concat(br, " ").concat(br, " ?)+");
var Mr = "(S) (?:".concat(br, " ").concat(br, " ").concat(br, " ").concat(br, " ?)+");
var Pr = "(Q) (?:".concat(br, " ").concat(br, " ").concat(br, " ").concat(br, " ?)+");
var Er = "(T) (?:".concat(br, " ").concat(br, " ?)+");
var Ar = "(A) (?:".concat(br, " ").concat(br, " ").concat(br, " ([01]) ?([01]) ").concat(br, " ").concat(br, " ?)+");
var jr = "(?:(?:".concat(wr, ")") + "|(?:".concat(Sr, ")") + "|(?:".concat(Tr, ")") + "|(?:".concat(Or, ")") + "|(?:".concat(kr, ")") + "|(?:".concat(Dr, ")") + "|(?:".concat(Mr, ")") + "|(?:".concat(Pr, ")") + "|(?:".concat(Er, ")") + "|(?:".concat(Ar, "))");
var Fr = { m: "l", M: "L" };
var Lr = (t3, e2, s2, i2, r2, n2, o2, a2, h2, c2, l2) => {
  const u2 = H(t3), d2 = G(t3), g2 = H(e2), f2 = G(e2), p2 = s2 * r2 * g2 - i2 * n2 * f2 + o2, m2 = i2 * r2 * g2 + s2 * n2 * f2 + a2;
  return ["C", c2 + h2 * (-s2 * r2 * d2 - i2 * n2 * u2), l2 + h2 * (-i2 * r2 * d2 + s2 * n2 * u2), p2 + h2 * (s2 * r2 * f2 + i2 * n2 * g2), m2 + h2 * (i2 * r2 * f2 - s2 * n2 * g2), p2, m2];
};
var Rr = (t3, e2, s2, i2) => {
  const r2 = Math.atan2(e2, t3), n2 = Math.atan2(i2, s2);
  return n2 >= r2 ? n2 - r2 : 2 * Math.PI - (r2 - n2);
};
function Br(t3, e2, s2, i2, r2, n2, o2, h2) {
  let c2;
  if (a.cachesBoundsOfCurve && (c2 = [...arguments].join(), x.boundsOfCurveCache[c2]))
    return x.boundsOfCurveCache[c2];
  const l2 = Math.sqrt, u2 = Math.abs, d2 = [], g2 = [[0, 0], [0, 0]];
  let f2 = 6 * t3 - 12 * s2 + 6 * r2, p2 = -3 * t3 + 9 * s2 - 9 * r2 + 3 * o2, m2 = 3 * s2 - 3 * t3;
  for (let t4 = 0; t4 < 2; ++t4) {
    if (t4 > 0 && (f2 = 6 * e2 - 12 * i2 + 6 * n2, p2 = -3 * e2 + 9 * i2 - 9 * n2 + 3 * h2, m2 = 3 * i2 - 3 * e2), u2(p2) < 1e-12) {
      if (u2(f2) < 1e-12)
        continue;
      const t5 = -m2 / f2;
      0 < t5 && t5 < 1 && d2.push(t5);
      continue;
    }
    const s3 = f2 * f2 - 4 * m2 * p2;
    if (s3 < 0)
      continue;
    const r3 = l2(s3), o3 = (-f2 + r3) / (2 * p2);
    0 < o3 && o3 < 1 && d2.push(o3);
    const a2 = (-f2 - r3) / (2 * p2);
    0 < a2 && a2 < 1 && d2.push(a2);
  }
  let v2 = d2.length;
  const y2 = v2, _2 = Wr(t3, e2, s2, i2, r2, n2, o2, h2);
  for (; v2--; ) {
    const { x: t4, y: e3 } = _2(d2[v2]);
    g2[0][v2] = t4, g2[1][v2] = e3;
  }
  g2[0][y2] = t3, g2[1][y2] = e2, g2[0][y2 + 1] = o2, g2[1][y2 + 1] = h2;
  const C2 = [new U(Math.min(...g2[0]), Math.min(...g2[1])), new U(Math.max(...g2[0]), Math.max(...g2[1]))];
  return a.cachesBoundsOfCurve && (x.boundsOfCurveCache[c2] = C2), C2;
}
var Ir = (t3, e2, s2) => {
  let [i2, r2, n2, o2, a2, h2, c2, l2] = s2;
  const u2 = ((t4, e3, s3, i3, r3, n3, o3) => {
    if (0 === s3 || 0 === i3)
      return [];
    let a3 = 0, h3 = 0, c3 = 0;
    const l3 = Math.PI, u3 = o3 * T, d2 = G(u3), g2 = H(u3), f2 = 0.5 * (-g2 * t4 - d2 * e3), p2 = 0.5 * (-g2 * e3 + d2 * t4), m2 = s3 ** 2, v2 = i3 ** 2, y2 = p2 ** 2, _2 = f2 ** 2, x2 = m2 * v2 - m2 * y2 - v2 * _2;
    let C2 = Math.abs(s3), b2 = Math.abs(i3);
    if (x2 < 0) {
      const t5 = Math.sqrt(1 - x2 / (m2 * v2));
      C2 *= t5, b2 *= t5;
    } else
      c3 = (r3 === n3 ? -1 : 1) * Math.sqrt(x2 / (m2 * y2 + v2 * _2));
    const w2 = c3 * C2 * p2 / b2, S2 = -c3 * b2 * f2 / C2, O2 = g2 * w2 - d2 * S2 + 0.5 * t4, k2 = d2 * w2 + g2 * S2 + 0.5 * e3;
    let D2 = Rr(1, 0, (f2 - w2) / C2, (p2 - S2) / b2), M2 = Rr((f2 - w2) / C2, (p2 - S2) / b2, (-f2 - w2) / C2, (-p2 - S2) / b2);
    0 === n3 && M2 > 0 ? M2 -= 2 * l3 : 1 === n3 && M2 < 0 && (M2 += 2 * l3);
    const P2 = Math.ceil(Math.abs(M2 / l3 * 2)), E2 = new Array(P2), A2 = M2 / P2, j2 = 8 / 3 * Math.sin(A2 / 4) * Math.sin(A2 / 4) / Math.sin(A2 / 2);
    let F2 = D2 + A2;
    for (let t5 = 0; t5 < P2; t5++)
      E2[t5] = Lr(D2, F2, g2, d2, C2, b2, O2, k2, j2, a3, h3), a3 = E2[t5][5], h3 = E2[t5][6], D2 = F2, F2 += A2;
    return E2;
  })(c2 - t3, l2 - e2, r2, n2, a2, h2, o2);
  for (let s3 = 0, i3 = u2.length; s3 < i3; s3++)
    u2[s3][1] += t3, u2[s3][2] += e2, u2[s3][3] += t3, u2[s3][4] += e2, u2[s3][5] += t3, u2[s3][6] += e2;
  return u2;
};
var Xr = (t3) => {
  let e2 = 0, s2 = 0, i2 = 0, r2 = 0;
  const n2 = [];
  let o2, a2 = 0, h2 = 0;
  for (const c2 of t3) {
    const t4 = [...c2];
    let l2;
    switch (t4[0]) {
      case "l":
        t4[1] += e2, t4[2] += s2;
      case "L":
        e2 = t4[1], s2 = t4[2], l2 = ["L", e2, s2];
        break;
      case "h":
        t4[1] += e2;
      case "H":
        e2 = t4[1], l2 = ["L", e2, s2];
        break;
      case "v":
        t4[1] += s2;
      case "V":
        s2 = t4[1], l2 = ["L", e2, s2];
        break;
      case "m":
        t4[1] += e2, t4[2] += s2;
      case "M":
        e2 = t4[1], s2 = t4[2], i2 = t4[1], r2 = t4[2], l2 = ["M", e2, s2];
        break;
      case "c":
        t4[1] += e2, t4[2] += s2, t4[3] += e2, t4[4] += s2, t4[5] += e2, t4[6] += s2;
      case "C":
        a2 = t4[3], h2 = t4[4], e2 = t4[5], s2 = t4[6], l2 = ["C", t4[1], t4[2], a2, h2, e2, s2];
        break;
      case "s":
        t4[1] += e2, t4[2] += s2, t4[3] += e2, t4[4] += s2;
      case "S":
        "C" === o2 ? (a2 = 2 * e2 - a2, h2 = 2 * s2 - h2) : (a2 = e2, h2 = s2), e2 = t4[3], s2 = t4[4], l2 = ["C", a2, h2, t4[1], t4[2], e2, s2], a2 = l2[3], h2 = l2[4];
        break;
      case "q":
        t4[1] += e2, t4[2] += s2, t4[3] += e2, t4[4] += s2;
      case "Q":
        a2 = t4[1], h2 = t4[2], e2 = t4[3], s2 = t4[4], l2 = ["Q", a2, h2, e2, s2];
        break;
      case "t":
        t4[1] += e2, t4[2] += s2;
      case "T":
        "Q" === o2 ? (a2 = 2 * e2 - a2, h2 = 2 * s2 - h2) : (a2 = e2, h2 = s2), e2 = t4[1], s2 = t4[2], l2 = ["Q", a2, h2, e2, s2];
        break;
      case "a":
        t4[6] += e2, t4[7] += s2;
      case "A":
        Ir(e2, s2, t4).forEach((t5) => n2.push(t5)), e2 = t4[6], s2 = t4[7];
        break;
      case "z":
      case "Z":
        e2 = i2, s2 = r2, l2 = ["Z"];
    }
    l2 ? (n2.push(l2), o2 = l2[0]) : o2 = "";
  }
  return n2;
};
var Yr = (t3, e2, s2, i2) => Math.sqrt((s2 - t3) ** 2 + (i2 - e2) ** 2);
var Wr = (t3, e2, s2, i2, r2, n2, o2, a2) => (h2) => {
  const c2 = h2 ** 3, l2 = ((t4) => 3 * t4 ** 2 * (1 - t4))(h2), u2 = ((t4) => 3 * t4 * (1 - t4) ** 2)(h2), d2 = ((t4) => (1 - t4) ** 3)(h2);
  return new U(o2 * c2 + r2 * l2 + s2 * u2 + t3 * d2, a2 * c2 + n2 * l2 + i2 * u2 + e2 * d2);
};
var Vr = (t3) => t3 ** 2;
var zr = (t3) => 2 * t3 * (1 - t3);
var Hr = (t3) => (1 - t3) ** 2;
var Gr = (t3, e2, s2, i2, r2, n2, o2, a2) => (h2) => {
  const c2 = Vr(h2), l2 = zr(h2), u2 = Hr(h2), d2 = 3 * (u2 * (s2 - t3) + l2 * (r2 - s2) + c2 * (o2 - r2)), g2 = 3 * (u2 * (i2 - e2) + l2 * (n2 - i2) + c2 * (a2 - n2));
  return Math.atan2(g2, d2);
};
var Ur = (t3, e2, s2, i2, r2, n2) => (o2) => {
  const a2 = Vr(o2), h2 = zr(o2), c2 = Hr(o2);
  return new U(r2 * a2 + s2 * h2 + t3 * c2, n2 * a2 + i2 * h2 + e2 * c2);
};
var Nr = (t3, e2, s2, i2, r2, n2) => (o2) => {
  const a2 = 1 - o2, h2 = 2 * (a2 * (s2 - t3) + o2 * (r2 - s2)), c2 = 2 * (a2 * (i2 - e2) + o2 * (n2 - i2));
  return Math.atan2(c2, h2);
};
var qr = (t3, e2, s2) => {
  let i2 = new U(e2, s2), r2 = 0;
  for (let e3 = 1; e3 <= 100; e3 += 1) {
    const s3 = t3(e3 / 100);
    r2 += Yr(i2.x, i2.y, s3.x, s3.y), i2 = s3;
  }
  return r2;
};
var Kr = (t3, s2) => {
  let i2, r2 = 0, n2 = 0, o2 = { x: t3.x, y: t3.y }, a2 = e({}, o2), h2 = 0.01, c2 = 0;
  const l2 = t3.iterator, u2 = t3.angleFinder;
  for (; n2 < s2 && h2 > 1e-4; )
    a2 = l2(r2), c2 = r2, i2 = Yr(o2.x, o2.y, a2.x, a2.y), i2 + n2 > s2 ? (r2 -= h2, h2 /= 2) : (o2 = a2, r2 += h2, n2 += i2);
  return e(e({}, a2), {}, { angle: u2(c2) });
};
var Jr = (t3) => {
  let e2, s2, i2 = 0, r2 = 0, n2 = 0, o2 = 0, a2 = 0;
  const h2 = [];
  for (const c2 of t3) {
    const t4 = { x: r2, y: n2, command: c2[0], length: 0 };
    switch (c2[0]) {
      case "M":
        s2 = t4, s2.x = o2 = r2 = c2[1], s2.y = a2 = n2 = c2[2];
        break;
      case "L":
        s2 = t4, s2.length = Yr(r2, n2, c2[1], c2[2]), r2 = c2[1], n2 = c2[2];
        break;
      case "C":
        e2 = Wr(r2, n2, c2[1], c2[2], c2[3], c2[4], c2[5], c2[6]), s2 = t4, s2.iterator = e2, s2.angleFinder = Gr(r2, n2, c2[1], c2[2], c2[3], c2[4], c2[5], c2[6]), s2.length = qr(e2, r2, n2), r2 = c2[5], n2 = c2[6];
        break;
      case "Q":
        e2 = Ur(r2, n2, c2[1], c2[2], c2[3], c2[4]), s2 = t4, s2.iterator = e2, s2.angleFinder = Nr(r2, n2, c2[1], c2[2], c2[3], c2[4]), s2.length = qr(e2, r2, n2), r2 = c2[3], n2 = c2[4];
        break;
      case "Z":
        s2 = t4, s2.destX = o2, s2.destY = a2, s2.length = Yr(r2, n2, o2, a2), r2 = o2, n2 = a2;
    }
    i2 += s2.length, h2.push(s2);
  }
  return h2.push({ length: i2, x: r2, y: n2 }), h2;
};
var Zr = function(t3, s2) {
  let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Jr(t3), r2 = 0;
  for (; s2 - i2[r2].length > 0 && r2 < i2.length - 2; )
    s2 -= i2[r2].length, r2++;
  const n2 = i2[r2], o2 = s2 / n2.length, a2 = t3[r2];
  switch (n2.command) {
    case "M":
      return { x: n2.x, y: n2.y, angle: 0 };
    case "Z":
      return e(e({}, new U(n2.x, n2.y).lerp(new U(n2.destX, n2.destY), o2)), {}, { angle: Math.atan2(n2.destY - n2.y, n2.destX - n2.x) });
    case "L":
      return e(e({}, new U(n2.x, n2.y).lerp(new U(a2[1], a2[2]), o2)), {}, { angle: Math.atan2(a2[2] - n2.y, a2[1] - n2.x) });
    case "C":
    case "Q":
      return Kr(n2, s2);
  }
};
var Qr = new RegExp(jr, "gi");
var $r = new RegExp(jr, "i");
var tn = (t3) => {
  t3 = Mi(t3);
  const e2 = [];
  for (let [s2] of t3.matchAll(Qr)) {
    const t4 = [];
    let i2;
    do {
      if (i2 = $r.exec(s2), !i2)
        break;
      const e3 = i2.filter((t5) => t5);
      e3.shift();
      const r2 = e3.map((t5) => {
        const e4 = Number.parseFloat(t5);
        return Number.isNaN(e4) ? t5 : e4;
      });
      if (t4.push(r2), e3.length <= 1)
        break;
      e3.shift(), s2 = s2.replace(new RegExp("".concat(e3.join(" ?"), " ?$")), "");
    } while (i2);
    t4.reverse().forEach((t5, s3) => {
      const i3 = Fr[t5[0]];
      s3 > 0 && ("l" == i3 || "L" == i3) && (t5[0] = i3), e2.push(t5);
    });
  }
  return e2;
};
var en = function(t3) {
  let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, s2 = new U(t3[0]), i2 = new U(t3[1]), r2 = 1, n2 = 0;
  const o2 = [], a2 = t3.length, h2 = a2 > 2;
  let c2;
  for (h2 && (r2 = t3[2].x < i2.x ? -1 : t3[2].x === i2.x ? 0 : 1, n2 = t3[2].y < i2.y ? -1 : t3[2].y === i2.y ? 0 : 1), o2.push(["M", s2.x - r2 * e2, s2.y - n2 * e2]), c2 = 1; c2 < a2; c2++) {
    if (!s2.eq(i2)) {
      const t4 = s2.midPointFrom(i2);
      o2.push(["Q", s2.x, s2.y, t4.x, t4.y]);
    }
    s2 = t3[c2], c2 + 1 < t3.length && (i2 = t3[c2 + 1]);
  }
  return h2 && (r2 = s2.x > t3[c2 - 2].x ? 1 : s2.x === t3[c2 - 2].x ? 0 : -1, n2 = s2.y > t3[c2 - 2].y ? 1 : s2.y === t3[c2 - 2].y ? 0 : -1), o2.push(["L", s2.x + r2 * e2, s2.y + n2 * e2]), o2;
};
var sn = (t3, e2) => t3.map((t4) => t4.map((t5, s2) => 0 === s2 || void 0 === e2 ? t5 : jt(t5, e2)).join(" ")).join(" ");
function rn(t3) {
  let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const s2 = e2.onComplete || b, i2 = new (y()).XMLHttpRequest(), r2 = e2.signal, n2 = function() {
    i2.abort();
  }, o2 = function() {
    r2 && r2.removeEventListener("abort", n2), i2.onerror = i2.ontimeout = b;
  };
  if (r2 && r2.aborted)
    throw new l("request");
  return r2 && r2.addEventListener("abort", n2, { once: true }), i2.onreadystatechange = function() {
    4 === i2.readyState && (o2(), s2(i2), i2.onreadystatechange = b);
  }, i2.onerror = i2.ontimeout = o2, i2.open("get", t3, true), i2.send(), i2;
}
var nn = (t3, e2) => {
  let s2 = t3._findCenterFromElement();
  t3.transformMatrix && (((t4) => {
    if (t4.transformMatrix) {
      const { scaleX: e3, scaleY: s3, angle: i2, skewX: r2 } = dt(t4.transformMatrix);
      t4.flipX = false, t4.flipY = false, t4.set("scaleX", e3), t4.set("scaleY", s3), t4.angle = i2, t4.skewX = r2, t4.skewY = 0;
    }
  })(t3), s2 = s2.transform(t3.transformMatrix)), delete t3.transformMatrix, e2 && (t3.scaleX *= e2.scaleX, t3.scaleY *= e2.scaleY, t3.cropX = e2.cropX, t3.cropY = e2.cropY, s2.x += e2.offsetLeft, s2.y += e2.offsetTop, t3.width = e2.width, t3.height = e2.height), t3.setPositionByOrigin(s2, M, M);
};
var on = Object.freeze({ __proto__: null, addTransformToObject: ne, animate: ze, animateColor: He, applyTransformToObject: oe, calcAngleBetweenVectors: Je, calcDimensionsMatrix: _t, calcPlaneChangeMatrix: le, calcVectorRotation: Ze, cancelAnimFrame: Q, capValue: Ie, composeMatrix: xt, copyCanvasElement: (t3) => {
  var e2;
  const s2 = et();
  return s2.width = t3.width, s2.height = t3.height, null === (e2 = s2.getContext("2d")) || void 0 === e2 || e2.drawImage(t3, 0, 0), s2;
}, cos: H, createCanvasElement: et, createImage: st, createRotateMatrix: ft, createScaleMatrix: pt, createSkewXMatrix: vt, createSkewYMatrix: yt, createTranslateMatrix: gt, createVector: qe, crossProduct: ts, degreesToRadians: rt, dotProduct: es, ease: Ee, enlivenObjectEnlivables: wt, enlivenObjects: bt, findScaleToCover: xr, findScaleToFit: _r, getBoundsOfCurve: Br, getOrthonormalVector: $e, getPathSegmentsInfo: Jr, getPointOnPath: Zr, getPointer: te, getRandomInt: W, getRegularPolygonPath: (t3, e2) => {
  const s2 = 2 * Math.PI / t3;
  let i2 = -w;
  t3 % 2 == 0 && (i2 += s2 / 2);
  const r2 = new Array(t3 + 1);
  for (let n2 = 0; n2 < t3; n2++) {
    const t4 = n2 * s2 + i2, { x: o2, y: a2 } = new U(H(t4), G(t4)).scalarMultiply(e2);
    r2[n2] = [0 === n2 ? "M" : "L", o2, a2];
  }
  return r2[t3] = ["Z"], r2;
}, getSmoothPathFromPoints: en, getSvgAttributes: (t3) => {
  const e2 = ["instantiated_by_use", "style", "id", "class"];
  switch (t3) {
    case "linearGradient":
      return e2.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
    case "radialGradient":
      return e2.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
    case "stop":
      return e2.concat(["offset", "stop-color", "stop-opacity"]);
  }
  return e2;
}, getUnitVector: Qe, groupSVGElements: (t3, e2) => t3 && 1 === t3.length ? t3[0] : new yr(t3, e2), hasStyleChanged: Ci, invertTransform: ht, isBetweenVectors: ss, isIdentityMatrix: ot, isTouchEvent: ee, isTransparent: ui, joinPath: sn, loadImage: Ct, magnitude: Ke, makeBoundingBoxFromPoints: ie, makePathSimpler: Xr, matrixToSVG: Rt, mergeClipPaths: (t3, e2) => {
  var s2;
  let i2 = t3, r2 = e2;
  i2.inverted && !r2.inverted && (i2 = e2, r2 = t3), ge(r2, null === (s2 = r2.group) || void 0 === s2 ? void 0 : s2.calcTransformMatrix(), i2.calcTransformMatrix());
  const n2 = i2.inverted && r2.inverted;
  return n2 && (i2.inverted = r2.inverted = false), new yr([i2], { clipPath: r2, inverted: n2 });
}, multiplyTransformMatrices: ct, multiplyTransformMatrixArray: lt, parsePath: tn, parsePreserveAspectRatioAttribute: Lt, parseUnit: Ft, pick: St, projectStrokeOnPoints: mi, qrDecompose: dt, radiansToDegrees: nt, removeFromArray: z, removeTransformFromObject: (t3, e2) => {
  const s2 = ht(e2), i2 = ct(s2, t3.calcOwnMatrix());
  oe(t3, i2);
}, removeTransformMatrixForSvgParsing: nn, request: rn, requestAnimFrame: Z, resetObjectTransform: ae, rotatePoint: (t3, e2, s2) => t3.rotate(s2, e2), rotateVector: Ne, saveObjectTransform: he, sendObjectToPlane: ge, sendPointToPlane: ue, sendVectorToPlane: de, setStyle: Ut, sin: G, sizeAfterTransform: ce, string: xi, stylesFromArray: wi, stylesToArray: bi, toDataURL: it, toFixed: jt, transformPath: (t3, e2, s2) => (s2 && (e2 = ct(e2, [1, 0, 0, 1, -s2.x, -s2.y])), t3.map((t4) => {
  const s3 = [...t4];
  for (let i2 = 1; i2 < t4.length - 1; i2 += 2) {
    const { x: r2, y: n2 } = at({ x: t4[i2], y: t4[i2 + 1] }, e2);
    s3[i2] = r2, s3[i2 + 1] = n2;
  }
  return s3;
})), transformPoint: at });
var an = class extends Jt {
  constructor(t3) {
    let { allowTouchScrolling: e2 = false, containerClass: i2 = "" } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(t3), s(this, "upper", void 0), s(this, "container", void 0);
    const { el: r2 } = this.lower, n2 = this.createUpperCanvas();
    this.upper = { el: n2, ctx: n2.getContext("2d") }, this.applyCanvasStyle(r2, { allowTouchScrolling: e2 }), this.applyCanvasStyle(n2, { allowTouchScrolling: e2 });
    const o2 = this.createContainerElement();
    o2.classList.add(i2), r2.parentNode && r2.parentNode.replaceChild(o2, r2), o2.append(r2, n2), this.container = o2;
  }
  createUpperCanvas() {
    const { el: t3 } = this.lower, e2 = et();
    return e2.className = t3.className, e2.classList.remove("lower-canvas"), e2.classList.add("upper-canvas"), e2.setAttribute("data-fabric", "top"), e2.style.cssText = t3.style.cssText, e2.setAttribute("draggable", "true"), e2;
  }
  createContainerElement() {
    const t3 = v().createElement("div");
    return t3.setAttribute("data-fabric", "wrapper"), Ut(t3, { position: "relative" }), Kt(t3), t3;
  }
  applyCanvasStyle(t3, e2) {
    let { allowTouchScrolling: s2 } = e2;
    Ut(t3, { position: "absolute", left: "0", top: "0" }), function(t4, e3) {
      const s3 = e3 ? "manipulation" : F;
      Ut(t4, { "touch-action": s3, "-ms-touch-action": s3 });
    }(t3, s2), Kt(t3);
  }
  setDimensions(t3, e2) {
    super.setDimensions(t3, e2);
    const { el: s2, ctx: i2 } = this.upper;
    Nt(s2, i2, t3, e2);
  }
  setCSSDimensions(t3) {
    super.setCSSDimensions(t3), qt(this.upper.el, t3), qt(this.container, t3);
  }
  cleanupDOM(t3) {
    const e2 = this.container, { el: s2 } = this.lower, { el: i2 } = this.upper;
    super.cleanupDOM(t3), e2.removeChild(i2), e2.removeChild(s2), e2.parentNode && e2.parentNode.replaceChild(s2, e2);
  }
  dispose() {
    super.dispose(), m().dispose(this.upper.el), delete this.upper, delete this.container;
  }
};
var hn = class _hn extends Qt {
  constructor() {
    super(...arguments), s(this, "targets", []), s(this, "_hoveredTargets", []), s(this, "_objectsToRender", void 0), s(this, "_currentTransform", null), s(this, "_groupSelector", null), s(this, "contextTopDirty", false);
  }
  static getDefaults() {
    return e(e({}, super.getDefaults()), _hn.ownDefaults);
  }
  get upperCanvasEl() {
    var t3;
    return null === (t3 = this.elements.upper) || void 0 === t3 ? void 0 : t3.el;
  }
  get contextTop() {
    var t3;
    return null === (t3 = this.elements.upper) || void 0 === t3 ? void 0 : t3.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(t3) {
    this.elements = new an(t3, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(t3) {
    this._objectsToRender = void 0, super._onObjectAdded(t3);
  }
  _onObjectRemoved(t3) {
    this._objectsToRender = void 0, t3 === this._activeObject && (this.fire("before:selection:cleared", { deselected: [t3] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [t3] }), t3.fire("deselected", { target: t3 })), t3 === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(t3);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const t3 = this._activeObject;
    return !this.preserveObjectStacking && t3 ? this._objects.filter((e2) => !e2.group && e2 !== t3).concat(t3) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = false), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = false), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(t3) {
    t3.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = true), this.selection && this._groupSelector && (this._drawSelection(t3), this.contextTopDirty = true), t3.restore();
  }
  renderTop() {
    const t3 = this.contextTop;
    this.clearContext(t3), this.renderTopLayer(t3), this.fire("after:render", { ctx: t3 });
  }
  setTargetFindTolerance(t3) {
    t3 = Math.round(t3), this.targetFindTolerance = t3;
    const e2 = this.getRetinaScaling(), s2 = Math.ceil((2 * t3 + 1) * e2);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = s2, this.pixelFindContext.scale(e2, e2);
  }
  isTargetTransparent(t3, e2, s2) {
    const i2 = this.targetFindTolerance, r2 = this.pixelFindContext;
    this.clearContext(r2), r2.save(), r2.translate(-e2 + i2, -s2 + i2), r2.transform(...this.viewportTransform);
    const n2 = t3.selectionBackgroundColor;
    t3.selectionBackgroundColor = "", t3.render(r2), t3.selectionBackgroundColor = n2, r2.restore();
    const o2 = Math.round(i2 * this.getRetinaScaling());
    return ui(r2, o2, o2, o2);
  }
  _isSelectionKeyPressed(t3) {
    const e2 = this.selectionKey;
    return !!e2 && (Array.isArray(e2) ? !!e2.find((e3) => !!e3 && true === t3[e3]) : t3[e2]);
  }
  _shouldClearSelection(t3, e2) {
    const s2 = this.getActiveObjects(), i2 = this._activeObject;
    return !!(!e2 || e2 && i2 && s2.length > 1 && -1 === s2.indexOf(e2) && i2 !== e2 && !this._isSelectionKeyPressed(t3) || e2 && !e2.evented || e2 && !e2.selectable && i2 && i2 !== e2);
  }
  _shouldCenterTransform(t3, e2, s2) {
    if (!t3)
      return;
    let i2;
    return "scale" === e2 || "scaleX" === e2 || "scaleY" === e2 || "resizing" === e2 ? i2 = this.centeredScaling || t3.centeredScaling : "rotate" === e2 && (i2 = this.centeredRotation || t3.centeredRotation), i2 ? !s2 : s2;
  }
  _getOriginFromCorner(t3, e2) {
    const s2 = { x: t3.originX, y: t3.originY };
    return e2 ? (["ml", "tl", "bl"].includes(e2) ? s2.x = j : ["mr", "tr", "br"].includes(e2) && (s2.x = P), ["tl", "mt", "tr"].includes(e2) ? s2.y = A : ["bl", "mb", "br"].includes(e2) && (s2.y = E), s2) : s2;
  }
  _setupCurrentTransform(t3, s2, i2) {
    var r2;
    const n2 = s2.group ? ue(this.getScenePoint(t3), void 0, s2.group.calcTransformMatrix()) : this.getScenePoint(t3), { key: o2 = "", control: a2 } = s2.getActiveControl() || {}, h2 = i2 && a2 ? null === (r2 = a2.getActionHandler(t3, s2, a2)) || void 0 === r2 ? void 0 : r2.bind(a2) : Se, c2 = ((t4, e2, s3, i3) => {
      if (!e2 || !t4)
        return "drag";
      const r3 = i3.controls[e2];
      return r3.getActionName(s3, r3, i3);
    })(i2, o2, t3, s2), l2 = t3[this.centeredKey], u2 = this._shouldCenterTransform(s2, c2, l2) ? { x: M, y: M } : this._getOriginFromCorner(s2, o2), d2 = { target: s2, action: c2, actionHandler: h2, actionPerformed: false, corner: o2, scaleX: s2.scaleX, scaleY: s2.scaleY, skewX: s2.skewX, skewY: s2.skewY, offsetX: n2.x - s2.left, offsetY: n2.y - s2.top, originX: u2.x, originY: u2.y, ex: n2.x, ey: n2.y, lastX: n2.x, lastY: n2.y, theta: rt(s2.angle), width: s2.width, height: s2.height, shiftKey: t3.shiftKey, altKey: l2, original: e(e({}, he(s2)), {}, { originX: u2.x, originY: u2.y }) };
    this._currentTransform = d2, this.fire("before:transform", { e: t3, transform: d2 });
  }
  setCursor(t3) {
    this.upperCanvasEl.style.cursor = t3;
  }
  _drawSelection(t3) {
    const { x: e2, y: s2, deltaX: i2, deltaY: r2 } = this._groupSelector, n2 = new U(e2, s2).transform(this.viewportTransform), o2 = new U(e2 + i2, s2 + r2).transform(this.viewportTransform), a2 = this.selectionLineWidth / 2;
    let h2 = Math.min(n2.x, o2.x), c2 = Math.min(n2.y, o2.y), l2 = Math.max(n2.x, o2.x), u2 = Math.max(n2.y, o2.y);
    this.selectionColor && (t3.fillStyle = this.selectionColor, t3.fillRect(h2, c2, l2 - h2, u2 - c2)), this.selectionLineWidth && this.selectionBorderColor && (t3.lineWidth = this.selectionLineWidth, t3.strokeStyle = this.selectionBorderColor, h2 += a2, c2 += a2, l2 -= a2, u2 -= a2, li.prototype._setLineDash.call(this, t3, this.selectionDashArray), t3.strokeRect(h2, c2, l2 - h2, u2 - c2));
  }
  findTarget(t3) {
    if (this.skipTargetFind)
      return;
    const e2 = this.getViewportPoint(t3), s2 = this._activeObject, i2 = this.getActiveObjects();
    if (this.targets = [], s2 && i2.length >= 1) {
      if (s2.findControl(e2, ee(t3)))
        return s2;
      if (i2.length > 1 && this.searchPossibleTargets([s2], e2))
        return s2;
      if (s2 === this.searchPossibleTargets([s2], e2)) {
        if (this.preserveObjectStacking) {
          const i3 = this.targets;
          this.targets = [];
          const r2 = this.searchPossibleTargets(this._objects, e2);
          return t3[this.altSelectionKey] && r2 && r2 !== s2 ? (this.targets = i3, s2) : r2;
        }
        return s2;
      }
    }
    return this.searchPossibleTargets(this._objects, e2);
  }
  _pointIsInObjectSelectionArea(t3, e2) {
    let s2 = t3.getCoords();
    const i2 = this.getZoom(), r2 = t3.padding / i2;
    if (r2) {
      const [t4, e3, i3, n2] = s2, o2 = Math.atan2(e3.y - t4.y, e3.x - t4.x), a2 = H(o2) * r2, h2 = G(o2) * r2, c2 = a2 + h2, l2 = a2 - h2;
      s2 = [new U(t4.x - l2, t4.y - c2), new U(e3.x + c2, e3.y - l2), new U(i3.x + l2, i3.y + c2), new U(n2.x - c2, n2.y + l2)];
    }
    return is.isPointInPolygon(e2, s2);
  }
  _checkTarget(t3, e2) {
    if (t3 && t3.visible && t3.evented && this._pointIsInObjectSelectionArea(t3, ue(e2, void 0, this.viewportTransform))) {
      if (!this.perPixelTargetFind && !t3.perPixelTargetFind || t3.isEditing)
        return true;
      if (!this.isTargetTransparent(t3, e2.x, e2.y))
        return true;
    }
    return false;
  }
  _searchPossibleTargets(t3, e2) {
    let s2 = t3.length;
    for (; s2--; ) {
      const i2 = t3[s2];
      if (this._checkTarget(i2, e2)) {
        if (q(i2) && i2.subTargetCheck) {
          const t4 = this._searchPossibleTargets(i2._objects, e2);
          t4 && this.targets.push(t4);
        }
        return i2;
      }
    }
  }
  searchPossibleTargets(t3, e2) {
    const s2 = this._searchPossibleTargets(t3, e2);
    if (s2 && q(s2) && s2.interactive && this.targets[0]) {
      const t4 = this.targets;
      for (let e3 = t4.length - 1; e3 > 0; e3--) {
        const s3 = t4[e3];
        if (!q(s3) || !s3.interactive)
          return s3;
      }
      return t4[0];
    }
    return s2;
  }
  getViewportPoint(t3) {
    return this._pointer ? this._pointer : this.getPointer(t3, true);
  }
  getScenePoint(t3) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(t3);
  }
  getPointer(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const s2 = this.upperCanvasEl, i2 = s2.getBoundingClientRect();
    let r2 = te(t3), n2 = i2.width || 0, o2 = i2.height || 0;
    n2 && o2 || (E in i2 && A in i2 && (o2 = Math.abs(i2.top - i2.bottom)), j in i2 && P in i2 && (n2 = Math.abs(i2.right - i2.left))), this.calcOffset(), r2.x = r2.x - this._offset.left, r2.y = r2.y - this._offset.top, e2 || (r2 = ue(r2, void 0, this.viewportTransform));
    const a2 = this.getRetinaScaling();
    1 !== a2 && (r2.x /= a2, r2.y /= a2);
    const h2 = 0 === n2 || 0 === o2 ? new U(1, 1) : new U(s2.width / n2, s2.height / o2);
    return r2.multiply(h2);
  }
  _setDimensionsImpl(t3, e2) {
    this._resetTransformEventData(), super._setDimensionsImpl(t3, e2), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = et(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: true }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const t3 = this._activeObject;
    return Vt(t3) ? t3.getObjects() : t3 ? [t3] : [];
  }
  _fireSelectionEvents(t3, e2) {
    let s2 = false, i2 = false;
    const r2 = this.getActiveObjects(), n2 = [], o2 = [];
    t3.forEach((t4) => {
      r2.includes(t4) || (s2 = true, t4.fire("deselected", { e: e2, target: t4 }), o2.push(t4));
    }), r2.forEach((i3) => {
      t3.includes(i3) || (s2 = true, i3.fire("selected", { e: e2, target: i3 }), n2.push(i3));
    }), t3.length > 0 && r2.length > 0 ? (i2 = true, s2 && this.fire("selection:updated", { e: e2, selected: n2, deselected: o2 })) : r2.length > 0 ? (i2 = true, this.fire("selection:created", { e: e2, selected: n2 })) : t3.length > 0 && (i2 = true, this.fire("selection:cleared", { e: e2, deselected: o2 })), i2 && (this._objectsToRender = void 0);
  }
  setActiveObject(t3, e2) {
    const s2 = this.getActiveObjects(), i2 = this._setActiveObject(t3, e2);
    return this._fireSelectionEvents(s2, e2), i2;
  }
  _setActiveObject(t3, e2) {
    const s2 = this._activeObject;
    return s2 !== t3 && (!(!this._discardActiveObject(e2, t3) && this._activeObject) && (!t3.onSelect({ e: e2 }) && (this._activeObject = t3, Vt(t3) && s2 !== t3 && (t3.set("canvas", this), t3.setCoords()), true)));
  }
  _discardActiveObject(t3, e2) {
    const s2 = this._activeObject;
    return !!s2 && (!s2.onDeselect({ e: t3, object: e2 }) && (this._currentTransform && this._currentTransform.target === s2 && this.endCurrentTransform(t3), this._activeObject = void 0, true));
  }
  discardActiveObject(t3) {
    const e2 = this.getActiveObjects(), s2 = this.getActiveObject();
    e2.length && this.fire("before:selection:cleared", { e: t3, deselected: [s2] });
    const i2 = this._discardActiveObject(t3);
    return this._fireSelectionEvents(e2, t3), i2;
  }
  endCurrentTransform(t3) {
    const e2 = this._currentTransform;
    this._finalizeCurrentTransform(t3), e2 && e2.target && (e2.target.isMoving = false), this._currentTransform = null;
  }
  _finalizeCurrentTransform(t3) {
    const e2 = this._currentTransform, s2 = e2.target, i2 = { e: t3, target: s2, transform: e2, action: e2.action };
    s2._scaling && (s2._scaling = false), s2.setCoords(), e2.actionPerformed && (this.fire("object:modified", i2), s2.fire("modified", i2));
  }
  setViewportTransform(t3) {
    super.setViewportTransform(t3);
    const e2 = this._activeObject;
    e2 && e2.setCoords();
  }
  destroy() {
    const t3 = this._activeObject;
    Vt(t3) && (t3.removeAll(), t3.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(t3) {
    const e2 = this._activeObject;
    e2 && e2._renderControls(t3);
  }
  _toObject(t3, e2, s2) {
    const i2 = this._realizeGroupTransformOnObject(t3), r2 = super._toObject(t3, e2, s2);
    return t3.set(i2), r2;
  }
  _realizeGroupTransformOnObject(t3) {
    const { group: e2 } = t3;
    if (e2 && Vt(e2) && this._activeObject === e2) {
      const s2 = St(t3, ["angle", "flipX", "flipY", P, "scaleX", "scaleY", "skewX", "skewY", E]);
      return ne(t3, e2.calcOwnMatrix()), s2;
    }
    return {};
  }
  _setSVGObject(t3, e2, s2) {
    const i2 = this._realizeGroupTransformOnObject(e2);
    super._setSVGObject(t3, e2, s2), e2.set(i2);
  }
};
s(hn, "ownDefaults", { uniformScaling: true, uniScaleKey: "shiftKey", centeredScaling: false, centeredRotation: false, centeredKey: "altKey", altActionKey: "shiftKey", selection: true, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: false, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: false, targetFindTolerance: 0, skipTargetFind: false, stopContextMenu: false, fireRightClick: false, fireMiddleClick: false, enablePointerEvents: false, containerClass: "canvas-container", preserveObjectStacking: false });
var cn = class {
  constructor(t3) {
    s(this, "targets", []), s(this, "__disposer", void 0);
    const e2 = () => {
      const { hiddenTextarea: e3 } = t3.getActiveObject() || {};
      e3 && e3.focus();
    }, i2 = t3.upperCanvasEl;
    i2.addEventListener("click", e2), this.__disposer = () => i2.removeEventListener("click", e2);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((t3) => {
      t3.isEditing && t3.exitEditing();
    });
  }
  add(t3) {
    this.targets.push(t3);
  }
  remove(t3) {
    this.unregister(t3), z(this.targets, t3);
  }
  register(t3) {
    this.target = t3;
  }
  unregister(t3) {
    t3 === this.target && (this.target = void 0);
  }
  onMouseMove(t3) {
    var e2;
    (null === (e2 = this.target) || void 0 === e2 ? void 0 : e2.isEditing) && this.target.updateSelectionOnMouseMove(t3);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
};
var ln = ["target", "oldTarget", "fireCanvas", "e"];
var un = { passive: false };
var dn = (t3, e2) => {
  const s2 = t3.getViewportPoint(e2), i2 = t3.getScenePoint(e2);
  return { viewportPoint: s2, scenePoint: i2, pointer: s2, absolutePointer: i2 };
};
var gn = function(t3) {
  for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), i2 = 1; i2 < e2; i2++)
    s2[i2 - 1] = arguments[i2];
  return t3.addEventListener(...s2);
};
var fn = function(t3) {
  for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), i2 = 1; i2 < e2; i2++)
    s2[i2 - 1] = arguments[i2];
  return t3.removeEventListener(...s2);
};
var pn = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
var mn = class extends hn {
  constructor(t3) {
    super(t3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}), s(this, "_isClick", void 0), s(this, "textEditingManager", new cn(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onDoubleClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((t4) => {
      this[t4] = this[t4].bind(this);
    }), this.addOrRemove(gn, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(t3, e2) {
    const s2 = this.upperCanvasEl, i2 = this._getEventPrefix();
    t3(Gt(s2), "resize", this._onResize), t3(s2, i2 + "down", this._onMouseDown), t3(s2, "".concat(i2, "move"), this._onMouseMove, un), t3(s2, "".concat(i2, "out"), this._onMouseOut), t3(s2, "".concat(i2, "enter"), this._onMouseEnter), t3(s2, "wheel", this._onMouseWheel), t3(s2, "contextmenu", this._onContextMenu), t3(s2, "dblclick", this._onDoubleClick), t3(s2, "dragstart", this._onDragStart), t3(s2, "dragend", this._onDragEnd), t3(s2, "dragover", this._onDragOver), t3(s2, "dragenter", this._onDragEnter), t3(s2, "dragleave", this._onDragLeave), t3(s2, "drop", this._onDrop), this.enablePointerEvents || t3(s2, "touchstart", this._onTouchStart, un);
  }
  removeListeners() {
    this.addOrRemove(fn, "remove");
    const t3 = this._getEventPrefix(), e2 = Ht(this.upperCanvasEl);
    fn(e2, "".concat(t3, "up"), this._onMouseUp), fn(e2, "touchend", this._onTouchEnd, un), fn(e2, "".concat(t3, "move"), this._onMouseMove, un), fn(e2, "touchmove", this._onMouseMove, un);
  }
  _onMouseWheel(t3) {
    this.__onMouseWheel(t3);
  }
  _onMouseOut(t3) {
    const s2 = this._hoveredTarget, i2 = e({ e: t3 }, dn(this, t3));
    this.fire("mouse:out", e(e({}, i2), {}, { target: s2 })), this._hoveredTarget = void 0, s2 && s2.fire("mouseout", e({}, i2)), this._hoveredTargets.forEach((t4) => {
      this.fire("mouse:out", e(e({}, i2), {}, { target: t4 })), t4 && t4.fire("mouseout", e({}, i2));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(t3) {
    this._currentTransform || this.findTarget(t3) || (this.fire("mouse:over", e({ e: t3 }, dn(this, t3))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(t3) {
    this._isClick = false;
    const e2 = this.getActiveObject();
    if (e2 && e2.onDragStart(t3)) {
      this._dragSource = e2;
      const s2 = { e: t3, target: e2 };
      return this.fire("dragstart", s2), e2.fire("dragstart", s2), void gn(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    se(t3);
  }
  _renderDragEffects(t3, e2, s2) {
    let i2 = false;
    const r2 = this._dropTarget;
    r2 && r2 !== e2 && r2 !== s2 && (r2.clearContextTop(), i2 = true), null == e2 || e2.clearContextTop(), s2 !== e2 && (null == s2 || s2.clearContextTop());
    const n2 = this.contextTop;
    n2.save(), n2.transform(...this.viewportTransform), e2 && (n2.save(), e2.transform(n2), e2.renderDragSourceEffect(t3), n2.restore(), i2 = true), s2 && (n2.save(), s2.transform(n2), s2.renderDropTargetEffect(t3), n2.restore(), i2 = true), n2.restore(), i2 && (this.contextTopDirty = true);
  }
  _onDragEnd(t3) {
    const e2 = !!t3.dataTransfer && t3.dataTransfer.dropEffect !== F, s2 = e2 ? this._activeObject : void 0, i2 = { e: t3, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: e2, dropTarget: s2 };
    fn(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", i2), this._dragSource && this._dragSource.fire("dragend", i2), delete this._dragSource, this._onMouseUp(t3);
  }
  _onDragProgress(t3) {
    const e2 = { e: t3, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", e2), this._dragSource && this._dragSource.fire("drag", e2);
  }
  findDragTargets(t3) {
    this.targets = [];
    return { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(t3)), targets: [...this.targets] };
  }
  _onDragOver(t3) {
    const e2 = "dragover", { target: s2, targets: i2 } = this.findDragTargets(t3), r2 = this._dragSource, n2 = { e: t3, target: s2, subTargets: i2, dragSource: r2, canDrop: false, dropTarget: void 0 };
    let o2;
    this.fire(e2, n2), this._fireEnterLeaveEvents(s2, n2), s2 && (s2.canDrop(t3) && (o2 = s2), s2.fire(e2, n2));
    for (let s3 = 0; s3 < i2.length; s3++) {
      const r3 = i2[s3];
      r3.canDrop(t3) && (o2 = r3), r3.fire(e2, n2);
    }
    this._renderDragEffects(t3, r2, o2), this._dropTarget = o2;
  }
  _onDragEnter(t3) {
    const { target: e2, targets: s2 } = this.findDragTargets(t3), i2 = { e: t3, target: e2, subTargets: s2, dragSource: this._dragSource };
    this.fire("dragenter", i2), this._fireEnterLeaveEvents(e2, i2);
  }
  _onDragLeave(t3) {
    const e2 = { e: t3, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", e2), this._fireEnterLeaveEvents(void 0, e2), this._renderDragEffects(t3, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(t3) {
    const { target: s2, targets: i2 } = this.findDragTargets(t3), r2 = this._basicEventHandler("drop:before", e({ e: t3, target: s2, subTargets: i2, dragSource: this._dragSource }, dn(this, t3)));
    r2.didDrop = false, r2.dropTarget = void 0, this._basicEventHandler("drop", r2), this.fire("drop:after", r2);
  }
  _onContextMenu(t3) {
    const e2 = this.findTarget(t3), s2 = this.targets || [], i2 = this._basicEventHandler("contextmenu:before", { e: t3, target: e2, subTargets: s2 });
    return this.stopContextMenu && se(t3), this._basicEventHandler("contextmenu", i2), false;
  }
  _onDoubleClick(t3) {
    this._cacheTransformEventData(t3), this._handleEvent(t3, "dblclick"), this._resetTransformEventData();
  }
  getPointerId(t3) {
    const e2 = t3.changedTouches;
    return e2 ? e2[0] && e2[0].identifier : this.enablePointerEvents ? t3.pointerId : -1;
  }
  _isMainEvent(t3) {
    return true === t3.isPrimary || false !== t3.isPrimary && ("touchend" === t3.type && 0 === t3.touches.length || (!t3.changedTouches || t3.changedTouches[0].identifier === this.mainTouchId));
  }
  _onTouchStart(t3) {
    t3.preventDefault(), void 0 === this.mainTouchId && (this.mainTouchId = this.getPointerId(t3)), this.__onMouseDown(t3), this._resetTransformEventData();
    const e2 = this.upperCanvasEl, s2 = this._getEventPrefix(), i2 = Ht(e2);
    gn(i2, "touchend", this._onTouchEnd, un), gn(i2, "touchmove", this._onMouseMove, un), fn(e2, "".concat(s2, "down"), this._onMouseDown);
  }
  _onMouseDown(t3) {
    this.__onMouseDown(t3), this._resetTransformEventData();
    const e2 = this.upperCanvasEl, s2 = this._getEventPrefix();
    fn(e2, "".concat(s2, "move"), this._onMouseMove, un);
    const i2 = Ht(e2);
    gn(i2, "".concat(s2, "up"), this._onMouseUp), gn(i2, "".concat(s2, "move"), this._onMouseMove, un);
  }
  _onTouchEnd(t3) {
    if (t3.touches.length > 0)
      return;
    this.__onMouseUp(t3), this._resetTransformEventData(), delete this.mainTouchId;
    const e2 = this._getEventPrefix(), s2 = Ht(this.upperCanvasEl);
    fn(s2, "touchend", this._onTouchEnd, un), fn(s2, "touchmove", this._onMouseMove, un), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      gn(this.upperCanvasEl, "".concat(e2, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(t3) {
    this.__onMouseUp(t3), this._resetTransformEventData();
    const e2 = this.upperCanvasEl, s2 = this._getEventPrefix();
    if (this._isMainEvent(t3)) {
      const t4 = Ht(this.upperCanvasEl);
      fn(t4, "".concat(s2, "up"), this._onMouseUp), fn(t4, "".concat(s2, "move"), this._onMouseMove, un), gn(e2, "".concat(s2, "move"), this._onMouseMove, un);
    }
  }
  _onMouseMove(t3) {
    const e2 = this.getActiveObject();
    !this.allowTouchScrolling && (!e2 || !e2.shouldStartDragging(t3)) && t3.preventDefault && t3.preventDefault(), this.__onMouseMove(t3);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(t3) {
    const e2 = this.getActiveObject();
    return !!e2 != !!t3 || e2 && t3 && e2 !== t3;
  }
  __onMouseUp(t3) {
    var e2;
    this._cacheTransformEventData(t3), this._handleEvent(t3, "up:before");
    const s2 = this._currentTransform, i2 = this._isClick, r2 = this._target, { button: n2 } = t3;
    if (n2)
      return (this.fireMiddleClick && 1 === n2 || this.fireRightClick && 2 === n2) && this._handleEvent(t3, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing)
      return void this._onMouseUpInDrawingMode(t3);
    if (!this._isMainEvent(t3))
      return;
    let o2, a2, h2 = false;
    if (s2 && (this._finalizeCurrentTransform(t3), h2 = s2.actionPerformed), !i2) {
      const e3 = r2 === this._activeObject;
      this.handleSelection(t3), h2 || (h2 = this._shouldRender(r2) || !e3 && r2 === this._activeObject);
    }
    if (r2) {
      const e3 = r2.findControl(this.getViewportPoint(t3), ee(t3)), { key: i3, control: n3 } = e3 || {};
      if (a2 = i3, r2.selectable && r2 !== this._activeObject && "up" === r2.activeOn)
        this.setActiveObject(r2, t3), h2 = true;
      else if (n3) {
        const e4 = n3.getMouseUpHandler(t3, r2, n3);
        e4 && (o2 = this.getScenePoint(t3), e4.call(n3, t3, s2, o2.x, o2.y));
      }
      r2.isMoving = false;
    }
    if (s2 && (s2.target !== r2 || s2.corner !== a2)) {
      const e3 = s2.target && s2.target.controls[s2.corner], i3 = e3 && e3.getMouseUpHandler(t3, s2.target, e3);
      o2 = o2 || this.getScenePoint(t3), i3 && i3.call(e3, t3, s2, o2.x, o2.y);
    }
    this._setCursorFromEvent(t3, r2), this._handleEvent(t3, "up"), this._groupSelector = null, this._currentTransform = null, r2 && (r2.__corner = void 0), h2 ? this.requestRenderAll() : i2 || null !== (e2 = this._activeObject) && void 0 !== e2 && e2.isEditing || this.renderTop();
  }
  _basicEventHandler(t3, e2) {
    const { target: s2, subTargets: i2 = [] } = e2;
    this.fire(t3, e2), s2 && s2.fire(t3, e2);
    for (let r2 = 0; r2 < i2.length; r2++)
      i2[r2] !== s2 && i2[r2].fire(t3, e2);
    return e2;
  }
  _handleEvent(t3, s2) {
    const i2 = this._target, r2 = this.targets || [], n2 = e(e({ e: t3, target: i2, subTargets: r2 }, dn(this, t3)), {}, { transform: this._currentTransform }, "up:before" === s2 || "up" === s2 ? { isClick: this._isClick, currentTarget: this.findTarget(t3), currentSubTargets: this.targets } : {});
    this.fire("mouse:".concat(s2), n2), i2 && i2.fire("mouse".concat(s2), n2);
    for (let t4 = 0; t4 < r2.length; t4++)
      r2[t4] !== i2 && r2[t4].fire("mouse".concat(s2), n2);
  }
  _onMouseDownInDrawingMode(t3) {
    this._isCurrentlyDrawing = true, this.getActiveObject() && (this.discardActiveObject(t3), this.requestRenderAll());
    const e2 = this.getScenePoint(t3);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(e2, { e: t3, pointer: e2 }), this._handleEvent(t3, "down");
  }
  _onMouseMoveInDrawingMode(t3) {
    if (this._isCurrentlyDrawing) {
      const e2 = this.getScenePoint(t3);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(e2, { e: t3, pointer: e2 });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(t3, "move");
  }
  _onMouseUpInDrawingMode(t3) {
    const e2 = this.getScenePoint(t3);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e: t3, pointer: e2 }) : this._isCurrentlyDrawing = false, this._handleEvent(t3, "up");
  }
  __onMouseDown(t3) {
    this._isClick = true, this._cacheTransformEventData(t3), this._handleEvent(t3, "down:before");
    let e2 = this._target;
    const { button: s2 } = t3;
    if (s2)
      return (this.fireMiddleClick && 1 === s2 || this.fireRightClick && 2 === s2) && this._handleEvent(t3, "down"), void this._resetTransformEventData();
    if (this.isDrawingMode)
      return void this._onMouseDownInDrawingMode(t3);
    if (!this._isMainEvent(t3))
      return;
    if (this._currentTransform)
      return;
    let i2 = this._shouldRender(e2), r2 = false;
    if (this.handleMultiSelection(t3, e2) ? (e2 = this._activeObject, r2 = true, i2 = true) : this._shouldClearSelection(t3, e2) && this.discardActiveObject(t3), this.selection && (!e2 || !e2.selectable && !e2.isEditing && e2 !== this._activeObject)) {
      const e3 = this.getScenePoint(t3);
      this._groupSelector = { x: e3.x, y: e3.y, deltaY: 0, deltaX: 0 };
    }
    if (e2) {
      const s3 = e2 === this._activeObject;
      e2.selectable && "down" === e2.activeOn && this.setActiveObject(e2, t3);
      const i3 = e2.findControl(this.getViewportPoint(t3), ee(t3));
      if (e2 === this._activeObject && (i3 || !r2)) {
        this._setupCurrentTransform(t3, e2, s3);
        const r3 = i3 ? i3.control : void 0, n2 = this.getScenePoint(t3), o2 = r3 && r3.getMouseDownHandler(t3, e2, r3);
        o2 && o2.call(r3, t3, this._currentTransform, n2.x, n2.y);
      }
    }
    i2 && (this._objectsToRender = void 0), this._handleEvent(t3, "down"), i2 && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = void 0, this._pointer = void 0, this._absolutePointer = void 0;
  }
  _cacheTransformEventData(t3) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(t3), this._absolutePointer = ue(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t3);
  }
  __onMouseMove(t3) {
    if (this._isClick = false, this._cacheTransformEventData(t3), this._handleEvent(t3, "move:before"), this.isDrawingMode)
      return void this._onMouseMoveInDrawingMode(t3);
    if (!this._isMainEvent(t3))
      return;
    const e2 = this._groupSelector;
    if (e2) {
      const s2 = this.getScenePoint(t3);
      e2.deltaX = s2.x - e2.x, e2.deltaY = s2.y - e2.y, this.renderTop();
    } else if (this._currentTransform)
      this._transformObject(t3);
    else {
      const e3 = this.findTarget(t3);
      this._setCursorFromEvent(t3, e3), this._fireOverOutEvents(t3, e3);
    }
    this.textEditingManager.onMouseMove(t3), this._handleEvent(t3, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(t3, e2) {
    const s2 = this._hoveredTarget, i2 = this._hoveredTargets, r2 = this.targets, n2 = Math.max(i2.length, r2.length);
    this.fireSyntheticInOutEvents("mouse", { e: t3, target: e2, oldTarget: s2, fireCanvas: true });
    for (let e3 = 0; e3 < n2; e3++)
      this.fireSyntheticInOutEvents("mouse", { e: t3, target: r2[e3], oldTarget: i2[e3] });
    this._hoveredTarget = e2, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(t3, s2) {
    const i2 = this._draggedoverTarget, r2 = this._hoveredTargets, n2 = this.targets, o2 = Math.max(r2.length, n2.length);
    this.fireSyntheticInOutEvents("drag", e(e({}, s2), {}, { target: t3, oldTarget: i2, fireCanvas: true }));
    for (let t4 = 0; t4 < o2; t4++)
      this.fireSyntheticInOutEvents("drag", e(e({}, s2), {}, { target: n2[t4], oldTarget: r2[t4] }));
    this._draggedoverTarget = t3;
  }
  fireSyntheticInOutEvents(t3, s2) {
    let { target: r2, oldTarget: n2, fireCanvas: o2, e: a2 } = s2, h2 = i(s2, ln);
    const { targetIn: c2, targetOut: l2, canvasIn: u2, canvasOut: d2 } = pn[t3], g2 = n2 !== r2;
    if (n2 && g2) {
      const t4 = e(e({}, h2), {}, { e: a2, target: n2, nextTarget: r2 }, dn(this, a2));
      o2 && this.fire(d2, t4), n2.fire(l2, t4);
    }
    if (r2 && g2) {
      const t4 = e(e({}, h2), {}, { e: a2, target: r2, previousTarget: n2 }, dn(this, a2));
      o2 && this.fire(u2, t4), r2.fire(c2, t4);
    }
  }
  __onMouseWheel(t3) {
    this._cacheTransformEventData(t3), this._handleEvent(t3, "wheel"), this._resetTransformEventData();
  }
  _transformObject(t3) {
    const e2 = this.getScenePoint(t3), s2 = this._currentTransform, i2 = s2.target, r2 = i2.group ? ue(e2, void 0, i2.group.calcTransformMatrix()) : e2;
    s2.shiftKey = t3.shiftKey, s2.altKey = !!this.centeredKey && t3[this.centeredKey], this._performTransformAction(t3, s2, r2), s2.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(t3, e2, s2) {
    const i2 = s2.x, r2 = s2.y, n2 = e2.action, o2 = e2.actionHandler;
    let a2 = false;
    o2 && (a2 = o2(t3, e2, i2, r2)), "drag" === n2 && a2 && (e2.target.isMoving = true, this.setCursor(e2.target.moveCursor || this.moveCursor)), e2.actionPerformed = e2.actionPerformed || a2;
  }
  _setCursorFromEvent(t3, e2) {
    if (!e2)
      return void this.setCursor(this.defaultCursor);
    let s2 = e2.hoverCursor || this.hoverCursor;
    const i2 = Vt(this._activeObject) ? this._activeObject : null, r2 = (!i2 || e2.group !== i2) && e2.findControl(this.getViewportPoint(t3));
    if (r2) {
      const s3 = r2.control;
      this.setCursor(s3.cursorStyleHandler(t3, s3, e2));
    } else
      e2.subTargetCheck && this.targets.concat().reverse().map((t4) => {
        s2 = t4.hoverCursor || s2;
      }), this.setCursor(s2);
  }
  handleMultiSelection(t3, e2) {
    const s2 = this._activeObject, i2 = Vt(s2);
    if (s2 && this._isSelectionKeyPressed(t3) && this.selection && e2 && e2.selectable && (s2 !== e2 || i2) && (i2 || !e2.isDescendantOf(s2) && !s2.isDescendantOf(e2)) && !e2.onSelect({ e: t3 }) && !s2.getActiveControl()) {
      if (i2) {
        const i3 = s2.getObjects();
        if (e2 === s2) {
          const s3 = this.getViewportPoint(t3);
          if (!(e2 = this.searchPossibleTargets(i3, s3) || this.searchPossibleTargets(this._objects, s3)) || !e2.selectable)
            return false;
        }
        e2.group === s2 ? (s2.remove(e2), this._hoveredTarget = e2, this._hoveredTargets = [...this.targets], 1 === s2.size() && this._setActiveObject(s2.item(0), t3)) : (s2.multiSelectAdd(e2), this._hoveredTarget = s2, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(i3, t3);
      } else {
        s2.exitEditing && s2.exitEditing();
        const i3 = new (I.getClass("ActiveSelection"))([], { canvas: this });
        i3.multiSelectAdd(s2, e2), this._hoveredTarget = i3, this._setActiveObject(i3, t3), this._fireSelectionEvents([s2], t3);
      }
      return true;
    }
    return false;
  }
  handleSelection(t3) {
    if (!this.selection || !this._groupSelector)
      return false;
    const { x: e2, y: s2, deltaX: i2, deltaY: r2 } = this._groupSelector, n2 = new U(e2, s2), o2 = n2.add(new U(i2, r2)), a2 = n2.min(o2), h2 = n2.max(o2).subtract(a2), c2 = this.collectObjects({ left: a2.x, top: a2.y, width: h2.x, height: h2.y }, { includeIntersecting: !this.selectionFullyContained }), l2 = n2.eq(o2) ? c2[0] ? [c2[0]] : [] : c2.length > 1 ? c2.filter((e3) => !e3.onSelect({ e: t3 })).reverse() : c2;
    if (1 === l2.length)
      this.setActiveObject(l2[0], t3);
    else if (l2.length > 1) {
      const e3 = I.getClass("ActiveSelection");
      this.setActiveObject(new e3(l2, { canvas: this }), t3);
    }
    return this._groupSelector = null, true;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
};
var vn = { x1: 0, y1: 0, x2: 0, y2: 0 };
var yn = e(e({}, vn), {}, { r1: 0, r2: 0 });
var _n = /^(\d+\.\d+)%|(\d+)%$/;
function xn(t3) {
  return t3 && _n.test(t3);
}
function Cn(t3, e2) {
  const s2 = "number" == typeof t3 ? t3 : "string" == typeof t3 ? parseFloat(t3) / (xn(t3) ? 100 : 1) : NaN;
  return Ie(0, V(s2, e2), 1);
}
var bn = /\s*;\s*/;
var wn = /\s*:\s*/;
function Sn(t3, e2) {
  let s2, i2;
  const r2 = t3.getAttribute("style");
  if (r2) {
    const t4 = r2.split(bn);
    "" === t4[t4.length - 1] && t4.pop();
    for (let e3 = t4.length; e3--; ) {
      const [r3, n3] = t4[e3].split(wn).map((t5) => t5.trim());
      "stop-color" === r3 ? s2 = n3 : "stop-opacity" === r3 && (i2 = n3);
    }
  }
  const n2 = new At(s2 || t3.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: Cn(t3.getAttribute("offset"), 0), color: n2.toRgb(), opacity: V(parseFloat(i2 || t3.getAttribute("stop-opacity") || ""), 1) * n2.getAlpha() * e2 };
}
function Tn(t3, e2) {
  const s2 = [], i2 = t3.getElementsByTagName("stop"), r2 = Cn(e2, 1);
  for (let t4 = i2.length; t4--; )
    s2.push(Sn(i2[t4], r2));
  return s2;
}
function On(t3) {
  return "linearGradient" === t3.nodeName || "LINEARGRADIENT" === t3.nodeName ? "linear" : "radial";
}
function kn(t3) {
  return "userSpaceOnUse" === t3.getAttribute("gradientUnits") ? "pixels" : "percentage";
}
function Dn(t3, e2) {
  return t3.getAttribute(e2);
}
function Mn(t3, s2) {
  return function(t4, e2) {
    let s3, { width: i2, height: r2, gradientUnits: n2 } = e2;
    return Object.keys(t4).reduce((e3, o2) => {
      const a2 = t4[o2];
      return "Infinity" === a2 ? s3 = 1 : "-Infinity" === a2 ? s3 = 0 : (s3 = "string" == typeof a2 ? parseFloat(a2) : a2, "string" == typeof a2 && xn(a2) && (s3 *= 0.01, "pixels" === n2 && ("x1" !== o2 && "x2" !== o2 && "r2" !== o2 || (s3 *= i2), "y1" !== o2 && "y2" !== o2 || (s3 *= r2)))), e3[o2] = s3, e3;
    }, {});
  }("linear" === On(t3) ? function(t4) {
    return { x1: Dn(t4, "x1") || 0, y1: Dn(t4, "y1") || 0, x2: Dn(t4, "x2") || "100%", y2: Dn(t4, "y2") || 0 };
  }(t3) : function(t4) {
    return { x1: Dn(t4, "fx") || Dn(t4, "cx") || "50%", y1: Dn(t4, "fy") || Dn(t4, "cy") || "50%", r1: 0, x2: Dn(t4, "cx") || "50%", y2: Dn(t4, "cy") || "50%", r2: Dn(t4, "r") || "50%" };
  }(t3), e(e({}, s2), {}, { gradientUnits: kn(t3) }));
}
var Pn = class {
  constructor(t3) {
    let { type: s2 = "linear", gradientUnits: i2 = "pixels", coords: r2 = {}, colorStops: n2 = [], offsetX: o2 = 0, offsetY: a2 = 0, gradientTransform: h2, id: c2 } = t3;
    this.id = c2 ? "".concat(c2, "_").concat(tt()) : tt(), this.type = s2, this.gradientUnits = i2, this.gradientTransform = h2, this.offsetX = o2, this.offsetY = a2, this.coords = e(e({}, "radial" === this.type ? yn : vn), r2), this.colorStops = n2.slice();
  }
  addColorStop(t3) {
    for (const e2 in t3) {
      const s2 = new At(t3[e2]);
      this.colorStops.push({ offset: parseFloat(e2), color: s2.toRgb(), opacity: s2.getAlpha() });
    }
    return this;
  }
  toObject(t3) {
    return e(e({}, St(this, t3)), {}, { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(t3) {
    let { additionalTransform: s2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const i2 = [], r2 = this.gradientTransform ? this.gradientTransform.concat() : O.concat(), n2 = "pixels" === this.gradientUnits ? "userSpaceOnUse" : "objectBoundingBox", o2 = this.colorStops.map((t4) => e({}, t4)).sort((t4, e2) => t4.offset - e2.offset);
    let a2 = -this.offsetX, h2 = -this.offsetY;
    var c2;
    "objectBoundingBox" === n2 ? (a2 /= t3.width, h2 /= t3.height) : (a2 += t3.width / 2, h2 += t3.height / 2), (c2 = t3) && "function" == typeof c2._renderPathCommands && "percentage" !== this.gradientUnits && (a2 -= t3.pathOffset.x, h2 -= t3.pathOffset.y), r2[4] -= a2, r2[5] -= h2;
    const l2 = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(n2, '"'), 'gradientTransform="'.concat(s2 ? s2 + " " : "").concat(Rt(r2), '"'), ""].join(" ");
    if ("linear" === this.type) {
      const { x1: t4, y1: e2, x2: s3, y2: r3 } = this.coords;
      i2.push("<linearGradient ", l2, ' x1="', t4, '" y1="', e2, '" x2="', s3, '" y2="', r3, '">\n');
    } else if ("radial" === this.type) {
      const { x1: t4, y1: e2, x2: s3, y2: r3, r1: n3, r2: a3 } = this.coords, h3 = n3 > a3;
      i2.push("<radialGradient ", l2, ' cx="', h3 ? t4 : s3, '" cy="', h3 ? e2 : r3, '" r="', h3 ? n3 : a3, '" fx="', h3 ? s3 : t4, '" fy="', h3 ? r3 : e2, '">\n'), h3 && (o2.reverse(), o2.forEach((t5) => {
        t5.offset = 1 - t5.offset;
      }));
      const c3 = Math.min(n3, a3);
      if (c3 > 0) {
        const t5 = c3 / Math.max(n3, a3);
        o2.forEach((e3) => {
          e3.offset += t5 * (1 - e3.offset);
        });
      }
    }
    return o2.forEach((t4) => {
      let { color: e2, offset: s3, opacity: r3 } = t4;
      i2.push("<stop ", 'offset="', 100 * s3 + "%", '" style="stop-color:', e2, void 0 !== r3 ? ";stop-opacity: " + r3 : ";", '"/>\n');
    }), i2.push("linear" === this.type ? "</linearGradient>" : "</radialGradient>", "\n"), i2.join("");
  }
  toLive(t3) {
    const e2 = this.coords, s2 = "linear" === this.type ? t3.createLinearGradient(e2.x1, e2.y1, e2.x2, e2.y2) : t3.createRadialGradient(e2.x1, e2.y1, e2.r1, e2.x2, e2.y2, e2.r2);
    return this.colorStops.forEach((t4) => {
      let { color: e3, opacity: i2, offset: r2 } = t4;
      s2.addColorStop(r2, void 0 !== i2 ? new At(e3).setAlpha(i2).toRgba() : e3);
    }), s2;
  }
  static async fromObject(t3) {
    return new this(t3);
  }
  static fromElement(t3, s2, i2) {
    const r2 = kn(t3), n2 = s2._findCenterFromElement();
    return new this(e({ id: t3.getAttribute("id") || void 0, type: On(t3), coords: Mn(t3, { width: i2.viewBoxWidth || i2.width, height: i2.viewBoxHeight || i2.height }), colorStops: Tn(t3, i2.opacity), gradientUnits: r2, gradientTransform: Ji(t3.getAttribute("gradientTransform") || "") }, "pixels" === r2 ? { offsetX: s2.width / 2 - n2.x, offsetY: s2.height / 2 - n2.y } : { offsetX: 0, offsetY: 0 }));
  }
};
s(Pn, "type", "Gradient"), I.setClass(Pn, "gradient"), I.setClass(Pn, "linear"), I.setClass(Pn, "radial");
var En = ["type", "source"];
var An = class {
  get type() {
    return "pattern";
  }
  set type(t3) {
    h("warn", "Setting type has no effect", t3);
  }
  constructor(t3) {
    s(this, "repeat", "repeat"), s(this, "offsetX", 0), s(this, "offsetY", 0), s(this, "crossOrigin", ""), s(this, "patternTransform", null), this.id = tt(), Object.assign(this, t3);
  }
  isImageSource() {
    return !!this.source && "string" == typeof this.source.src;
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(t3) {
    return this.source && (!this.isImageSource() || this.source.complete && 0 !== this.source.naturalWidth && 0 !== this.source.naturalHeight) ? t3.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const { repeat: s2, crossOrigin: i2 } = this;
    return e(e({}, St(this, t3)), {}, { type: "pattern", source: this.sourceToString(), repeat: s2, crossOrigin: i2, offsetX: jt(this.offsetX, a.NUM_FRACTION_DIGITS), offsetY: jt(this.offsetY, a.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(t3) {
    let { width: e2, height: s2 } = t3;
    const { source: i2, repeat: r2, id: n2 } = this, o2 = V(this.offsetX / e2, 0), a2 = V(this.offsetY / s2, 0), h2 = "repeat-y" === r2 || "no-repeat" === r2 ? 1 + Math.abs(o2 || 0) : V(i2.width / e2, 0), c2 = "repeat-x" === r2 || "no-repeat" === r2 ? 1 + Math.abs(a2 || 0) : V(i2.height / s2, 0);
    return ['<pattern id="SVGID_'.concat(n2, '" x="').concat(o2, '" y="').concat(a2, '" width="').concat(h2, '" height="').concat(c2, '">'), '<image x="0" y="0" width="'.concat(i2.width, '" height="').concat(i2.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join("\n");
  }
  static async fromObject(t3, s2) {
    let { type: r2, source: n2 } = t3, o2 = i(t3, En);
    const a2 = await Ct(n2, e(e({}, s2), {}, { crossOrigin: o2.crossOrigin }));
    return new this(e(e({}, o2), {}, { source: a2 }));
  }
};
s(An, "type", "Pattern"), I.setClass(An), I.setClass(An, "pattern");
var jn = class {
  constructor(t3) {
    s(this, "color", "rgb(0, 0, 0)"), s(this, "width", 1), s(this, "shadow", null), s(this, "strokeLineCap", "round"), s(this, "strokeLineJoin", "round"), s(this, "strokeMiterLimit", 10), s(this, "strokeDashArray", null), s(this, "limitedToCanvasSize", false), this.canvas = t3;
  }
  _setBrushStyles(t3) {
    t3.strokeStyle = this.color, t3.lineWidth = this.width, t3.lineCap = this.strokeLineCap, t3.miterLimit = this.strokeMiterLimit, t3.lineJoin = this.strokeLineJoin, t3.setLineDash(this.strokeDashArray || []);
  }
  _saveAndTransform(t3) {
    const e2 = this.canvas.viewportTransform;
    t3.save(), t3.transform(e2[0], e2[1], e2[2], e2[3], e2[4], e2[5]);
  }
  needsFullRender() {
    return new At(this.color).getAlpha() < 1 || !!this.shadow;
  }
  _setShadow() {
    if (!this.shadow || !this.canvas)
      return;
    const t3 = this.canvas, e2 = this.shadow, s2 = t3.contextTop, i2 = t3.getZoom() * t3.getRetinaScaling();
    s2.shadowColor = e2.color, s2.shadowBlur = e2.blur * i2, s2.shadowOffsetX = e2.offsetX * i2, s2.shadowOffsetY = e2.offsetY * i2;
  }
  _resetShadow() {
    const t3 = this.canvas.contextTop;
    t3.shadowColor = "", t3.shadowBlur = t3.shadowOffsetX = t3.shadowOffsetY = 0;
  }
  _isOutSideCanvas(t3) {
    return t3.x < 0 || t3.x > this.canvas.getWidth() || t3.y < 0 || t3.y > this.canvas.getHeight();
  }
};
var Fn = ["path", "left", "top"];
var Ln = ["d"];
var Rn = class _Rn extends li {
  constructor(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { path: s2, left: r2, top: n2 } = e2, o2 = i(e2, Fn);
    super(), Object.assign(this, _Rn.ownDefaults), this.setOptions(o2), this._setPath(t3 || [], true), "number" == typeof r2 && this.set(P, r2), "number" == typeof n2 && this.set(E, n2);
  }
  _setPath(t3, e2) {
    this.path = Xr(Array.isArray(t3) ? t3 : tn(t3)), this.setBoundingBox(e2);
  }
  _findCenterFromElement() {
    const t3 = this._calcBoundsFromPath();
    return new U(t3.left + t3.width / 2, t3.top + t3.height / 2);
  }
  _renderPathCommands(t3) {
    const e2 = -this.pathOffset.x, s2 = -this.pathOffset.y;
    t3.beginPath();
    for (const i2 of this.path)
      switch (i2[0]) {
        case "L":
          t3.lineTo(i2[1] + e2, i2[2] + s2);
          break;
        case "M":
          t3.moveTo(i2[1] + e2, i2[2] + s2);
          break;
        case "C":
          t3.bezierCurveTo(i2[1] + e2, i2[2] + s2, i2[3] + e2, i2[4] + s2, i2[5] + e2, i2[6] + s2);
          break;
        case "Q":
          t3.quadraticCurveTo(i2[1] + e2, i2[2] + s2, i2[3] + e2, i2[4] + s2);
          break;
        case "Z":
          t3.closePath();
      }
  }
  _render(t3) {
    this._renderPathCommands(t3), this._renderPaintInOrder(t3);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return e(e({}, super.toObject(t3)), {}, { path: this.path.map((t4) => t4.slice()) });
  }
  toDatalessObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const e2 = this.toObject(t3);
    return this.sourcePath && (delete e2.path, e2.sourcePath = this.sourcePath), e2;
  }
  _toSVG() {
    const t3 = sn(this.path, a.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(t3, '" stroke-linecap="round" />\n')];
  }
  _getOffsetTransform() {
    const t3 = a.NUM_FRACTION_DIGITS;
    return " translate(".concat(jt(-this.pathOffset.x, t3), ", ").concat(jt(-this.pathOffset.y, t3), ")");
  }
  toClipPathSVG(t3) {
    const e2 = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: t3, additionalTransform: e2 });
  }
  toSVG(t3) {
    const e2 = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: t3, additionalTransform: e2 });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(t3) {
    const { width: e2, height: s2, pathOffset: i2 } = this._calcDimensions();
    this.set({ width: e2, height: s2, pathOffset: i2 }), t3 && this.setPositionByOrigin(i2, M, M);
  }
  _calcBoundsFromPath() {
    const t3 = [];
    let e2 = 0, s2 = 0, i2 = 0, r2 = 0;
    for (const n2 of this.path)
      switch (n2[0]) {
        case "L":
          i2 = n2[1], r2 = n2[2], t3.push(new U(e2, s2), new U(i2, r2));
          break;
        case "M":
          i2 = n2[1], r2 = n2[2], e2 = i2, s2 = r2;
          break;
        case "C":
          t3.push(...Br(i2, r2, n2[1], n2[2], n2[3], n2[4], n2[5], n2[6])), i2 = n2[5], r2 = n2[6];
          break;
        case "Q":
          t3.push(...Br(i2, r2, n2[1], n2[2], n2[1], n2[2], n2[3], n2[4])), i2 = n2[3], r2 = n2[4];
          break;
        case "Z":
          i2 = e2, r2 = s2;
      }
    return ie(t3);
  }
  _calcDimensions() {
    const t3 = this._calcBoundsFromPath();
    return e(e({}, t3), {}, { pathOffset: new U(t3.left + t3.width / 2, t3.top + t3.height / 2) });
  }
  static fromObject(t3) {
    return this._fromObject(t3, { extraParam: "path" });
  }
  static async fromElement(t3, s2, r2) {
    const n2 = er(t3, this.ATTRIBUTE_NAMES, r2), { d: o2 } = n2;
    return new this(o2, e(e(e({}, i(n2, Ln)), s2), {}, { left: void 0, top: void 0 }));
  }
};
s(Rn, "type", "Path"), s(Rn, "cacheProperties", [...Os, "path", "fillRule"]), s(Rn, "ATTRIBUTE_NAMES", [...Si, "d"]), I.setClass(Rn), I.setSVGClass(Rn);
var Bn = class _Bn extends jn {
  constructor(t3) {
    super(t3), s(this, "decimate", 0.4), s(this, "drawStraightLine", false), s(this, "straightLineKey", "shiftKey"), this._points = [], this._hasStraightLine = false;
  }
  needsFullRender() {
    return super.needsFullRender() || this._hasStraightLine;
  }
  static drawSegment(t3, e2, s2) {
    const i2 = e2.midPointFrom(s2);
    return t3.quadraticCurveTo(e2.x, e2.y, i2.x, i2.y), i2;
  }
  onMouseDown(t3, e2) {
    let { e: s2 } = e2;
    this.canvas._isMainEvent(s2) && (this.drawStraightLine = !!this.straightLineKey && s2[this.straightLineKey], this._prepareForDrawing(t3), this._addPoint(t3), this._render());
  }
  onMouseMove(t3, e2) {
    let { e: s2 } = e2;
    if (this.canvas._isMainEvent(s2) && (this.drawStraightLine = !!this.straightLineKey && s2[this.straightLineKey], (true !== this.limitedToCanvasSize || !this._isOutSideCanvas(t3)) && this._addPoint(t3) && this._points.length > 1))
      if (this.needsFullRender())
        this.canvas.clearContext(this.canvas.contextTop), this._render();
      else {
        const t4 = this._points, e3 = t4.length, s3 = this.canvas.contextTop;
        this._saveAndTransform(s3), this.oldEnd && (s3.beginPath(), s3.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = _Bn.drawSegment(s3, t4[e3 - 2], t4[e3 - 1]), s3.stroke(), s3.restore();
      }
  }
  onMouseUp(t3) {
    let { e: e2 } = t3;
    return !this.canvas._isMainEvent(e2) || (this.drawStraightLine = false, this.oldEnd = void 0, this._finalizeAndAddPath(), false);
  }
  _prepareForDrawing(t3) {
    this._reset(), this._addPoint(t3), this.canvas.contextTop.moveTo(t3.x, t3.y);
  }
  _addPoint(t3) {
    return !(this._points.length > 1 && t3.eq(this._points[this._points.length - 1])) && (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = true, this._points.pop()), this._points.push(t3), true);
  }
  _reset() {
    this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = false;
  }
  _render() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.canvas.contextTop, e2 = this._points[0], s2 = this._points[1];
    if (this._saveAndTransform(t3), t3.beginPath(), 2 === this._points.length && e2.x === s2.x && e2.y === s2.y) {
      const t4 = this.width / 1e3;
      e2.x -= t4, s2.x += t4;
    }
    t3.moveTo(e2.x, e2.y);
    for (let i2 = 1; i2 < this._points.length; i2++)
      _Bn.drawSegment(t3, e2, s2), e2 = this._points[i2], s2 = this._points[i2 + 1];
    t3.lineTo(e2.x, e2.y), t3.stroke(), t3.restore();
  }
  convertPointsToSVGPath(t3) {
    const e2 = this.width / 1e3;
    return en(t3, e2);
  }
  createPath(t3) {
    const e2 = new Rn(t3, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeMiterLimit: this.strokeMiterLimit, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray });
    return this.shadow && (this.shadow.affectStroke = true, e2.shadow = new ws(this.shadow)), e2;
  }
  decimatePoints(t3, e2) {
    if (t3.length <= 2)
      return t3;
    let s2, i2 = t3[0];
    const r2 = this.canvas.getZoom(), n2 = Math.pow(e2 / r2, 2), o2 = t3.length - 1, a2 = [i2];
    for (let e3 = 1; e3 < o2 - 1; e3++)
      s2 = Math.pow(i2.x - t3[e3].x, 2) + Math.pow(i2.y - t3[e3].y, 2), s2 >= n2 && (i2 = t3[e3], a2.push(i2));
    return a2.push(t3[o2]), a2;
  }
  _finalizeAndAddPath() {
    this.canvas.contextTop.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate));
    const t3 = this.convertPointsToSVGPath(this._points);
    if (function(t4) {
      return "M 0 0 Q 0 0 0 0 L 0 0" === sn(t4);
    }(t3))
      return void this.canvas.requestRenderAll();
    const e2 = this.createPath(t3);
    this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: e2 }), this.canvas.add(e2), this.canvas.requestRenderAll(), e2.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: e2 });
  }
};
var In = ["left", "top", "radius"];
var Xn = ["radius", "startAngle", "endAngle", "counterClockwise"];
var Yn = class _Yn extends li {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _Yn.ownDefaults);
  }
  constructor(t3) {
    super(), Object.assign(this, _Yn.ownDefaults), this.setOptions(t3);
  }
  _set(t3, e2) {
    return super._set(t3, e2), "radius" === t3 && this.setRadius(e2), this;
  }
  _render(t3) {
    t3.beginPath(), t3.arc(0, 0, this.radius, rt(this.startAngle), rt(this.endAngle), this.counterClockwise), this._renderPaintInOrder(t3);
  }
  getRadiusX() {
    return this.get("radius") * this.get("scaleX");
  }
  getRadiusY() {
    return this.get("radius") * this.get("scaleY");
  }
  setRadius(t3) {
    this.radius = t3, this.set({ width: 2 * t3, height: 2 * t3 });
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return super.toObject([...Xn, ...t3]);
  }
  _toSVG() {
    const t3 = (this.endAngle - this.startAngle) % 360;
    if (0 === t3)
      return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), '" />\n'];
    {
      const { radius: e2 } = this, s2 = rt(this.startAngle), i2 = rt(this.endAngle), r2 = H(s2) * e2, n2 = G(s2) * e2, o2 = H(i2) * e2, a2 = G(i2) * e2, h2 = t3 > 180 ? 1 : 0, c2 = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(r2, " ").concat(n2, " A ").concat(e2, " ").concat(e2, " 0 ").concat(h2, " ").concat(c2, " ").concat(o2, " ").concat(a2, '" '), "COMMON_PARTS", " />\n"];
    }
  }
  static async fromElement(t3, s2, r2) {
    const n2 = er(t3, this.ATTRIBUTE_NAMES, r2), { left: o2 = 0, top: a2 = 0, radius: h2 = 0 } = n2;
    return new this(e(e({}, i(n2, In)), {}, { radius: h2, left: o2 - h2, top: a2 - h2 }));
  }
  static fromObject(t3) {
    return super._fromObject(t3);
  }
};
s(Yn, "type", "Circle"), s(Yn, "cacheProperties", [...Os, ...Xn]), s(Yn, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: false }), s(Yn, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Si]), I.setClass(Yn), I.setSVGClass(Yn);
var Wn = class extends jn {
  constructor(t3) {
    super(t3), s(this, "width", 10), this.points = [];
  }
  drawDot(t3) {
    const e2 = this.addPoint(t3), s2 = this.canvas.contextTop;
    this._saveAndTransform(s2), this.dot(s2, e2), s2.restore();
  }
  dot(t3, e2) {
    t3.fillStyle = e2.fill, t3.beginPath(), t3.arc(e2.x, e2.y, e2.radius, 0, 2 * Math.PI, false), t3.closePath(), t3.fill();
  }
  onMouseDown(t3) {
    this.points = [], this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t3);
  }
  _render() {
    const t3 = this.canvas.contextTop, e2 = this.points;
    this._saveAndTransform(t3);
    for (let s2 = 0; s2 < e2.length; s2++)
      this.dot(t3, e2[s2]);
    t3.restore();
  }
  onMouseMove(t3) {
    true === this.limitedToCanvasSize && this._isOutSideCanvas(t3) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(t3), this._render()) : this.drawDot(t3));
  }
  onMouseUp() {
    const t3 = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;
    const e2 = [];
    for (let t4 = 0; t4 < this.points.length; t4++) {
      const s3 = this.points[t4], i2 = new Yn({ radius: s3.radius, left: s3.x, top: s3.y, originX: M, originY: M, fill: s3.fill });
      this.shadow && (i2.shadow = new ws(this.shadow)), e2.push(i2);
    }
    const s2 = new yr(e2, { canvas: this.canvas });
    this.canvas.fire("before:path:created", { path: s2 }), this.canvas.add(s2), this.canvas.fire("path:created", { path: s2 }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t3, this.canvas.requestRenderAll();
  }
  addPoint(t3) {
    let { x: e2, y: s2 } = t3;
    const i2 = { x: e2, y: s2, radius: W(Math.max(0, this.width - 20), this.width + 20) / 2, fill: new At(this.color).setAlpha(W(0, 100) / 100).toRgba() };
    return this.points.push(i2), i2;
  }
};
var Vn = class extends jn {
  constructor(t3) {
    super(t3), s(this, "width", 10), s(this, "density", 20), s(this, "dotWidth", 1), s(this, "dotWidthVariance", 1), s(this, "randomOpacity", false), s(this, "optimizeOverlapping", true), this.sprayChunks = [], this.sprayChunk = [];
  }
  onMouseDown(t3) {
    this.sprayChunks = [], this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t3), this.renderChunck(this.sprayChunk);
  }
  onMouseMove(t3) {
    true === this.limitedToCanvasSize && this._isOutSideCanvas(t3) || (this.addSprayChunk(t3), this.renderChunck(this.sprayChunk));
  }
  onMouseUp() {
    const t3 = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;
    const e2 = [];
    for (let t4 = 0; t4 < this.sprayChunks.length; t4++) {
      const s3 = this.sprayChunks[t4];
      for (let t5 = 0; t5 < s3.length; t5++) {
        const i2 = s3[t5], r2 = new rr({ width: i2.width, height: i2.width, left: i2.x + 1, top: i2.y + 1, originX: M, originY: M, fill: this.color });
        e2.push(r2);
      }
    }
    const s2 = new yr(this.optimizeOverlapping ? function(t4) {
      const e3 = {}, s3 = [];
      for (let i2, r2 = 0; r2 < t4.length; r2++)
        i2 = "".concat(t4[r2].left).concat(t4[r2].top), e3[i2] || (e3[i2] = true, s3.push(t4[r2]));
      return s3;
    }(e2) : e2, { objectCaching: true, subTargetCheck: false, interactive: false });
    this.shadow && s2.set("shadow", new ws(this.shadow)), this.canvas.fire("before:path:created", { path: s2 }), this.canvas.add(s2), this.canvas.fire("path:created", { path: s2 }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t3, this.canvas.requestRenderAll();
  }
  renderChunck(t3) {
    const e2 = this.canvas.contextTop;
    e2.fillStyle = this.color, this._saveAndTransform(e2);
    for (let s2 = 0; s2 < t3.length; s2++) {
      const i2 = t3[s2];
      e2.globalAlpha = i2.opacity, e2.fillRect(i2.x, i2.y, i2.width, i2.width);
    }
    e2.restore();
  }
  _render() {
    const t3 = this.canvas.contextTop;
    t3.fillStyle = this.color, this._saveAndTransform(t3);
    for (let t4 = 0; t4 < this.sprayChunks.length; t4++)
      this.renderChunck(this.sprayChunks[t4]);
    t3.restore();
  }
  addSprayChunk(t3) {
    this.sprayChunk = [];
    const e2 = this.width / 2;
    for (let s2 = 0; s2 < this.density; s2++)
      this.sprayChunk.push({ x: W(t3.x - e2, t3.x + e2), y: W(t3.y - e2, t3.y + e2), width: this.dotWidthVariance ? W(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth, opacity: this.randomOpacity ? W(0, 100) / 100 : 1 });
    this.sprayChunks.push(this.sprayChunk);
  }
};
var zn = class extends Bn {
  constructor(t3) {
    super(t3);
  }
  getPatternSrc() {
    const t3 = et(), e2 = t3.getContext("2d");
    return t3.width = t3.height = 25, e2 && (e2.fillStyle = this.color, e2.beginPath(), e2.arc(10, 10, 10, 0, 2 * Math.PI, false), e2.closePath(), e2.fill()), t3;
  }
  getPattern(t3) {
    return t3.createPattern(this.source || this.getPatternSrc(), "repeat");
  }
  _setBrushStyles(t3) {
    super._setBrushStyles(t3);
    const e2 = this.getPattern(t3);
    e2 && (t3.strokeStyle = e2);
  }
  createPath(t3) {
    const e2 = super.createPath(t3), s2 = e2._getLeftTopCoords().scalarAdd(e2.strokeWidth / 2);
    return e2.stroke = new An({ source: this.source || this.getPatternSrc(), offsetX: -s2.x, offsetY: -s2.y }), e2;
  }
};
var Hn = ["x1", "y1", "x2", "y2"];
var Gn = ["x1", "y1", "x2", "y2"];
var Un = ["x1", "x2", "y1", "y2"];
var Nn = class _Nn extends li {
  constructor() {
    let [t3, e2, s2, i2] = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [0, 0, 0, 0], r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(), Object.assign(this, _Nn.ownDefaults), this.setOptions(r2), this.x1 = t3, this.x2 = s2, this.y1 = e2, this.y2 = i2, this._setWidthHeight();
    const { left: n2, top: o2 } = r2;
    "number" == typeof n2 && this.set(P, n2), "number" == typeof o2 && this.set(E, o2);
  }
  _setWidthHeight() {
    const { x1: t3, y1: e2, x2: s2, y2: i2 } = this;
    this.width = Math.abs(s2 - t3), this.height = Math.abs(i2 - e2);
    const { left: r2, top: n2, width: o2, height: a2 } = ie([{ x: t3, y: e2 }, { x: s2, y: i2 }]), h2 = new U(r2 + o2 / 2, n2 + a2 / 2);
    this.setPositionByOrigin(h2, M, M);
  }
  _set(t3, e2) {
    return super._set(t3, e2), Un.includes(t3) && this._setWidthHeight(), this;
  }
  _render(t3) {
    t3.beginPath();
    const e2 = this.calcLinePoints();
    t3.moveTo(e2.x1, e2.y1), t3.lineTo(e2.x2, e2.y2), t3.lineWidth = this.strokeWidth;
    const s2 = t3.strokeStyle;
    var i2;
    It(this.stroke) ? t3.strokeStyle = this.stroke.toLive(t3) : t3.strokeStyle = null !== (i2 = this.stroke) && void 0 !== i2 ? i2 : t3.fillStyle;
    this.stroke && this._renderStroke(t3), t3.strokeStyle = s2;
  }
  _findCenterFromElement() {
    return new U((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return e(e({}, super.toObject(t3)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const t3 = super._getNonTransformedDimensions();
    return "butt" === this.strokeLineCap && (0 === this.width && (t3.y -= this.strokeWidth), 0 === this.height && (t3.x -= this.strokeWidth)), t3;
  }
  calcLinePoints() {
    const { x1: t3, x2: e2, y1: s2, y2: i2, width: r2, height: n2 } = this, o2 = t3 <= e2 ? -1 : 1, a2 = s2 <= i2 ? -1 : 1;
    return { x1: o2 * r2 / 2, x2: o2 * -r2 / 2, y1: a2 * n2 / 2, y2: a2 * -n2 / 2 };
  }
  _toSVG() {
    const { x1: t3, x2: e2, y1: s2, y2: i2 } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(t3, '" y1="').concat(s2, '" x2="').concat(e2, '" y2="').concat(i2, '" />\n')];
  }
  static async fromElement(t3, e2, s2) {
    const r2 = er(t3, this.ATTRIBUTE_NAMES, s2), { x1: n2 = 0, y1: o2 = 0, x2: a2 = 0, y2: h2 = 0 } = r2;
    return new this([n2, o2, a2, h2], i(r2, Hn));
  }
  static fromObject(t3) {
    let { x1: s2, y1: r2, x2: n2, y2: o2 } = t3, a2 = i(t3, Gn);
    return this._fromObject(e(e({}, a2), {}, { points: [s2, r2, n2, o2] }), { extraParam: "points" });
  }
};
s(Nn, "type", "Line"), s(Nn, "cacheProperties", [...Os, ...Un]), s(Nn, "ATTRIBUTE_NAMES", Si.concat(Un)), I.setClass(Nn), I.setSVGClass(Nn);
var qn = class _qn extends li {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _qn.ownDefaults);
  }
  constructor(t3) {
    super(), Object.assign(this, _qn.ownDefaults), this.setOptions(t3);
  }
  _render(t3) {
    const e2 = this.width / 2, s2 = this.height / 2;
    t3.beginPath(), t3.moveTo(-e2, s2), t3.lineTo(0, -s2), t3.lineTo(e2, s2), t3.closePath(), this._renderPaintInOrder(t3);
  }
  _toSVG() {
    const t3 = this.width / 2, e2 = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-t3, " ").concat(e2, ",0 ").concat(-e2, ",").concat(t3, " ").concat(e2), '" />'];
  }
};
s(qn, "type", "Triangle"), s(qn, "ownDefaults", { width: 100, height: 100 }), I.setClass(qn), I.setSVGClass(qn);
var Kn = ["rx", "ry"];
var Jn = class _Jn extends li {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _Jn.ownDefaults);
  }
  constructor(t3) {
    super(), Object.assign(this, _Jn.ownDefaults), this.setOptions(t3);
  }
  _set(t3, e2) {
    switch (super._set(t3, e2), t3) {
      case "rx":
        this.rx = e2, this.set("width", 2 * e2);
        break;
      case "ry":
        this.ry = e2, this.set("height", 2 * e2);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get("scaleX");
  }
  getRy() {
    return this.get("ry") * this.get("scaleY");
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return super.toObject([...Kn, ...t3]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, '" />\n')];
  }
  _render(t3) {
    t3.beginPath(), t3.save(), t3.transform(1, 0, 0, this.ry / this.rx, 0, 0), t3.arc(0, 0, this.rx, 0, S, false), t3.restore(), this._renderPaintInOrder(t3);
  }
  static async fromElement(t3, e2, s2) {
    const i2 = er(t3, this.ATTRIBUTE_NAMES, s2);
    return i2.left = (i2.left || 0) - i2.rx, i2.top = (i2.top || 0) - i2.ry, new this(i2);
  }
};
function Zn(t3) {
  if (!t3)
    return [];
  const e2 = t3.replace(/,/g, " ").trim().split(/\s+/), s2 = [];
  for (let t4 = 0; t4 < e2.length; t4 += 2)
    s2.push({ x: parseFloat(e2[t4]), y: parseFloat(e2[t4 + 1]) });
  return s2;
}
s(Jn, "type", "Ellipse"), s(Jn, "cacheProperties", [...Os, ...Kn]), s(Jn, "ownDefaults", { rx: 0, ry: 0 }), s(Jn, "ATTRIBUTE_NAMES", [...Si, "cx", "cy", "rx", "ry"]), I.setClass(Jn), I.setSVGClass(Jn);
var Qn = ["left", "top"];
var $n = { exactBoundingBox: false };
var to = class _to extends li {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _to.ownDefaults);
  }
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(), s(this, "strokeDiff", void 0), Object.assign(this, _to.ownDefaults), this.setOptions(e2), this.points = t3;
    const { left: i2, top: r2 } = e2;
    this.initialized = true, this.setBoundingBox(true), "number" == typeof i2 && this.set(P, i2), "number" == typeof r2 && this.set(E, r2);
  }
  isOpen() {
    return true;
  }
  _projectStrokeOnPoints(t3) {
    return mi(this.points, t3, this.isOpen());
  }
  _calcDimensions(t3) {
    t3 = e({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, t3 || {});
    const s2 = this.exactBoundingBox ? this._projectStrokeOnPoints(t3).map((t4) => t4.projectedPoint) : this.points;
    if (0 === s2.length)
      return { left: 0, top: 0, width: 0, height: 0, pathOffset: new U(), strokeOffset: new U(), strokeDiff: new U() };
    const i2 = ie(s2), r2 = _t(e(e({}, t3), {}, { scaleX: 1, scaleY: 1 })), n2 = ie(this.points.map((t4) => at(t4, r2, true))), o2 = new U(this.scaleX, this.scaleY);
    let a2 = i2.left + i2.width / 2, h2 = i2.top + i2.height / 2;
    return this.exactBoundingBox && (a2 -= h2 * Math.tan(rt(this.skewX)), h2 -= a2 * Math.tan(rt(this.skewY))), e(e({}, i2), {}, { pathOffset: new U(a2, h2), strokeOffset: new U(n2.left, n2.top).subtract(new U(i2.left, i2.top)).multiply(o2), strokeDiff: new U(i2.width, i2.height).subtract(new U(n2.width, n2.height)).multiply(o2) });
  }
  _findCenterFromElement() {
    const t3 = ie(this.points);
    return new U(t3.left + t3.width / 2, t3.top + t3.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(t3) {
    const { left: e2, top: s2, width: i2, height: r2, pathOffset: n2, strokeOffset: o2, strokeDiff: a2 } = this._calcDimensions();
    this.set({ width: i2, height: r2, pathOffset: n2, strokeOffset: o2, strokeDiff: a2 }), t3 && this.setPositionByOrigin(new U(e2 + i2 / 2, s2 + r2 / 2), M, M);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new U(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let n2;
      if (Object.keys(t3).some((t4) => this.strokeUniform || this.constructor.layoutProperties.includes(t4))) {
        var e2, s2;
        const { width: i3, height: r3 } = this._calcDimensions(t3);
        n2 = new U(null !== (e2 = t3.width) && void 0 !== e2 ? e2 : i3, null !== (s2 = t3.height) && void 0 !== s2 ? s2 : r3);
      } else {
        var i2, r2;
        n2 = new U(null !== (i2 = t3.width) && void 0 !== i2 ? i2 : this.width, null !== (r2 = t3.height) && void 0 !== r2 ? r2 : this.height);
      }
      return n2.multiply(new U(t3.scaleX || this.scaleX, t3.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(t3);
  }
  _set(t3, e2) {
    const s2 = this.initialized && this[t3] !== e2, i2 = super._set(t3, e2);
    return this.exactBoundingBox && s2 && (("scaleX" === t3 || "scaleY" === t3) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(t3)) && this.setDimensions(), i2;
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return e(e({}, super.toObject(t3)), {}, { points: Ss(this.points) });
  }
  _toSVG() {
    const t3 = [], e2 = this.pathOffset.x, s2 = this.pathOffset.y, i2 = a.NUM_FRACTION_DIGITS;
    for (let r2 = 0, n2 = this.points.length; r2 < n2; r2++)
      t3.push(jt(this.points[r2].x - e2, i2), ",", jt(this.points[r2].y - s2, i2), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(t3.join(""), '" />\n')];
  }
  _render(t3) {
    const e2 = this.points.length, s2 = this.pathOffset.x, i2 = this.pathOffset.y;
    if (e2 && !isNaN(this.points[e2 - 1].y)) {
      t3.beginPath(), t3.moveTo(this.points[0].x - s2, this.points[0].y - i2);
      for (let r2 = 0; r2 < e2; r2++) {
        const e3 = this.points[r2];
        t3.lineTo(e3.x - s2, e3.y - i2);
      }
      !this.isOpen() && t3.closePath(), this._renderPaintInOrder(t3);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(t3, s2, r2) {
    return new this(Zn(t3.getAttribute("points")), e(e({}, i(er(t3, this.ATTRIBUTE_NAMES, r2), Qn)), s2));
  }
  static fromObject(t3) {
    return this._fromObject(t3, { extraParam: "points" });
  }
};
s(to, "ownDefaults", $n), s(to, "type", "Polyline"), s(to, "layoutProperties", ["skewX", "skewY", "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), s(to, "cacheProperties", [...Os, "points"]), s(to, "ATTRIBUTE_NAMES", [...Si]), I.setClass(to), I.setSVGClass(to);
var eo = class extends to {
  isOpen() {
    return false;
  }
};
s(eo, "ownDefaults", $n), s(eo, "type", "Polygon"), I.setClass(eo), I.setSVGClass(eo);
var so = ["fontSize", "fontWeight", "fontFamily", "fontStyle"];
var io = ["underline", "overline", "linethrough"];
var ro = [...so, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"];
var no = [...ro, ...io, "textBackgroundColor", "direction"];
var oo = [...so, ...io, "stroke", "strokeWidth", "fill", "deltaY", "textBackgroundColor"];
var ao = { _reNewline: L, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: false, overline: false, linethrough: false, textAlign: P, fontStyle: "normal", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: P, pathAlign: "baseline", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2 };
var ho = "justify";
var co = "justify-left";
var lo = "justify-right";
var uo = "justify-center";
var go = class extends li {
  isEmptyStyles(t3) {
    if (!this.styles)
      return true;
    if (void 0 !== t3 && !this.styles[t3])
      return true;
    const e2 = void 0 === t3 ? this.styles : { line: this.styles[t3] };
    for (const t4 in e2)
      for (const s2 in e2[t4])
        for (const i2 in e2[t4][s2])
          return false;
    return true;
  }
  styleHas(t3, e2) {
    if (!this.styles)
      return false;
    if (void 0 !== e2 && !this.styles[e2])
      return false;
    const s2 = void 0 === e2 ? this.styles : { 0: this.styles[e2] };
    for (const e3 in s2)
      for (const i2 in s2[e3])
        if (void 0 !== s2[e3][i2][t3])
          return true;
    return false;
  }
  cleanStyle(t3) {
    if (!this.styles)
      return false;
    const e2 = this.styles;
    let s2, i2, r2 = 0, n2 = true, o2 = 0;
    for (const o3 in e2) {
      s2 = 0;
      for (const a2 in e2[o3]) {
        const h2 = e2[o3][a2] || {};
        r2++, void 0 !== h2[t3] ? (i2 ? h2[t3] !== i2 && (n2 = false) : i2 = h2[t3], h2[t3] === this[t3] && delete h2[t3]) : n2 = false, 0 !== Object.keys(h2).length ? s2++ : delete e2[o3][a2];
      }
      0 === s2 && delete e2[o3];
    }
    for (let t4 = 0; t4 < this._textLines.length; t4++)
      o2 += this._textLines[t4].length;
    n2 && r2 === o2 && (this[t3] = i2, this.removeStyle(t3));
  }
  removeStyle(t3) {
    if (!this.styles)
      return;
    const e2 = this.styles;
    let s2, i2, r2;
    for (i2 in e2) {
      for (r2 in s2 = e2[i2], s2)
        delete s2[r2][t3], 0 === Object.keys(s2[r2]).length && delete s2[r2];
      0 === Object.keys(s2).length && delete e2[i2];
    }
  }
  _extendStyles(t3, s2) {
    const { lineIndex: i2, charIndex: r2 } = this.get2DCursorLocation(t3);
    this._getLineStyle(i2) || this._setLineStyle(i2);
    const n2 = Tt(e(e({}, this._getStyleDeclaration(i2, r2)), s2), (t4) => void 0 !== t4);
    this._setStyleDeclaration(i2, r2, n2);
  }
  getSelectionStyles(t3, e2, s2) {
    const i2 = [];
    for (let r2 = t3; r2 < (e2 || t3); r2++)
      i2.push(this.getStyleAtPosition(r2, s2));
    return i2;
  }
  getStyleAtPosition(t3, e2) {
    const { lineIndex: s2, charIndex: i2 } = this.get2DCursorLocation(t3);
    return e2 ? this.getCompleteStyleDeclaration(s2, i2) : this._getStyleDeclaration(s2, i2);
  }
  setSelectionStyles(t3, e2, s2) {
    for (let i2 = e2; i2 < (s2 || e2); i2++)
      this._extendStyles(i2, t3);
    this._forceClearCache = true;
  }
  _getStyleDeclaration(t3, e2) {
    var s2;
    const i2 = this.styles && this.styles[t3];
    return i2 && null !== (s2 = i2[e2]) && void 0 !== s2 ? s2 : {};
  }
  getCompleteStyleDeclaration(t3, s2) {
    return e(e({}, St(this, this.constructor._styleProperties)), this._getStyleDeclaration(t3, s2));
  }
  _setStyleDeclaration(t3, e2, s2) {
    this.styles[t3][e2] = s2;
  }
  _deleteStyleDeclaration(t3, e2) {
    delete this.styles[t3][e2];
  }
  _getLineStyle(t3) {
    return !!this.styles[t3];
  }
  _setLineStyle(t3) {
    this.styles[t3] = {};
  }
  _deleteLineStyle(t3) {
    delete this.styles[t3];
  }
};
s(go, "_styleProperties", oo);
var fo = /  +/g;
var po = /"/g;
function mo(t3, e2, s2, i2, r2) {
  return "		".concat(function(t4, e3) {
    let { left: s3, top: i3, width: r3, height: n2 } = e3, o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : a.NUM_FRACTION_DIGITS;
    const h2 = Bt("fill", t4, false), [c2, l2, u2, d2] = [s3, i3, r3, n2].map((t5) => jt(t5, o2));
    return "<rect ".concat(h2, ' x="').concat(c2, '" y="').concat(l2, '" width="').concat(u2, '" height="').concat(d2, '"></rect>');
  }(t3, { left: e2, top: s2, width: i2, height: r2 }), "\n");
}
var vo = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
var yo;
var _o = class __o extends go {
  static getDefaults() {
    return e(e({}, super.getDefaults()), __o.ownDefaults);
  }
  constructor(t3, e2) {
    super(), s(this, "__charBounds", []), Object.assign(this, __o.ownDefaults), this.setOptions(e2), this.styles || (this.styles = {}), this.text = t3, this.initialized = true, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const t3 = this.path;
    t3 && (t3.segmentsInfo = Jr(t3.path));
  }
  _splitText() {
    const t3 = this._splitTextIntoLines(this.text);
    return this.textLines = t3.lines, this._textLines = t3.graphemeLines, this._unwrappedTextLines = t3._unwrappedLines, this._text = t3.graphemeText, t3;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = true, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(ho) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let t3, e2, s2, i2, r2, n2, o2;
    for (let a2 = 0, h2 = this._textLines.length; a2 < h2; a2++)
      if ((this.textAlign === ho || a2 !== h2 - 1 && !this.isEndOfWrapping(a2)) && (i2 = 0, r2 = this._textLines[a2], e2 = this.getLineWidth(a2), e2 < this.width && (o2 = this.textLines[a2].match(this._reSpacesAndTabs)))) {
        s2 = o2.length, t3 = (this.width - e2) / s2;
        for (let e3 = 0; e3 <= r2.length; e3++)
          n2 = this.__charBounds[a2][e3], this._reSpaceAndTab.test(r2[e3]) ? (n2.width += t3, n2.kernedWidth += t3, n2.left += i2, i2 += t3) : n2.left += i2;
      }
  }
  isEndOfWrapping(t3) {
    return t3 === this._textLines.length - 1;
  }
  missingNewlineOffset(t3) {
    return 1;
  }
  get2DCursorLocation(t3, e2) {
    const s2 = e2 ? this._unwrappedTextLines : this._textLines;
    let i2;
    for (i2 = 0; i2 < s2.length; i2++) {
      if (t3 <= s2[i2].length)
        return { lineIndex: i2, charIndex: t3 };
      t3 -= s2[i2].length + this.missingNewlineOffset(i2, e2);
    }
    return { lineIndex: i2 - 1, charIndex: s2[i2 - 1].length < t3 ? s2[i2 - 1].length : t3 };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const t3 = super._getCacheCanvasDimensions(), e2 = this.fontSize;
    return t3.width += e2 * t3.zoomX, t3.height += e2 * t3.zoomY, t3;
  }
  _render(t3) {
    const e2 = this.path;
    e2 && !e2.isNotVisible() && e2._render(t3), this._setTextStyles(t3), this._renderTextLinesBackground(t3), this._renderTextDecoration(t3, "underline"), this._renderText(t3), this._renderTextDecoration(t3, "overline"), this._renderTextDecoration(t3, "linethrough");
  }
  _renderText(t3) {
    "stroke" === this.paintFirst ? (this._renderTextStroke(t3), this._renderTextFill(t3)) : (this._renderTextFill(t3), this._renderTextStroke(t3));
  }
  _setTextStyles(t3, e2, s2) {
    if (t3.textBaseline = "alphabetic", this.path)
      switch (this.pathAlign) {
        case M:
          t3.textBaseline = "middle";
          break;
        case "ascender":
          t3.textBaseline = E;
          break;
        case "descender":
          t3.textBaseline = A;
      }
    t3.font = this._getFontDeclaration(e2, s2);
  }
  calcTextWidth() {
    let t3 = this.getLineWidth(0);
    for (let e2 = 1, s2 = this._textLines.length; e2 < s2; e2++) {
      const s3 = this.getLineWidth(e2);
      s3 > t3 && (t3 = s3);
    }
    return t3;
  }
  _renderTextLine(t3, e2, s2, i2, r2, n2) {
    this._renderChars(t3, e2, s2, i2, r2, n2);
  }
  _renderTextLinesBackground(t3) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor"))
      return;
    const e2 = t3.fillStyle, s2 = this._getLeftOffset();
    let i2 = this._getTopOffset();
    for (let e3 = 0, r2 = this._textLines.length; e3 < r2; e3++) {
      const r3 = this.getHeightOfLine(e3);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", e3)) {
        i2 += r3;
        continue;
      }
      const n2 = this._textLines[e3].length, o2 = this._getLineLeftOffset(e3);
      let a2, h2, c2 = 0, l2 = 0, u2 = this.getValueOfPropertyAt(e3, 0, "textBackgroundColor");
      for (let d2 = 0; d2 < n2; d2++) {
        const n3 = this.__charBounds[e3][d2];
        h2 = this.getValueOfPropertyAt(e3, d2, "textBackgroundColor"), this.path ? (t3.save(), t3.translate(n3.renderLeft, n3.renderTop), t3.rotate(n3.angle), t3.fillStyle = h2, h2 && t3.fillRect(-n3.width / 2, -r3 / this.lineHeight * (1 - this._fontSizeFraction), n3.width, r3 / this.lineHeight), t3.restore()) : h2 !== u2 ? (a2 = s2 + o2 + l2, "rtl" === this.direction && (a2 = this.width - a2 - c2), t3.fillStyle = u2, u2 && t3.fillRect(a2, i2, c2, r3 / this.lineHeight), l2 = n3.left, c2 = n3.width, u2 = h2) : c2 += n3.kernedWidth;
      }
      h2 && !this.path && (a2 = s2 + o2 + l2, "rtl" === this.direction && (a2 = this.width - a2 - c2), t3.fillStyle = h2, t3.fillRect(a2, i2, c2, r3 / this.lineHeight)), i2 += r3;
    }
    t3.fillStyle = e2, this._removeShadow(t3);
  }
  _measureChar(t3, e2, s2, i2) {
    const r2 = x.getFontCache(e2), n2 = this._getFontDeclaration(e2), o2 = s2 + t3, a2 = s2 && n2 === this._getFontDeclaration(i2), h2 = e2.fontSize / this.CACHE_FONT_SIZE;
    let c2, l2, u2, d2;
    if (s2 && void 0 !== r2[s2] && (u2 = r2[s2]), void 0 !== r2[t3] && (d2 = c2 = r2[t3]), a2 && void 0 !== r2[o2] && (l2 = r2[o2], d2 = l2 - u2), void 0 === c2 || void 0 === u2 || void 0 === l2) {
      const i3 = function() {
        if (!yo) {
          const t4 = et();
          t4.width = t4.height = 0, yo = t4.getContext("2d");
        }
        return yo;
      }();
      this._setTextStyles(i3, e2, true), void 0 === c2 && (d2 = c2 = i3.measureText(t3).width, r2[t3] = c2), void 0 === u2 && a2 && s2 && (u2 = i3.measureText(s2).width, r2[s2] = u2), a2 && void 0 === l2 && (l2 = i3.measureText(o2).width, r2[o2] = l2, d2 = l2 - u2);
    }
    return { width: c2 * h2, kernedWidth: d2 * h2 };
  }
  getHeightOfChar(t3, e2) {
    return this.getValueOfPropertyAt(t3, e2, "fontSize");
  }
  measureLine(t3) {
    const e2 = this._measureLine(t3);
    return 0 !== this.charSpacing && (e2.width -= this._getWidthOfCharSpacing()), e2.width < 0 && (e2.width = 0), e2;
  }
  _measureLine(t3) {
    let e2, s2, i2 = 0;
    const r2 = this.pathSide === j, n2 = this.path, o2 = this._textLines[t3], a2 = o2.length, h2 = new Array(a2);
    this.__charBounds[t3] = h2;
    for (let r3 = 0; r3 < a2; r3++) {
      const n3 = o2[r3];
      s2 = this._getGraphemeBox(n3, t3, r3, e2), h2[r3] = s2, i2 += s2.kernedWidth, e2 = n3;
    }
    if (h2[a2] = { left: s2 ? s2.left + s2.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, n2 && n2.segmentsInfo) {
      let t4 = 0;
      const e3 = n2.segmentsInfo[n2.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case P:
          t4 = r2 ? e3 - i2 : 0;
          break;
        case M:
          t4 = (e3 - i2) / 2;
          break;
        case j:
          t4 = r2 ? 0 : e3 - i2;
      }
      t4 += this.pathStartOffset * (r2 ? -1 : 1);
      for (let i3 = r2 ? a2 - 1 : 0; r2 ? i3 >= 0 : i3 < a2; r2 ? i3-- : i3++)
        s2 = h2[i3], t4 > e3 ? t4 %= e3 : t4 < 0 && (t4 += e3), this._setGraphemeOnPath(t4, s2), t4 += s2.kernedWidth;
    }
    return { width: i2, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(t3, e2) {
    const s2 = t3 + e2.kernedWidth / 2, i2 = this.path, r2 = Zr(i2.path, s2, i2.segmentsInfo);
    e2.renderLeft = r2.x - i2.pathOffset.x, e2.renderTop = r2.y - i2.pathOffset.y, e2.angle = r2.angle + (this.pathSide === j ? Math.PI : 0);
  }
  _getGraphemeBox(t3, e2, s2, i2, r2) {
    const n2 = this.getCompleteStyleDeclaration(e2, s2), o2 = i2 ? this.getCompleteStyleDeclaration(e2, s2 - 1) : {}, a2 = this._measureChar(t3, n2, i2, o2);
    let h2, c2 = a2.kernedWidth, l2 = a2.width;
    0 !== this.charSpacing && (h2 = this._getWidthOfCharSpacing(), l2 += h2, c2 += h2);
    const u2 = { width: l2, left: 0, height: n2.fontSize, kernedWidth: c2, deltaY: n2.deltaY };
    if (s2 > 0 && !r2) {
      const t4 = this.__charBounds[e2][s2 - 1];
      u2.left = t4.left + t4.width + a2.kernedWidth - a2.width;
    }
    return u2;
  }
  getHeightOfLine(t3) {
    if (this.__lineHeights[t3])
      return this.__lineHeights[t3];
    let e2 = this.getHeightOfChar(t3, 0);
    for (let s2 = 1, i2 = this._textLines[t3].length; s2 < i2; s2++)
      e2 = Math.max(this.getHeightOfChar(t3, s2), e2);
    return this.__lineHeights[t3] = e2 * this.lineHeight * this._fontSizeMult;
  }
  calcTextHeight() {
    let t3, e2 = 0;
    for (let s2 = 0, i2 = this._textLines.length; s2 < i2; s2++)
      t3 = this.getHeightOfLine(s2), e2 += s2 === i2 - 1 ? t3 / this.lineHeight : t3;
    return e2;
  }
  _getLeftOffset() {
    return "ltr" === this.direction ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(t3, e2) {
    t3.save();
    let s2 = 0;
    const i2 = this._getLeftOffset(), r2 = this._getTopOffset();
    for (let n2 = 0, o2 = this._textLines.length; n2 < o2; n2++) {
      const o3 = this.getHeightOfLine(n2), a2 = o3 / this.lineHeight, h2 = this._getLineLeftOffset(n2);
      this._renderTextLine(e2, t3, this._textLines[n2], i2 + h2, r2 + s2 + a2, n2), s2 += o3;
    }
    t3.restore();
  }
  _renderTextFill(t3) {
    (this.fill || this.styleHas("fill")) && this._renderTextCommon(t3, "fillText");
  }
  _renderTextStroke(t3) {
    (this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t3), t3.save(), this._setLineDash(t3, this.strokeDashArray), t3.beginPath(), this._renderTextCommon(t3, "strokeText"), t3.closePath(), t3.restore());
  }
  _renderChars(t3, e2, s2, i2, r2, n2) {
    const o2 = this.getHeightOfLine(n2), a2 = this.textAlign.includes(ho), h2 = this.path, c2 = !a2 && 0 === this.charSpacing && this.isEmptyStyles(n2) && !h2, l2 = "ltr" === this.direction, u2 = "ltr" === this.direction ? 1 : -1, d2 = e2.direction;
    let g2, f2, p2, m2, v2, y2 = "", _2 = 0;
    if (e2.save(), d2 !== this.direction && (e2.canvas.setAttribute("dir", l2 ? "ltr" : "rtl"), e2.direction = l2 ? "ltr" : "rtl", e2.textAlign = l2 ? P : j), r2 -= o2 * this._fontSizeFraction / this.lineHeight, c2)
      return this._renderChar(t3, e2, n2, 0, s2.join(""), i2, r2), void e2.restore();
    for (let o3 = 0, c3 = s2.length - 1; o3 <= c3; o3++)
      m2 = o3 === c3 || this.charSpacing || h2, y2 += s2[o3], p2 = this.__charBounds[n2][o3], 0 === _2 ? (i2 += u2 * (p2.kernedWidth - p2.width), _2 += p2.width) : _2 += p2.kernedWidth, a2 && !m2 && this._reSpaceAndTab.test(s2[o3]) && (m2 = true), m2 || (g2 = g2 || this.getCompleteStyleDeclaration(n2, o3), f2 = this.getCompleteStyleDeclaration(n2, o3 + 1), m2 = Ci(g2, f2, false)), m2 && (h2 ? (e2.save(), e2.translate(p2.renderLeft, p2.renderTop), e2.rotate(p2.angle), this._renderChar(t3, e2, n2, o3, y2, -_2 / 2, 0), e2.restore()) : (v2 = i2, this._renderChar(t3, e2, n2, o3, y2, v2, r2)), y2 = "", g2 = f2, i2 += u2 * _2, _2 = 0);
    e2.restore();
  }
  _applyPatternGradientTransformText(t3) {
    const e2 = et(), s2 = this.width + this.strokeWidth, i2 = this.height + this.strokeWidth, r2 = e2.getContext("2d");
    return e2.width = s2, e2.height = i2, r2.beginPath(), r2.moveTo(0, 0), r2.lineTo(s2, 0), r2.lineTo(s2, i2), r2.lineTo(0, i2), r2.closePath(), r2.translate(s2 / 2, i2 / 2), r2.fillStyle = t3.toLive(r2), this._applyPatternGradientTransform(r2, t3), r2.fill(), r2.createPattern(e2, "no-repeat");
  }
  handleFiller(t3, e2, s2) {
    let i2, r2;
    return It(s2) ? "percentage" === s2.gradientUnits || s2.gradientTransform || s2.patternTransform ? (i2 = -this.width / 2, r2 = -this.height / 2, t3.translate(i2, r2), t3[e2] = this._applyPatternGradientTransformText(s2), { offsetX: i2, offsetY: r2 }) : (t3[e2] = s2.toLive(t3), this._applyPatternGradientTransform(t3, s2)) : (t3[e2] = s2, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(t3, e2) {
    let { stroke: s2, strokeWidth: i2 } = e2;
    return t3.lineWidth = i2, t3.lineCap = this.strokeLineCap, t3.lineDashOffset = this.strokeDashOffset, t3.lineJoin = this.strokeLineJoin, t3.miterLimit = this.strokeMiterLimit, this.handleFiller(t3, "strokeStyle", s2);
  }
  _setFillStyles(t3, e2) {
    let { fill: s2 } = e2;
    return this.handleFiller(t3, "fillStyle", s2);
  }
  _renderChar(t3, e2, s2, i2, r2, n2, o2) {
    const a2 = this._getStyleDeclaration(s2, i2), h2 = this.getCompleteStyleDeclaration(s2, i2), c2 = "fillText" === t3 && h2.fill, l2 = "strokeText" === t3 && h2.stroke && h2.strokeWidth;
    if (l2 || c2) {
      if (e2.save(), e2.font = this._getFontDeclaration(h2), a2.textBackgroundColor && this._removeShadow(e2), a2.deltaY && (o2 += a2.deltaY), c2) {
        const t4 = this._setFillStyles(e2, h2);
        e2.fillText(r2, n2 - t4.offsetX, o2 - t4.offsetY);
      }
      if (l2) {
        const t4 = this._setStrokeStyles(e2, h2);
        e2.strokeText(r2, n2 - t4.offsetX, o2 - t4.offsetY);
      }
      e2.restore();
    }
  }
  setSuperscript(t3, e2) {
    this._setScript(t3, e2, this.superscript);
  }
  setSubscript(t3, e2) {
    this._setScript(t3, e2, this.subscript);
  }
  _setScript(t3, e2, s2) {
    const i2 = this.get2DCursorLocation(t3, true), r2 = this.getValueOfPropertyAt(i2.lineIndex, i2.charIndex, "fontSize"), n2 = this.getValueOfPropertyAt(i2.lineIndex, i2.charIndex, "deltaY"), o2 = { fontSize: r2 * s2.size, deltaY: n2 + r2 * s2.baseline };
    this.setSelectionStyles(o2, t3, e2);
  }
  _getLineLeftOffset(t3) {
    const e2 = this.getLineWidth(t3), s2 = this.width - e2, i2 = this.textAlign, r2 = this.direction, n2 = this.isEndOfWrapping(t3);
    let o2 = 0;
    return i2 === ho || i2 === uo && !n2 || i2 === lo && !n2 || i2 === co && !n2 ? 0 : (i2 === M && (o2 = s2 / 2), i2 === j && (o2 = s2), i2 === uo && (o2 = s2 / 2), i2 === lo && (o2 = s2), "rtl" === r2 && (i2 === j || i2 === ho || i2 === lo ? o2 = 0 : i2 === P || i2 === co ? o2 = -s2 : i2 !== M && i2 !== uo || (o2 = -s2 / 2)), o2);
  }
  _clearCache() {
    this._forceClearCache = false, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(t3) {
    if (void 0 !== this.__lineWidths[t3])
      return this.__lineWidths[t3];
    const { width: e2 } = this.measureLine(t3);
    return this.__lineWidths[t3] = e2, e2;
  }
  _getWidthOfCharSpacing() {
    return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(t3, e2, s2) {
    var i2;
    return null !== (i2 = this._getStyleDeclaration(t3, e2)[s2]) && void 0 !== i2 ? i2 : this[s2];
  }
  _renderTextDecoration(t3, e2) {
    if (!this[e2] && !this.styleHas(e2))
      return;
    let s2 = this._getTopOffset();
    const i2 = this._getLeftOffset(), r2 = this.path, n2 = this._getWidthOfCharSpacing(), o2 = this.offsets[e2];
    for (let a2 = 0, h2 = this._textLines.length; a2 < h2; a2++) {
      const h3 = this.getHeightOfLine(a2);
      if (!this[e2] && !this.styleHas(e2, a2)) {
        s2 += h3;
        continue;
      }
      const c2 = this._textLines[a2], l2 = h3 / this.lineHeight, u2 = this._getLineLeftOffset(a2);
      let d2, g2, f2 = 0, p2 = 0, m2 = this.getValueOfPropertyAt(a2, 0, e2), v2 = this.getValueOfPropertyAt(a2, 0, "fill");
      const y2 = s2 + l2 * (1 - this._fontSizeFraction);
      let _2 = this.getHeightOfChar(a2, 0), x2 = this.getValueOfPropertyAt(a2, 0, "deltaY");
      for (let s3 = 0, n3 = c2.length; s3 < n3; s3++) {
        const n4 = this.__charBounds[a2][s3];
        d2 = this.getValueOfPropertyAt(a2, s3, e2), g2 = this.getValueOfPropertyAt(a2, s3, "fill");
        const h4 = this.getHeightOfChar(a2, s3), c3 = this.getValueOfPropertyAt(a2, s3, "deltaY");
        if (r2 && d2 && g2)
          t3.save(), t3.fillStyle = v2, t3.translate(n4.renderLeft, n4.renderTop), t3.rotate(n4.angle), t3.fillRect(-n4.kernedWidth / 2, o2 * h4 + c3, n4.kernedWidth, this.fontSize / 15), t3.restore();
        else if ((d2 !== m2 || g2 !== v2 || h4 !== _2 || c3 !== x2) && p2 > 0) {
          let e3 = i2 + u2 + f2;
          "rtl" === this.direction && (e3 = this.width - e3 - p2), m2 && v2 && (t3.fillStyle = v2, t3.fillRect(e3, y2 + o2 * _2 + x2, p2, this.fontSize / 15)), f2 = n4.left, p2 = n4.width, m2 = d2, v2 = g2, _2 = h4, x2 = c3;
        } else
          p2 += n4.kernedWidth;
      }
      let C2 = i2 + u2 + f2;
      "rtl" === this.direction && (C2 = this.width - C2 - p2), t3.fillStyle = g2, d2 && g2 && t3.fillRect(C2, y2 + o2 * _2 + x2, p2 - n2, this.fontSize / 15), s2 += h3;
    }
    this._removeShadow(t3);
  }
  _getFontDeclaration() {
    let { fontFamily: t3 = this.fontFamily, fontStyle: e2 = this.fontStyle, fontWeight: s2 = this.fontWeight, fontSize: i2 = this.fontSize } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = arguments.length > 1 ? arguments[1] : void 0;
    const n2 = t3.includes("'") || t3.includes('"') || t3.includes(",") || __o.genericFonts.includes(t3.toLowerCase()) ? t3 : '"'.concat(t3, '"');
    return [e2, s2, "".concat(r2 ? this.CACHE_FONT_SIZE : i2, "px"), n2].join(" ");
  }
  render(t3) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(t3)));
  }
  graphemeSplit(t3) {
    return yi(t3);
  }
  _splitTextIntoLines(t3) {
    const e2 = t3.split(this._reNewline), s2 = new Array(e2.length), i2 = ["\n"];
    let r2 = [];
    for (let t4 = 0; t4 < e2.length; t4++)
      s2[t4] = this.graphemeSplit(e2[t4]), r2 = r2.concat(s2[t4], i2);
    return r2.pop(), { _unwrappedLines: s2, lines: e2, graphemeText: r2, graphemeLines: s2 };
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return e(e({}, super.toObject([...no, ...t3])), {}, { styles: bi(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(t3, e2) {
    const { textLayoutProperties: s2 } = this.constructor;
    super.set(t3, e2);
    let i2 = false, r2 = false;
    if ("object" == typeof t3)
      for (const e3 in t3)
        "path" === e3 && this.setPathInfo(), i2 = i2 || s2.includes(e3), r2 = r2 || "path" === e3;
    else
      i2 = s2.includes(t3), r2 = "path" === t3;
    return r2 && this.setPathInfo(), i2 && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(t3, s2, r2) {
    const n2 = er(t3, __o.ATTRIBUTE_NAMES, r2), o2 = e(e({}, s2), n2), { textAnchor: a2 = P, textDecoration: h2 = "", dx: c2 = 0, dy: l2 = 0, top: u2 = 0, left: d2 = 0, fontSize: g2 = k, strokeWidth: f2 = 1 } = o2, p2 = i(o2, vo), m2 = new this((t3.textContent || "").replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "), e({ left: d2 + c2, top: u2 + l2, underline: h2.includes("underline"), overline: h2.includes("overline"), linethrough: h2.includes("line-through"), strokeWidth: 0, fontSize: g2 }, p2)), v2 = m2.getScaledHeight() / m2.height, y2 = ((m2.height + m2.strokeWidth) * m2.lineHeight - m2.height) * v2, _2 = m2.getScaledHeight() + y2;
    let x2 = 0;
    return a2 === M && (x2 = m2.getScaledWidth() / 2), a2 === j && (x2 = m2.getScaledWidth()), m2.set({ left: m2.left - x2, top: m2.top - (_2 - m2.fontSize * (0.07 + m2._fontSizeFraction)) / m2.lineHeight, strokeWidth: f2 }), m2;
  }
  static fromObject(t3) {
    return this._fromObject(e(e({}, t3), {}, { styles: wi(t3.styles || {}, t3.text) }), { extraParam: "text" });
  }
};
s(_o, "textLayoutProperties", ro), s(_o, "cacheProperties", [...Os, ...no]), s(_o, "ownDefaults", ao), s(_o, "type", "Text"), s(_o, "genericFonts", ["sans-serif", "serif", "cursive", "fantasy", "monospace"]), s(_o, "ATTRIBUTE_NAMES", Si.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), ci(_o, [class extends Te {
  _toSVG() {
    const t3 = this._getSVGLeftTopOffsets(), e2 = this._getSVGTextAndBg(t3.textTop, t3.textLeft);
    return this._wrapSVGTextAndBg(e2);
  }
  toSVG(t3) {
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: t3, noStyle: true, withShadow: true });
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(t3) {
    let { textBgRects: e2, textSpans: s2 } = t3;
    const i2 = this.getSvgTextDecoration(this);
    return [e2.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="'.concat(this.fontFamily.replace(po, "'"), '" ') : "", this.fontSize ? 'font-size="'.concat(this.fontSize, '" ') : "", this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", i2 ? 'text-decoration="'.concat(i2, '" ') : "", "rtl" === this.direction ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(true), '"', this.addPaintOrder(), " >", s2.join(""), "</text>\n"];
  }
  _getSVGTextAndBg(t3, e2) {
    const s2 = [], i2 = [];
    let r2, n2 = t3;
    this.backgroundColor && i2.push(...mo(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let t4 = 0, o2 = this._textLines.length; t4 < o2; t4++)
      r2 = this._getLineLeftOffset(t4), "rtl" === this.direction && (r2 += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", t4)) && this._setSVGTextLineBg(i2, t4, e2 + r2, n2), this._setSVGTextLineText(s2, t4, e2 + r2, n2), n2 += this.getHeightOfLine(t4);
    return { textSpans: s2, textBgRects: i2 };
  }
  _createTextCharSpan(t3, e2, s2, i2) {
    const r2 = this.getSvgSpanStyles(e2, t3 !== t3.trim() || !!t3.match(fo)), n2 = r2 ? 'style="'.concat(r2, '"') : "", o2 = e2.deltaY, h2 = o2 ? ' dy="'.concat(jt(o2, a.NUM_FRACTION_DIGITS), '" ') : "";
    return '<tspan x="'.concat(jt(s2, a.NUM_FRACTION_DIGITS), '" y="').concat(jt(i2, a.NUM_FRACTION_DIGITS), '" ').concat(h2).concat(n2, ">").concat(vi(t3), "</tspan>");
  }
  _setSVGTextLineText(t3, e2, s2, i2) {
    const r2 = this.getHeightOfLine(e2), n2 = this.textAlign.includes(ho), o2 = this._textLines[e2];
    let a2, h2, c2, l2, u2, d2 = "", g2 = 0;
    i2 += r2 * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let r3 = 0, f2 = o2.length - 1; r3 <= f2; r3++)
      u2 = r3 === f2 || this.charSpacing, d2 += o2[r3], c2 = this.__charBounds[e2][r3], 0 === g2 ? (s2 += c2.kernedWidth - c2.width, g2 += c2.width) : g2 += c2.kernedWidth, n2 && !u2 && this._reSpaceAndTab.test(o2[r3]) && (u2 = true), u2 || (a2 = a2 || this.getCompleteStyleDeclaration(e2, r3), h2 = this.getCompleteStyleDeclaration(e2, r3 + 1), u2 = Ci(a2, h2, true)), u2 && (l2 = this._getStyleDeclaration(e2, r3), t3.push(this._createTextCharSpan(d2, l2, s2, i2)), d2 = "", a2 = h2, "rtl" === this.direction ? s2 -= g2 : s2 += g2, g2 = 0);
  }
  _setSVGTextLineBg(t3, e2, s2, i2) {
    const r2 = this._textLines[e2], n2 = this.getHeightOfLine(e2) / this.lineHeight;
    let o2, a2 = 0, h2 = 0, c2 = this.getValueOfPropertyAt(e2, 0, "textBackgroundColor");
    for (let l2 = 0; l2 < r2.length; l2++) {
      const { left: r3, width: u2, kernedWidth: d2 } = this.__charBounds[e2][l2];
      o2 = this.getValueOfPropertyAt(e2, l2, "textBackgroundColor"), o2 !== c2 ? (c2 && t3.push(...mo(c2, s2 + h2, i2, a2, n2)), h2 = r3, a2 = u2, c2 = o2) : a2 += d2;
    }
    o2 && t3.push(...mo(c2, s2 + h2, i2, a2, n2));
  }
  _getSVGLineTopOffset(t3) {
    let e2, s2 = 0;
    for (e2 = 0; e2 < t3; e2++)
      s2 += this.getHeightOfLine(e2);
    const i2 = this.getHeightOfLine(e2);
    return { lineTop: s2, offset: (this._fontSizeMult - this._fontSizeFraction) * i2 / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(t3) {
    return "".concat(super.getSvgStyles(t3), " white-space: pre;");
  }
  getSvgSpanStyles(t3, e2) {
    const { fontFamily: s2, strokeWidth: i2, stroke: r2, fill: n2, fontSize: o2, fontStyle: a2, fontWeight: h2, deltaY: c2 } = t3, l2 = this.getSvgTextDecoration(t3);
    return [r2 ? Bt("stroke", r2) : "", i2 ? "stroke-width: ".concat(i2, "; ") : "", s2 ? "font-family: ".concat(s2.includes("'") || s2.includes('"') ? s2 : "'".concat(s2, "'"), "; ") : "", o2 ? "font-size: ".concat(o2, "px; ") : "", a2 ? "font-style: ".concat(a2, "; ") : "", h2 ? "font-weight: ".concat(h2, "; ") : "", l2 ? "text-decoration: ".concat(l2, "; ") : l2, n2 ? Bt("fill", n2) : "", c2 ? "baseline-shift: ".concat(-c2, "; ") : "", e2 ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(t3) {
    return ["overline", "underline", "line-through"].filter((e2) => t3[e2.replace("-", "")]).join(" ");
  }
}]), I.setClass(_o), I.setSVGClass(_o);
var xo = class {
  constructor(t3) {
    s(this, "target", void 0), s(this, "__mouseDownInPlace", false), s(this, "__dragStartFired", false), s(this, "__isDraggingOver", false), s(this, "__dragStartSelection", void 0), s(this, "__dragImageDisposer", void 0), s(this, "_dispose", void 0), this.target = t3;
    const e2 = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      e2.forEach((t4) => t4()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(t3) {
    const e2 = this.target, s2 = e2.getSelectionStartFromPointer(t3);
    return e2.isEditing && s2 >= e2.selectionStart && s2 <= e2.selectionEnd && e2.selectionStart < e2.selectionEnd;
  }
  start(t3) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(t3);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(t3) {
    const e2 = this.isActive();
    return e2 && !this.__dragStartFired && (this.target.setCursorByClick(t3), this.target.initDelayedCursor(true)), this.__mouseDownInPlace = false, this.__dragStartFired = false, this.__isDraggingOver = false, e2;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(t3, e2) {
    var s2;
    let { selectionStart: i2, selectionEnd: r2 } = e2;
    const n2 = this.target, o2 = n2.canvas, a2 = new U(n2.flipX ? -1 : 1, n2.flipY ? -1 : 1), h2 = n2._getCursorBoundaries(i2), c2 = new U(h2.left + h2.leftOffset, h2.top + h2.topOffset).multiply(a2).transform(n2.calcTransformMatrix()), l2 = o2.getScenePoint(t3).subtract(c2), u2 = n2.getCanvasRetinaScaling(), d2 = n2.getBoundingRect(), g2 = c2.subtract(new U(d2.left, d2.top)), f2 = o2.viewportTransform, p2 = g2.add(l2).transform(f2, true), m2 = n2.backgroundColor, v2 = Ss(n2.styles);
    n2.backgroundColor = "";
    const y2 = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    n2.setSelectionStyles(y2, 0, i2), n2.setSelectionStyles(y2, r2, n2.text.length), n2.dirty = true;
    const _2 = n2.toCanvasElement({ enableRetinaScaling: o2.enableRetinaScaling, viewportTransform: true });
    n2.backgroundColor = m2, n2.styles = v2, n2.dirty = true, Ut(_2, { position: "fixed", left: "".concat(-_2.width, "px"), border: F, width: "".concat(_2.width / u2, "px"), height: "".concat(_2.height / u2, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      _2.remove();
    }, Ht(t3.target || this.target.hiddenTextarea).body.appendChild(_2), null === (s2 = t3.dataTransfer) || void 0 === s2 || s2.setDragImage(_2, p2.x, p2.y);
  }
  onDragStart(t3) {
    this.__dragStartFired = true;
    const s2 = this.target, i2 = this.isActive();
    if (i2 && t3.dataTransfer) {
      const i3 = this.__dragStartSelection = { selectionStart: s2.selectionStart, selectionEnd: s2.selectionEnd }, r2 = s2._text.slice(i3.selectionStart, i3.selectionEnd).join(""), n2 = e({ text: s2.text, value: r2 }, i3);
      t3.dataTransfer.setData("text/plain", r2), t3.dataTransfer.setData("application/fabric", JSON.stringify({ value: r2, styles: s2.getSelectionStyles(i3.selectionStart, i3.selectionEnd, true) })), t3.dataTransfer.effectAllowed = "copyMove", this.setDragImage(t3, n2);
    }
    return s2.abortCursorAnimation(), i2;
  }
  canDrop(t3) {
    if (this.target.editable && !this.target.getActiveControl() && !t3.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const e2 = this.target.getSelectionStartFromPointer(t3), s2 = this.__dragStartSelection;
        return e2 < s2.selectionStart || e2 > s2.selectionEnd;
      }
      return true;
    }
    return false;
  }
  targetCanDrop(t3) {
    return this.target.canDrop(t3);
  }
  dragEnterHandler(t3) {
    let { e: e2 } = t3;
    const s2 = this.targetCanDrop(e2);
    !this.__isDraggingOver && s2 && (this.__isDraggingOver = true);
  }
  dragOverHandler(t3) {
    const { e: e2 } = t3, s2 = this.targetCanDrop(e2);
    !this.__isDraggingOver && s2 ? this.__isDraggingOver = true : this.__isDraggingOver && !s2 && (this.__isDraggingOver = false), this.__isDraggingOver && (e2.preventDefault(), t3.canDrop = true, t3.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = false);
  }
  dropHandler(t3) {
    var e2;
    const { e: s2 } = t3, i2 = s2.defaultPrevented;
    this.__isDraggingOver = false, s2.preventDefault();
    let r2 = null === (e2 = s2.dataTransfer) || void 0 === e2 ? void 0 : e2.getData("text/plain");
    if (r2 && !i2) {
      const e3 = this.target, i3 = e3.canvas;
      let n2 = e3.getSelectionStartFromPointer(s2);
      const { styles: o2 } = s2.dataTransfer.types.includes("application/fabric") ? JSON.parse(s2.dataTransfer.getData("application/fabric")) : {}, a2 = r2[Math.max(0, r2.length - 1)], h2 = 0;
      if (this.__dragStartSelection) {
        const t4 = this.__dragStartSelection.selectionStart, s3 = this.__dragStartSelection.selectionEnd;
        n2 > t4 && n2 <= s3 ? n2 = t4 : n2 > s3 && (n2 -= s3 - t4), e3.removeChars(t4, s3), delete this.__dragStartSelection;
      }
      e3._reNewline.test(a2) && (e3._reNewline.test(e3._text[n2]) || n2 === e3._text.length) && (r2 = r2.trimEnd()), t3.didDrop = true, t3.dropTarget = e3, e3.insertChars(r2, o2, n2), i3.setActiveObject(e3), e3.enterEditing(s2), e3.selectionStart = Math.min(n2 + h2, e3._text.length), e3.selectionEnd = Math.min(e3.selectionStart + r2.length, e3._text.length), e3.hiddenTextarea.value = e3.text, e3._updateTextarea(), e3.hiddenTextarea.focus(), e3.fire("changed", { index: n2 + h2, action: "drop" }), i3.fire("text:changed", { target: e3 }), i3.contextTopDirty = true, i3.requestRenderAll();
    }
  }
  dragEndHandler(t3) {
    let { e: e2 } = t3;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var s2;
      const t4 = this.target, i2 = this.target.canvas, { selectionStart: r2, selectionEnd: n2 } = this.__dragStartSelection, o2 = (null === (s2 = e2.dataTransfer) || void 0 === s2 ? void 0 : s2.dropEffect) || F;
      o2 === F ? (t4.selectionStart = r2, t4.selectionEnd = n2, t4._updateTextarea(), t4.hiddenTextarea.focus()) : (t4.clearContextTop(), "move" === o2 && (t4.removeChars(r2, n2), t4.selectionStart = t4.selectionEnd = r2, t4.hiddenTextarea && (t4.hiddenTextarea.value = t4.text), t4._updateTextarea(), t4.fire("changed", { index: r2, action: "dragend" }), i2.fire("text:changed", { target: t4 }), i2.requestRenderAll()), t4.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = false;
  }
  dispose() {
    this._dispose && this._dispose();
  }
};
var Co = /[ \n\.,;!\?\-]/;
var bo = class extends _o {
  constructor() {
    super(...arguments), s(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(t3) {
    return this.isEditing && this.exitEditing(), this.selected = false, super.onDeselect(t3);
  }
  _animateCursor(t3) {
    let { toValue: e2, duration: s2, delay: i2, onComplete: r2 } = t3;
    return ze({ startValue: this._currentCursorOpacity, endValue: e2, duration: s2, delay: i2, onComplete: r2, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (t4) => {
      this._currentCursorOpacity = t4, this.renderCursorOrSelection();
    } });
  }
  _tick(t3) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(t3 || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var t3;
    null === (t3 = this._currentTickCompleteState) || void 0 === t3 || t3.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(t3) {
    this.abortCursorAnimation(), this._tick(t3 ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let t3 = false;
    [this._currentTickState, this._currentTickCompleteState].forEach((e2) => {
      e2 && !e2.isDone() && (t3 = true, e2.abort());
    }), this._currentCursorOpacity = 1, t3 && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((t3) => !t3 || t3.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(t3) {
    let e2 = 0, s2 = t3 - 1;
    if (this._reSpace.test(this._text[s2]))
      for (; this._reSpace.test(this._text[s2]); )
        e2++, s2--;
    for (; /\S/.test(this._text[s2]) && s2 > -1; )
      e2++, s2--;
    return t3 - e2;
  }
  findWordBoundaryRight(t3) {
    let e2 = 0, s2 = t3;
    if (this._reSpace.test(this._text[s2]))
      for (; this._reSpace.test(this._text[s2]); )
        e2++, s2++;
    for (; /\S/.test(this._text[s2]) && s2 < this._text.length; )
      e2++, s2++;
    return t3 + e2;
  }
  findLineBoundaryLeft(t3) {
    let e2 = 0, s2 = t3 - 1;
    for (; !/\n/.test(this._text[s2]) && s2 > -1; )
      e2++, s2--;
    return t3 - e2;
  }
  findLineBoundaryRight(t3) {
    let e2 = 0, s2 = t3;
    for (; !/\n/.test(this._text[s2]) && s2 < this._text.length; )
      e2++, s2++;
    return t3 + e2;
  }
  searchWordBoundary(t3, e2) {
    const s2 = this._text;
    let i2 = t3 > 0 && this._reSpace.test(s2[t3]) && (-1 === e2 || !L.test(s2[t3 - 1])) ? t3 - 1 : t3, r2 = s2[i2];
    for (; i2 > 0 && i2 < s2.length && !Co.test(r2); )
      i2 += e2, r2 = s2[i2];
    return -1 === e2 && Co.test(r2) && i2++, i2;
  }
  selectWord(t3) {
    t3 = t3 || this.selectionStart;
    const e2 = this.searchWordBoundary(t3, -1), s2 = Math.max(e2, this.searchWordBoundary(t3, 1));
    this.selectionStart = e2, this.selectionEnd = s2, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(t3) {
    t3 = t3 || this.selectionStart;
    const e2 = this.findLineBoundaryLeft(t3), s2 = this.findLineBoundaryRight(t3);
    return this.selectionStart = e2, this.selectionEnd = s2, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  enterEditing(t3) {
    !this.isEditing && this.editable && (this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = true, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered", t3 ? { e: t3 } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e: t3 }), this.canvas.requestRenderAll()));
  }
  updateSelectionOnMouseMove(t3) {
    if (this.getActiveControl())
      return;
    const e2 = this.hiddenTextarea;
    Ht(e2).activeElement !== e2 && e2.focus();
    const s2 = this.getSelectionStartFromPointer(t3), i2 = this.selectionStart, r2 = this.selectionEnd;
    (s2 === this.__selectionStartOnMouseDown && i2 !== r2 || i2 !== s2 && r2 !== s2) && (s2 > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = s2) : (this.selectionStart = s2, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i2 && this.selectionEnd === r2 || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = false, this.lockMovementX = this.lockMovementY = true;
  }
  fromStringToGraphemeSelection(t3, e2, s2) {
    const i2 = s2.slice(0, t3), r2 = this.graphemeSplit(i2).length;
    if (t3 === e2)
      return { selectionStart: r2, selectionEnd: r2 };
    const n2 = s2.slice(t3, e2);
    return { selectionStart: r2, selectionEnd: r2 + this.graphemeSplit(n2).length };
  }
  fromGraphemeToStringSelection(t3, e2, s2) {
    const i2 = s2.slice(0, t3).join("").length;
    if (t3 === e2)
      return { selectionStart: i2, selectionEnd: i2 };
    return { selectionStart: i2, selectionEnd: i2 + s2.slice(t3, e2).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const t3 = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = t3.selectionStart, this.hiddenTextarea.selectionEnd = t3.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea)
      return;
    this.cursorOffsetCache = {};
    const t3 = this.hiddenTextarea;
    this.text = t3.value, this.set("dirty", true), this.initDimensions(), this.setCoords();
    const e2 = this.fromStringToGraphemeSelection(t3.selectionStart, t3.selectionEnd, t3.value);
    this.selectionEnd = this.selectionStart = e2.selectionEnd, this.inCompositionMode || (this.selectionStart = e2.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const t3 = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = t3.left, this.hiddenTextarea.style.top = t3.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas)
      return { left: "1px", top: "1px" };
    const t3 = this.inCompositionMode ? this.compositionStart : this.selectionStart, e2 = this._getCursorBoundaries(t3), s2 = this.get2DCursorLocation(t3), i2 = s2.lineIndex, r2 = s2.charIndex, n2 = this.getValueOfPropertyAt(i2, r2, "fontSize") * this.lineHeight, o2 = e2.leftOffset, a2 = this.getCanvasRetinaScaling(), h2 = this.canvas.upperCanvasEl, c2 = h2.width / a2, l2 = h2.height / a2, u2 = c2 - n2, d2 = l2 - n2, g2 = new U(e2.left + o2, e2.top + e2.topOffset + n2).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new U(h2.clientWidth / c2, h2.clientHeight / l2));
    return g2.x < 0 && (g2.x = 0), g2.x > u2 && (g2.x = u2), g2.y < 0 && (g2.y = 0), g2.y > d2 && (g2.y = d2), g2.x += this.canvas._offset.left, g2.y += this.canvas._offset.top, { left: "".concat(g2.x, "px"), top: "".concat(g2.y, "px"), fontSize: "".concat(n2, "px"), charHeight: n2 };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const t3 = this.hiddenTextarea;
    this.selected = false, this.isEditing = false, t3 && (t3.blur && t3.blur(), t3.parentNode && t3.parentNode.removeChild(t3)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditing() {
    const t3 = this._textBeforeEdit !== this.text;
    return this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), t3 && this.fire("modified"), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), t3 && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const t3 in this.styles)
      this._textLines[t3] || delete this.styles[t3];
  }
  removeStyleFromTo(t3, e2) {
    const { lineIndex: s2, charIndex: i2 } = this.get2DCursorLocation(t3, true), { lineIndex: r2, charIndex: n2 } = this.get2DCursorLocation(e2, true);
    if (s2 !== r2) {
      if (this.styles[s2])
        for (let t4 = i2; t4 < this._unwrappedTextLines[s2].length; t4++)
          delete this.styles[s2][t4];
      if (this.styles[r2])
        for (let t4 = n2; t4 < this._unwrappedTextLines[r2].length; t4++) {
          const e3 = this.styles[r2][t4];
          e3 && (this.styles[s2] || (this.styles[s2] = {}), this.styles[s2][i2 + t4 - n2] = e3);
        }
      for (let t4 = s2 + 1; t4 <= r2; t4++)
        delete this.styles[t4];
      this.shiftLineStyles(r2, s2 - r2);
    } else if (this.styles[s2]) {
      const t4 = this.styles[s2], e3 = n2 - i2;
      for (let e4 = i2; e4 < n2; e4++)
        delete t4[e4];
      for (const i3 in this.styles[s2]) {
        const s3 = parseInt(i3, 10);
        s3 >= n2 && (t4[s3 - e3] = t4[i3], delete t4[i3]);
      }
    }
  }
  shiftLineStyles(t3, e2) {
    const s2 = Object.assign({}, this.styles);
    for (const i2 in this.styles) {
      const r2 = parseInt(i2, 10);
      r2 > t3 && (this.styles[r2 + e2] = s2[r2], s2[r2 - e2] || delete this.styles[r2]);
    }
  }
  insertNewlineStyleObject(t3, s2, i2, r2) {
    const n2 = {}, o2 = this._unwrappedTextLines[t3].length, a2 = o2 === s2;
    let h2 = false;
    i2 || (i2 = 1), this.shiftLineStyles(t3, i2);
    const c2 = this.styles[t3] ? this.styles[t3][0 === s2 ? s2 : s2 - 1] : void 0;
    for (const e2 in this.styles[t3]) {
      const i3 = parseInt(e2, 10);
      i3 >= s2 && (h2 = true, n2[i3 - s2] = this.styles[t3][e2], a2 && 0 === s2 || delete this.styles[t3][e2]);
    }
    let l2 = false;
    for (h2 && !a2 && (this.styles[t3 + i2] = n2, l2 = true), (l2 || o2 > s2) && i2--; i2 > 0; )
      r2 && r2[i2 - 1] ? this.styles[t3 + i2] = { 0: e({}, r2[i2 - 1]) } : c2 ? this.styles[t3 + i2] = { 0: e({}, c2) } : delete this.styles[t3 + i2], i2--;
    this._forceClearCache = true;
  }
  insertCharStyleObject(t3, s2, i2, r2) {
    this.styles || (this.styles = {});
    const n2 = this.styles[t3], o2 = n2 ? e({}, n2) : {};
    i2 || (i2 = 1);
    for (const t4 in o2) {
      const e2 = parseInt(t4, 10);
      e2 >= s2 && (n2[e2 + i2] = o2[e2], o2[e2 - i2] || delete n2[e2]);
    }
    if (this._forceClearCache = true, r2) {
      for (; i2--; )
        Object.keys(r2[i2]).length && (this.styles[t3] || (this.styles[t3] = {}), this.styles[t3][s2 + i2] = e({}, r2[i2]));
      return;
    }
    if (!n2)
      return;
    const a2 = n2[s2 ? s2 - 1 : 1];
    for (; a2 && i2--; )
      this.styles[t3][s2 + i2] = e({}, a2);
  }
  insertNewStyleBlock(t3, e2, s2) {
    const i2 = this.get2DCursorLocation(e2, true), r2 = [0];
    let n2, o2 = 0;
    for (let e3 = 0; e3 < t3.length; e3++)
      "\n" === t3[e3] ? (o2++, r2[o2] = 0) : r2[o2]++;
    for (r2[0] > 0 && (this.insertCharStyleObject(i2.lineIndex, i2.charIndex, r2[0], s2), s2 = s2 && s2.slice(r2[0] + 1)), o2 && this.insertNewlineStyleObject(i2.lineIndex, i2.charIndex + r2[0], o2), n2 = 1; n2 < o2; n2++)
      r2[n2] > 0 ? this.insertCharStyleObject(i2.lineIndex + n2, 0, r2[n2], s2) : s2 && this.styles[i2.lineIndex + n2] && s2[0] && (this.styles[i2.lineIndex + n2][0] = s2[0]), s2 = s2 && s2.slice(r2[n2] + 1);
    r2[n2] > 0 && this.insertCharStyleObject(i2.lineIndex + n2, 0, r2[n2], s2);
  }
  removeChars(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t3 + 1;
    this.removeStyleFromTo(t3, e2), this._text.splice(t3, e2 - t3), this.text = this._text.join(""), this.set("dirty", true), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(t3, e2, s2) {
    let i2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : s2;
    i2 > s2 && this.removeStyleFromTo(s2, i2);
    const r2 = this.graphemeSplit(t3);
    this.insertNewStyleBlock(r2, s2, e2), this._text = [...this._text.slice(0, s2), ...r2, ...this._text.slice(i2)], this.text = this._text.join(""), this.set("dirty", true), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(t3, e2, s2) {
    s2 <= t3 ? (e2 === t3 ? this._selectionDirection = P : this._selectionDirection === j && (this._selectionDirection = P, this.selectionEnd = t3), this.selectionStart = s2) : s2 > t3 && s2 < e2 ? this._selectionDirection === j ? this.selectionEnd = s2 : this.selectionStart = s2 : (e2 === t3 ? this._selectionDirection = j : this._selectionDirection === P && (this._selectionDirection = j, this.selectionStart = e2), this.selectionEnd = s2);
  }
};
var wo = class extends bo {
  initHiddenTextarea() {
    const t3 = this.canvas && Ht(this.canvas.getElement()) || v(), e2 = t3.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off" }).map((t4) => {
      let [s3, i3] = t4;
      return e2.setAttribute(s3, i3);
    });
    const { top: s2, left: i2, fontSize: r2 } = this._calcTextareaPosition();
    e2.style.cssText = "position: absolute; top: ".concat(s2, "; left: ").concat(i2, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(r2, ";"), (this.hiddenTextareaContainer || t3.body).appendChild(e2), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((t4) => {
      let [s3, i3] = t4;
      return e2.addEventListener(s3, this[i3].bind(this));
    }), this.hiddenTextarea = e2;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(t3) {
    if (!this.isEditing)
      return;
    const e2 = "rtl" === this.direction ? this.keysMapRtl : this.keysMap;
    if (t3.keyCode in e2)
      this[e2[t3.keyCode]](t3);
    else {
      if (!(t3.keyCode in this.ctrlKeysMapDown) || !t3.ctrlKey && !t3.metaKey)
        return;
      this[this.ctrlKeysMapDown[t3.keyCode]](t3);
    }
    t3.stopImmediatePropagation(), t3.preventDefault(), t3.keyCode >= 33 && t3.keyCode <= 40 ? (this.inCompositionMode = false, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(t3) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = false : t3.keyCode in this.ctrlKeysMapUp && (t3.ctrlKey || t3.metaKey) && (this[this.ctrlKeysMapUp[t3.keyCode]](t3), t3.stopImmediatePropagation(), t3.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(t3) {
    const e2 = this.fromPaste;
    if (this.fromPaste = false, t3 && t3.stopPropagation(), !this.isEditing)
      return;
    const s2 = () => {
      this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if ("" === this.hiddenTextarea.value)
      return this.styles = {}, void s2();
    const i2 = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, r2 = this._text.length, n2 = i2.length, o2 = this.selectionStart, h2 = this.selectionEnd, c2 = o2 !== h2;
    let l2, u2, d2, g2, f2 = n2 - r2;
    const p2 = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), v2 = o2 > p2.selectionStart;
    c2 ? (u2 = this._text.slice(o2, h2), f2 += h2 - o2) : n2 < r2 && (u2 = v2 ? this._text.slice(h2 + f2, h2) : this._text.slice(o2, o2 - f2));
    const y2 = i2.slice(p2.selectionEnd - f2, p2.selectionEnd);
    if (u2 && u2.length && (y2.length && (l2 = this.getSelectionStyles(o2, o2 + 1, false), l2 = y2.map(() => l2[0])), c2 ? (d2 = o2, g2 = h2) : v2 ? (d2 = h2 - u2.length, g2 = h2) : (d2 = h2, g2 = h2 + u2.length), this.removeStyleFromTo(d2, g2)), y2.length) {
      const { copyPasteData: t4 } = m();
      e2 && y2.join("") === t4.copiedText && !a.disableStyleCopyPaste && (l2 = t4.copiedTextStyle), this.insertNewStyleBlock(y2, o2, l2);
    }
    s2();
  }
  onCompositionStart() {
    this.inCompositionMode = true;
  }
  onCompositionEnd() {
    this.inCompositionMode = false;
  }
  onCompositionUpdate(t3) {
    let { target: e2 } = t3;
    const { selectionStart: s2, selectionEnd: i2 } = e2;
    this.compositionStart = s2, this.compositionEnd = i2, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd)
      return;
    const { copyPasteData: t3 } = m();
    t3.copiedText = this.getSelectedText(), a.disableStyleCopyPaste ? t3.copiedTextStyle = void 0 : t3.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true), this._copyDone = true;
  }
  paste() {
    this.fromPaste = true;
  }
  _getWidthBeforeCursor(t3, e2) {
    let s2, i2 = this._getLineLeftOffset(t3);
    return e2 > 0 && (s2 = this.__charBounds[t3][e2 - 1], i2 += s2.left + s2.width), i2;
  }
  getDownCursorOffset(t3, e2) {
    const s2 = this._getSelectionForOffset(t3, e2), i2 = this.get2DCursorLocation(s2), r2 = i2.lineIndex;
    if (r2 === this._textLines.length - 1 || t3.metaKey || 34 === t3.keyCode)
      return this._text.length - s2;
    const n2 = i2.charIndex, o2 = this._getWidthBeforeCursor(r2, n2), a2 = this._getIndexOnLine(r2 + 1, o2);
    return this._textLines[r2].slice(n2).length + a2 + 1 + this.missingNewlineOffset(r2);
  }
  _getSelectionForOffset(t3, e2) {
    return t3.shiftKey && this.selectionStart !== this.selectionEnd && e2 ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(t3, e2) {
    const s2 = this._getSelectionForOffset(t3, e2), i2 = this.get2DCursorLocation(s2), r2 = i2.lineIndex;
    if (0 === r2 || t3.metaKey || 33 === t3.keyCode)
      return -s2;
    const n2 = i2.charIndex, o2 = this._getWidthBeforeCursor(r2, n2), a2 = this._getIndexOnLine(r2 - 1, o2), h2 = this._textLines[r2].slice(0, n2), c2 = this.missingNewlineOffset(r2 - 1);
    return -this._textLines[r2 - 1].length + a2 - h2.length + (1 - c2);
  }
  _getIndexOnLine(t3, e2) {
    const s2 = this._textLines[t3];
    let i2, r2, n2 = this._getLineLeftOffset(t3), o2 = 0;
    for (let a2 = 0, h2 = s2.length; a2 < h2; a2++)
      if (i2 = this.__charBounds[t3][a2].width, n2 += i2, n2 > e2) {
        r2 = true;
        const t4 = n2 - i2, s3 = n2, h3 = Math.abs(t4 - e2);
        o2 = Math.abs(s3 - e2) < h3 ? a2 : a2 - 1;
        break;
      }
    return r2 || (o2 = s2.length - 1), o2;
  }
  moveCursorDown(t3) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", t3);
  }
  moveCursorUp(t3) {
    0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorUpOrDown("Up", t3);
  }
  _moveCursorUpOrDown(t3, e2) {
    const s2 = this["get".concat(t3, "CursorOffset")](e2, this._selectionDirection === j);
    if (e2.shiftKey ? this.moveCursorWithShift(s2) : this.moveCursorWithoutShift(s2), 0 !== s2) {
      const t4 = this.text.length;
      this.selectionStart = Ie(0, this.selectionStart, t4), this.selectionEnd = Ie(0, this.selectionEnd, t4), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(t3) {
    const e2 = this._selectionDirection === P ? this.selectionStart + t3 : this.selectionEnd + t3;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e2), 0 !== t3;
  }
  moveCursorWithoutShift(t3) {
    return t3 < 0 ? (this.selectionStart += t3, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t3, this.selectionStart = this.selectionEnd), 0 !== t3;
  }
  moveCursorLeft(t3) {
    0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorLeftOrRight("Left", t3);
  }
  _move(t3, e2, s2) {
    let i2;
    if (t3.altKey)
      i2 = this["findWordBoundary".concat(s2)](this[e2]);
    else {
      if (!t3.metaKey && 35 !== t3.keyCode && 36 !== t3.keyCode)
        return this[e2] += "Left" === s2 ? -1 : 1, true;
      i2 = this["findLineBoundary".concat(s2)](this[e2]);
    }
    return void 0 !== i2 && this[e2] !== i2 && (this[e2] = i2, true);
  }
  _moveLeft(t3, e2) {
    return this._move(t3, e2, "Left");
  }
  _moveRight(t3, e2) {
    return this._move(t3, e2, "Right");
  }
  moveCursorLeftWithoutShift(t3) {
    let e2 = true;
    return this._selectionDirection = P, this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e2 = this._moveLeft(t3, "selectionStart")), this.selectionEnd = this.selectionStart, e2;
  }
  moveCursorLeftWithShift(t3) {
    return this._selectionDirection === j && this.selectionStart !== this.selectionEnd ? this._moveLeft(t3, "selectionEnd") : 0 !== this.selectionStart ? (this._selectionDirection = P, this._moveLeft(t3, "selectionStart")) : void 0;
  }
  moveCursorRight(t3) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", t3);
  }
  _moveCursorLeftOrRight(t3, e2) {
    const s2 = "moveCursor".concat(t3).concat(e2.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[s2](e2) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(t3) {
    return this._selectionDirection === P && this.selectionStart !== this.selectionEnd ? this._moveRight(t3, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = j, this._moveRight(t3, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(t3) {
    let e2 = true;
    return this._selectionDirection = j, this.selectionStart === this.selectionEnd ? (e2 = this._moveRight(t3, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e2;
  }
};
var So = (t3) => !!t3.button;
var To = class extends wo {
  constructor() {
    super(...arguments), s(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler), this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown), this.draggableTextDelegate = new xo(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(t3) {
    return this.draggableTextDelegate.onDragStart(t3);
  }
  canDrop(t3) {
    return this.draggableTextDelegate.canDrop(t3);
  }
  onMouseDown(t3) {
    if (!this.canvas)
      return;
    this.__newClickTime = +/* @__PURE__ */ new Date();
    const e2 = t3.pointer;
    this.isTripleClick(e2) && (this.fire("tripleclick", t3), se(t3.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e2, this.__lastSelected = this.selected && !this.getActiveControl();
  }
  isTripleClick(t3) {
    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t3.x && this.__lastPointer.y === t3.y;
  }
  doubleClickHandler(t3) {
    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(t3.e));
  }
  tripleClickHandler(t3) {
    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(t3.e));
  }
  _mouseDownHandler(t3) {
    let { e: e2 } = t3;
    this.canvas && this.editable && !So(e2) && !this.getActiveControl() && (this.draggableTextDelegate.start(e2) || (this.canvas.textEditingManager.register(this), this.selected && (this.inCompositionMode = false, this.setCursorByClick(e2)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())));
  }
  _mouseDownHandlerBefore(t3) {
    let { e: e2 } = t3;
    this.canvas && this.editable && !So(e2) && (this.selected = this === this.canvas._activeObject);
  }
  mouseUpHandler(t3) {
    let { e: e2, transform: s2 } = t3;
    const i2 = this.draggableTextDelegate.end(e2);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const t4 = this.canvas._activeObject;
      if (t4 && t4 !== this)
        return;
    }
    !this.editable || this.group && !this.group.interactive || s2 && s2.actionPerformed || So(e2) || i2 || (this.__lastSelected && !this.getActiveControl() ? (this.selected = false, this.__lastSelected = false, this.enterEditing(e2), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(true) : this.renderCursorOrSelection()) : this.selected = true);
  }
  setCursorByClick(t3) {
    const e2 = this.getSelectionStartFromPointer(t3), s2 = this.selectionStart, i2 = this.selectionEnd;
    t3.shiftKey ? this.setSelectionStartEndWithShift(s2, i2, e2) : (this.selectionStart = e2, this.selectionEnd = e2), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(t3) {
    const e2 = this.canvas.getScenePoint(t3).transform(ht(this.calcTransformMatrix())).add(new U(-this._getLeftOffset(), -this._getTopOffset()));
    let s2 = 0, i2 = 0, r2 = 0;
    for (let t4 = 0; t4 < this._textLines.length && s2 <= e2.y; t4++)
      s2 += this.getHeightOfLine(t4), r2 = t4, t4 > 0 && (i2 += this._textLines[t4 - 1].length + this.missingNewlineOffset(t4 - 1));
    let n2 = Math.abs(this._getLineLeftOffset(r2));
    const o2 = this._textLines[r2].length, a2 = this.__charBounds[r2];
    for (let t4 = 0; t4 < o2; t4++) {
      const s3 = n2 + a2[t4].kernedWidth;
      if (e2.x <= s3) {
        Math.abs(e2.x - s3) <= Math.abs(e2.x - n2) && i2++;
        break;
      }
      n2 = s3, i2++;
    }
    return Math.min(this.flipX ? o2 - i2 : i2, this._text.length);
  }
};
var Oo = "moveCursorUp";
var ko = "moveCursorDown";
var Do = "moveCursorLeft";
var Mo = "moveCursorRight";
var Po = "exitEditing";
var Eo = e({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: false, editable: true, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: true, hiddenTextareaContainer: null, keysMap: { 9: Po, 27: Po, 33: Oo, 34: ko, 35: Mo, 36: Do, 37: Do, 38: Oo, 39: Mo, 40: ko }, keysMapRtl: { 9: Po, 27: Po, 33: Oo, 34: ko, 35: Do, 36: Mo, 37: Mo, 38: Oo, 39: Do, 40: ko }, ctrlKeysMapDown: { 65: "selectAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: false });
var Ao = class _Ao extends To {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _Ao.ownDefaults);
  }
  get type() {
    const t3 = super.type;
    return "itext" === t3 ? "i-text" : t3;
  }
  constructor(t3, s2) {
    super(t3, e(e({}, _Ao.ownDefaults), s2)), this.initBehavior();
  }
  _set(t3, e2) {
    return this.isEditing && this._savedProps && t3 in this._savedProps ? (this._savedProps[t3] = e2, this) : ("canvas" === t3 && (this.canvas instanceof mn && this.canvas.textEditingManager.remove(this), e2 instanceof mn && e2.textEditingManager.add(this)), super._set(t3, e2));
  }
  setSelectionStart(t3) {
    t3 = Math.max(t3, 0), this._updateAndFire("selectionStart", t3);
  }
  setSelectionEnd(t3) {
    t3 = Math.min(t3, this.text.length), this._updateAndFire("selectionEnd", t3);
  }
  _updateAndFire(t3, e2) {
    this[t3] !== e2 && (this._fireSelectionChanged(), this[t3] = e2), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart || 0, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selectionEnd, s2 = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(t3, e2, s2);
  }
  setSelectionStyles(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selectionStart || 0, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(t3, e2, s2);
  }
  get2DCursorLocation() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart, e2 = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(t3, e2);
  }
  render(t3) {
    super.render(t3), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(t3) {
    const e2 = this.isEditing;
    this.isEditing = false;
    const s2 = super.toCanvasElement(t3);
    return this.isEditing = e2, s2;
  }
  renderCursorOrSelection() {
    if (!this.isEditing)
      return;
    const t3 = this.clearContextTop(true);
    if (!t3)
      return;
    const e2 = this._getCursorBoundaries();
    this.selectionStart === this.selectionEnd ? this.renderCursor(t3, e2) : this.renderSelection(t3, e2), this.canvas.contextTopDirty = true, t3.restore();
  }
  _getCursorBoundaries() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectionStart, e2 = arguments.length > 1 ? arguments[1] : void 0;
    const s2 = this._getLeftOffset(), i2 = this._getTopOffset(), r2 = this._getCursorBoundariesOffsets(t3, e2);
    return { left: s2, top: i2, leftOffset: r2.left, topOffset: r2.top };
  }
  _getCursorBoundariesOffsets(t3, e2) {
    return e2 ? this.__getCursorBoundariesOffsets(t3) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(t3);
  }
  __getCursorBoundariesOffsets(t3) {
    let e2 = 0, s2 = 0;
    const { charIndex: i2, lineIndex: r2 } = this.get2DCursorLocation(t3);
    for (let t4 = 0; t4 < r2; t4++)
      e2 += this.getHeightOfLine(t4);
    const n2 = this._getLineLeftOffset(r2), o2 = this.__charBounds[r2][i2];
    o2 && (s2 = o2.left), 0 !== this.charSpacing && i2 === this._textLines[r2].length && (s2 -= this._getWidthOfCharSpacing());
    const a2 = { top: e2, left: n2 + (s2 > 0 ? s2 : 0) };
    return "rtl" === this.direction && (this.textAlign === j || this.textAlign === ho || this.textAlign === lo ? a2.left *= -1 : this.textAlign === P || this.textAlign === co ? a2.left = n2 - (s2 > 0 ? s2 : 0) : this.textAlign !== M && this.textAlign !== uo || (a2.left = n2 - (s2 > 0 ? s2 : 0))), a2;
  }
  renderCursorAt(t3) {
    const e2 = this._getCursorBoundaries(t3, true);
    this._renderCursor(this.canvas.contextTop, e2, t3);
  }
  renderCursor(t3, e2) {
    this._renderCursor(t3, e2, this.selectionStart);
  }
  _renderCursor(t3, e2, s2) {
    const i2 = this.get2DCursorLocation(s2), r2 = i2.lineIndex, n2 = i2.charIndex > 0 ? i2.charIndex - 1 : 0, o2 = this.getValueOfPropertyAt(r2, n2, "fontSize"), a2 = this.getObjectScaling().x * this.canvas.getZoom(), h2 = this.cursorWidth / a2, c2 = this.getValueOfPropertyAt(r2, n2, "deltaY"), l2 = e2.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(r2) / this.lineHeight - o2 * (1 - this._fontSizeFraction);
    this.inCompositionMode && this.renderSelection(t3, e2), t3.fillStyle = this.cursorColor || this.getValueOfPropertyAt(r2, n2, "fill"), t3.globalAlpha = this._currentCursorOpacity, t3.fillRect(e2.left + e2.leftOffset - h2 / 2, l2 + e2.top + c2, h2, o2);
  }
  renderSelection(t3, e2) {
    const s2 = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(t3, s2, e2);
  }
  renderDragSourceEffect() {
    const t3 = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, t3, this._getCursorBoundaries(t3.selectionStart, true));
  }
  renderDropTargetEffect(t3) {
    const e2 = this.getSelectionStartFromPointer(t3);
    this.renderCursorAt(e2);
  }
  _renderSelection(t3, e2, s2) {
    const i2 = e2.selectionStart, r2 = e2.selectionEnd, n2 = this.textAlign.includes(ho), o2 = this.get2DCursorLocation(i2), a2 = this.get2DCursorLocation(r2), h2 = o2.lineIndex, c2 = a2.lineIndex, l2 = o2.charIndex < 0 ? 0 : o2.charIndex, u2 = a2.charIndex < 0 ? 0 : a2.charIndex;
    for (let e3 = h2; e3 <= c2; e3++) {
      const i3 = this._getLineLeftOffset(e3) || 0;
      let r3 = this.getHeightOfLine(e3), o3 = 0, a3 = 0, d2 = 0;
      if (e3 === h2 && (a3 = this.__charBounds[h2][l2].left), e3 >= h2 && e3 < c2)
        d2 = n2 && !this.isEndOfWrapping(e3) ? this.width : this.getLineWidth(e3) || 5;
      else if (e3 === c2)
        if (0 === u2)
          d2 = this.__charBounds[c2][u2].left;
        else {
          const t4 = this._getWidthOfCharSpacing();
          d2 = this.__charBounds[c2][u2 - 1].left + this.__charBounds[c2][u2 - 1].width - t4;
        }
      o3 = r3, (this.lineHeight < 1 || e3 === c2 && this.lineHeight > 1) && (r3 /= this.lineHeight);
      let g2 = s2.left + i3 + a3, f2 = r3, p2 = 0;
      const m2 = d2 - a3;
      this.inCompositionMode ? (t3.fillStyle = this.compositionColor || "black", f2 = 1, p2 = r3) : t3.fillStyle = this.selectionColor, "rtl" === this.direction && (this.textAlign === j || this.textAlign === ho || this.textAlign === lo ? g2 = this.width - g2 - m2 : this.textAlign === P || this.textAlign === co ? g2 = s2.left + i3 - d2 : this.textAlign !== M && this.textAlign !== uo || (g2 = s2.left + i3 - d2)), t3.fillRect(g2, s2.top + s2.topOffset + p2, m2, f2), s2.topOffset += o3;
    }
  }
  getCurrentCharFontSize() {
    const t3 = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(t3.l, t3.c, "fontSize");
  }
  getCurrentCharColor() {
    const t3 = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(t3.l, t3.c, "fill");
  }
  _getCurrentCharIndex() {
    const t3 = this.get2DCursorLocation(this.selectionStart, true), e2 = t3.charIndex > 0 ? t3.charIndex - 1 : 0;
    return { l: t3.lineIndex, c: e2 };
  }
  dispose() {
    this._exitEditing(), this.draggableTextDelegate.dispose(), super.dispose();
  }
};
s(Ao, "ownDefaults", Eo), s(Ao, "type", "IText"), I.setClass(Ao), I.setClass(Ao, "i-text");
var jo = class _jo extends Ao {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _jo.ownDefaults);
  }
  constructor(t3, s2) {
    super(t3, e(e({}, _jo.ownDefaults), s2));
  }
  static createControls() {
    return { controls: ai() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(ho) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(t3) {
    let e2 = 0, s2 = 0, i2 = 0;
    const r2 = {};
    for (let n2 = 0; n2 < t3.graphemeLines.length; n2++)
      "\n" === t3.graphemeText[i2] && n2 > 0 ? (s2 = 0, i2++, e2++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t3.graphemeText[i2]) && n2 > 0 && (s2++, i2++), r2[n2] = { line: e2, offset: s2 }, i2 += t3.graphemeLines[n2].length, s2 += t3.graphemeLines[n2].length;
    return r2;
  }
  styleHas(t3, e2) {
    if (this._styleMap && !this.isWrapping) {
      const t4 = this._styleMap[e2];
      t4 && (e2 = t4.line);
    }
    return super.styleHas(t3, e2);
  }
  isEmptyStyles(t3) {
    if (!this.styles)
      return true;
    let e2, s2 = 0, i2 = t3 + 1, r2 = false;
    const n2 = this._styleMap[t3], o2 = this._styleMap[t3 + 1];
    n2 && (t3 = n2.line, s2 = n2.offset), o2 && (i2 = o2.line, r2 = i2 === t3, e2 = o2.offset);
    const a2 = void 0 === t3 ? this.styles : { line: this.styles[t3] };
    for (const t4 in a2)
      for (const i3 in a2[t4]) {
        const n3 = parseInt(i3, 10);
        if (n3 >= s2 && (!r2 || n3 < e2))
          for (const e3 in a2[t4][i3])
            return false;
      }
    return true;
  }
  _getStyleDeclaration(t3, e2) {
    if (this._styleMap && !this.isWrapping) {
      const s2 = this._styleMap[t3];
      if (!s2)
        return {};
      t3 = s2.line, e2 = s2.offset + e2;
    }
    return super._getStyleDeclaration(t3, e2);
  }
  _setStyleDeclaration(t3, e2, s2) {
    const i2 = this._styleMap[t3];
    super._setStyleDeclaration(i2.line, i2.offset + e2, s2);
  }
  _deleteStyleDeclaration(t3, e2) {
    const s2 = this._styleMap[t3];
    super._deleteStyleDeclaration(s2.line, s2.offset + e2);
  }
  _getLineStyle(t3) {
    const e2 = this._styleMap[t3];
    return !!this.styles[e2.line];
  }
  _setLineStyle(t3) {
    const e2 = this._styleMap[t3];
    super._setLineStyle(e2.line);
  }
  _wrapText(t3, e2) {
    this.isWrapping = true;
    const s2 = this.getGraphemeDataForRender(t3), i2 = [];
    for (let t4 = 0; t4 < s2.wordsData.length; t4++)
      i2.push(...this._wrapLine(t4, e2, s2));
    return this.isWrapping = false, i2;
  }
  getGraphemeDataForRender(t3) {
    const e2 = this.splitByGrapheme, s2 = e2 ? "" : " ";
    let i2 = 0;
    return { wordsData: t3.map((t4, r2) => {
      let n2 = 0;
      const o2 = e2 ? this.graphemeSplit(t4) : this.wordSplit(t4);
      return 0 === o2.length ? [{ word: [], width: 0 }] : o2.map((t5) => {
        const o3 = e2 ? [t5] : this.graphemeSplit(t5), a2 = this._measureWord(o3, r2, n2);
        return i2 = Math.max(a2, i2), n2 += o3.length + s2.length, { word: o3, width: a2 };
      });
    }), largestWordWidth: i2 };
  }
  _measureWord(t3, e2) {
    let s2, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r2 = 0;
    for (let n2 = 0, o2 = t3.length; n2 < o2; n2++) {
      r2 += this._getGraphemeBox(t3[n2], e2, n2 + i2, s2, true).kernedWidth, s2 = t3[n2];
    }
    return r2;
  }
  wordSplit(t3) {
    return t3.split(this._wordJoiners);
  }
  _wrapLine(t3, e2, s2) {
    let { largestWordWidth: i2, wordsData: r2 } = s2, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    const o2 = this._getWidthOfCharSpacing(), a2 = this.splitByGrapheme, h2 = [], c2 = a2 ? "" : " ";
    let l2 = 0, u2 = [], d2 = 0, g2 = 0, f2 = true;
    e2 -= n2;
    const p2 = Math.max(e2, i2, this.dynamicMinWidth), m2 = r2[t3];
    let v2;
    for (d2 = 0, v2 = 0; v2 < m2.length; v2++) {
      const { word: e3, width: s3 } = m2[v2];
      d2 += e3.length, l2 += g2 + s3 - o2, l2 > p2 && !f2 ? (h2.push(u2), u2 = [], l2 = s3, f2 = true) : l2 += o2, f2 || a2 || u2.push(c2), u2 = u2.concat(e3), g2 = a2 ? 0 : this._measureWord([c2], t3, d2), d2++, f2 = false;
    }
    return v2 && h2.push(u2), i2 + n2 > this.dynamicMinWidth && (this.dynamicMinWidth = i2 - o2 + n2), h2;
  }
  isEndOfWrapping(t3) {
    return !this._styleMap[t3 + 1] || this._styleMap[t3 + 1].line !== this._styleMap[t3].line;
  }
  missingNewlineOffset(t3, e2) {
    return this.splitByGrapheme && !e2 ? this.isEndOfWrapping(t3) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(t3) {
    const e2 = super._splitTextIntoLines(t3), s2 = this._wrapText(e2.lines, this.width), i2 = new Array(s2.length);
    for (let t4 = 0; t4 < s2.length; t4++)
      i2[t4] = s2[t4].join("");
    return e2.lines = i2, e2.graphemeLines = s2, e2;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const t3 = /* @__PURE__ */ new Map();
    for (const e2 in this._styleMap) {
      const s2 = parseInt(e2, 10);
      if (this._textLines[s2]) {
        const s3 = this._styleMap[e2].line;
        t3.set("".concat(s3), true);
      }
    }
    for (const e2 in this.styles)
      t3.has(e2) || delete this.styles[e2];
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...t3]);
  }
};
s(jo, "type", "Textbox"), s(jo, "textLayoutProperties", [...Ao.textLayoutProperties, "width"]), s(jo, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: true, noScaleCache: false, _wordJoiners: /[ \t\r]/, splitByGrapheme: false }), I.setClass(jo);
var Fo = class extends lr {
  shouldPerformLayout(t3) {
    return !!t3.target.clipPath && super.shouldPerformLayout(t3);
  }
  shouldLayoutClipPath() {
    return false;
  }
  calcLayoutResult(t3, e2) {
    const { target: s2 } = t3, { clipPath: i2 } = s2;
    if (!i2 || !this.shouldPerformLayout(t3))
      return;
    const { width: r2, height: n2 } = ie(cr(s2, i2)), o2 = new U(r2, n2);
    if (i2.absolutePositioned) {
      var a2;
      return { center: ue(i2.getRelativeCenterPoint(), void 0, null === (a2 = s2.group) || void 0 === a2 ? void 0 : a2.calcTransformMatrix()), size: o2 };
    }
    {
      const r3 = i2.getRelativeCenterPoint().transform(s2.calcOwnMatrix(), true);
      if (this.shouldPerformLayout(t3)) {
        const { center: s3 = new U(), correction: i3 = new U() } = this.calcBoundingBox(e2, t3) || {};
        return { center: s3.add(r3), correction: i3.subtract(r3), size: o2 };
      }
      return { center: s2.getRelativeCenterPoint().add(r3), size: o2 };
    }
  }
};
s(Fo, "type", "clip-path"), I.setClass(Fo);
var Lo = class extends lr {
  getInitialSize(t3, e2) {
    let { target: s2 } = t3, { size: i2 } = e2;
    return new U(s2.width || i2.x, s2.height || i2.y);
  }
};
s(Lo, "type", "fixed"), I.setClass(Lo);
var Ro = class extends pr {
  subscribeTargets(t3) {
    const e2 = t3.target;
    t3.targets.reduce((t4, e3) => (e3.parent && t4.add(e3.parent), t4), /* @__PURE__ */ new Set()).forEach((t4) => {
      t4.layoutManager.subscribeTargets({ target: t4, targets: [e2] });
    });
  }
  unsubscribeTargets(t3) {
    const e2 = t3.target, s2 = e2.getObjects();
    t3.targets.reduce((t4, e3) => (e3.parent && t4.add(e3.parent), t4), /* @__PURE__ */ new Set()).forEach((t4) => {
      !s2.some((e3) => e3.parent === t4) && t4.layoutManager.unsubscribeTargets({ target: t4, targets: [e2] });
    });
  }
};
var Bo = ["layoutManager"];
var Io = class _Io extends yr {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _Io.ownDefaults);
  }
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { layoutManager: s2 } = e2, r2 = i(e2, Bo);
    super(t3, { layoutManager: null != s2 ? s2 : new Ro() }), Object.assign(this, _Io.ownDefaults), this.setOptions(r2);
  }
  _shouldSetNestedCoords() {
    return true;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var t3 = arguments.length, e2 = new Array(t3), s2 = 0; s2 < t3; s2++)
      e2[s2] = arguments[s2];
    "selection-order" === this.multiSelectionStacking ? this.add(...e2) : e2.forEach((t4) => {
      const e3 = this._objects.findIndex((e4) => e4.isInFrontOf(t4)), s3 = -1 === e3 ? this.size() : e3;
      this.insertAt(s3, t4);
    });
  }
  canEnterGroup(t3) {
    return this.getObjects().some((e2) => e2.isDescendantOf(t3) || t3.isDescendantOf(e2)) ? (h("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), false) : super.canEnterGroup(t3);
  }
  enterGroup(t3, e2) {
    t3.parent && t3.parent === t3.group ? t3.parent._exitGroup(t3) : t3.group && t3.parent !== t3.group && t3.group.remove(t3), this._enterGroup(t3, e2);
  }
  exitGroup(t3, e2) {
    this._exitGroup(t3, e2), t3.parent && t3.parent._enterGroup(t3, true);
  }
  _onAfterObjectsChange(t3, e2) {
    super._onAfterObjectsChange(t3, e2);
    const s2 = /* @__PURE__ */ new Set();
    e2.forEach((t4) => {
      const { parent: e3 } = t4;
      e3 && s2.add(e3);
    }), t3 === ar ? s2.forEach((t4) => {
      t4._onAfterObjectsChange(or, e2);
    }) : s2.forEach((t4) => {
      t4._set("dirty", true);
    });
  }
  onDeselect() {
    return this.removeAll(), false;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return false;
  }
  isOnACache() {
    return false;
  }
  _renderControls(t3, s2, i2) {
    t3.save(), t3.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, super._renderControls(t3, s2);
    const r2 = e(e({ hasControls: false }, i2), {}, { forActiveSelection: true });
    for (let e2 = 0; e2 < this._objects.length; e2++)
      this._objects[e2]._renderControls(t3, r2);
    t3.restore();
  }
};
s(Io, "type", "ActiveSelection"), s(Io, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), I.setClass(Io), I.setClass(Io, "activeSelection");
var Xo = class {
  constructor() {
    s(this, "resources", {});
  }
  applyFilters(t3, e2, s2, i2, r2) {
    const n2 = r2.getContext("2d");
    if (!n2)
      return;
    n2.drawImage(e2, 0, 0, s2, i2);
    const o2 = { sourceWidth: s2, sourceHeight: i2, imageData: n2.getImageData(0, 0, s2, i2), originalEl: e2, originalImageData: n2.getImageData(0, 0, s2, i2), canvasEl: r2, ctx: n2, filterBackend: this };
    t3.forEach((t4) => {
      t4.applyTo(o2);
    });
    const { imageData: a2 } = o2;
    return a2.width === s2 && a2.height === i2 || (r2.width = a2.width, r2.height = a2.height), n2.putImageData(a2, 0, 0), o2;
  }
};
var Yo = class {
  constructor() {
    let { tileSize: t3 = a.textureSize } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    s(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), s(this, "resources", {}), this.tileSize = t3, this.setupGLContext(t3, t3), this.captureGPUInfo();
  }
  setupGLContext(t3, e2) {
    this.dispose(), this.createWebGLCanvas(t3, e2);
  }
  createWebGLCanvas(t3, e2) {
    const s2 = et();
    s2.width = t3, s2.height = e2;
    const i2 = s2.getContext("webgl", { alpha: true, premultipliedAlpha: false, depth: false, stencil: false, antialias: false });
    i2 && (i2.clearColor(0, 0, 0, 0), this.canvas = s2, this.gl = i2);
  }
  applyFilters(t3, e2, s2, i2, r2, n2) {
    const o2 = this.gl, a2 = r2.getContext("2d");
    if (!o2 || !a2)
      return;
    let h2;
    n2 && (h2 = this.getCachedTexture(n2, e2));
    const c2 = { originalWidth: e2.width || e2.originalWidth || 0, originalHeight: e2.height || e2.originalHeight || 0, sourceWidth: s2, sourceHeight: i2, destinationWidth: s2, destinationHeight: i2, context: o2, sourceTexture: this.createTexture(o2, s2, i2, h2 ? void 0 : e2), targetTexture: this.createTexture(o2, s2, i2), originalTexture: h2 || this.createTexture(o2, s2, i2, h2 ? void 0 : e2), passes: t3.length, webgl: true, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: r2 }, l2 = o2.createFramebuffer();
    return o2.bindFramebuffer(o2.FRAMEBUFFER, l2), t3.forEach((t4) => {
      t4 && t4.applyTo(c2);
    }), function(t4) {
      const e3 = t4.targetCanvas, s3 = e3.width, i3 = e3.height, r3 = t4.destinationWidth, n3 = t4.destinationHeight;
      s3 === r3 && i3 === n3 || (e3.width = r3, e3.height = n3);
    }(c2), this.copyGLTo2D(o2, c2), o2.bindTexture(o2.TEXTURE_2D, null), o2.deleteTexture(c2.sourceTexture), o2.deleteTexture(c2.targetTexture), o2.deleteFramebuffer(l2), a2.setTransform(1, 0, 0, 1, 0, 0), c2;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(t3, e2, s2, i2, r2) {
    const { NEAREST: n2, TEXTURE_2D: o2, RGBA: a2, UNSIGNED_BYTE: h2, CLAMP_TO_EDGE: c2, TEXTURE_MAG_FILTER: l2, TEXTURE_MIN_FILTER: u2, TEXTURE_WRAP_S: d2, TEXTURE_WRAP_T: g2 } = t3, f2 = t3.createTexture();
    return t3.bindTexture(o2, f2), t3.texParameteri(o2, l2, r2 || n2), t3.texParameteri(o2, u2, r2 || n2), t3.texParameteri(o2, d2, c2), t3.texParameteri(o2, g2, c2), i2 ? t3.texImage2D(o2, 0, a2, a2, h2, i2) : t3.texImage2D(o2, 0, a2, e2, s2, 0, a2, h2, null), f2;
  }
  getCachedTexture(t3, e2, s2) {
    const { textureCache: i2 } = this;
    if (i2[t3])
      return i2[t3];
    {
      const r2 = this.createTexture(this.gl, e2.width, e2.height, e2, s2);
      return r2 && (i2[t3] = r2), r2;
    }
  }
  evictCachesForKey(t3) {
    this.textureCache[t3] && (this.gl.deleteTexture(this.textureCache[t3]), delete this.textureCache[t3]);
  }
  copyGLTo2D(t3, e2) {
    const s2 = t3.canvas, i2 = e2.targetCanvas, r2 = i2.getContext("2d");
    if (!r2)
      return;
    r2.translate(0, i2.height), r2.scale(1, -1);
    const n2 = s2.height - i2.height;
    r2.drawImage(s2, 0, n2, i2.width, i2.height, 0, 0, i2.width, i2.height);
  }
  copyGLTo2DPutImageData(t3, e2) {
    const s2 = e2.targetCanvas.getContext("2d"), i2 = e2.destinationWidth, r2 = e2.destinationHeight, n2 = i2 * r2 * 4;
    if (!s2)
      return;
    const o2 = new Uint8Array(this.imageBuffer, 0, n2), a2 = new Uint8ClampedArray(this.imageBuffer, 0, n2);
    t3.readPixels(0, 0, i2, r2, t3.RGBA, t3.UNSIGNED_BYTE, o2);
    const h2 = new ImageData(a2, i2, r2);
    s2.putImageData(h2, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo)
      return this.gpuInfo;
    const t3 = this.gl, e2 = { renderer: "", vendor: "" };
    if (!t3)
      return e2;
    const s2 = t3.getExtension("WEBGL_debug_renderer_info");
    if (s2) {
      const i2 = t3.getParameter(s2.UNMASKED_RENDERER_WEBGL), r2 = t3.getParameter(s2.UNMASKED_VENDOR_WEBGL);
      i2 && (e2.renderer = i2.toLowerCase()), r2 && (e2.vendor = r2.toLowerCase());
    }
    return this.gpuInfo = e2, e2;
  }
};
var Wo;
function Vo() {
  const { WebGLProbe: t3 } = m();
  return t3.queryWebGL(et()), a.enableGLFiltering && t3.isSupported(a.textureSize) ? new Yo({ tileSize: a.textureSize }) : new Xo();
}
function zo() {
  return !Wo && (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) && (Wo = Vo()), Wo;
}
function Ho(t3) {
  Wo = t3;
}
var Go = ["filters", "resizeFilter", "src", "crossOrigin", "type"];
var Uo = ["cropX", "cropY"];
var No = class _No extends li {
  static getDefaults() {
    return e(e({}, super.getDefaults()), _No.ownDefaults);
  }
  constructor(t3, e2) {
    super(), s(this, "_lastScaleX", 1), s(this, "_lastScaleY", 1), s(this, "_filterScalingX", 1), s(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, _No.ownDefaults), this.setOptions(e2), this.cacheKey = "texture".concat(tt()), this.setElement("string" == typeof t3 ? (this.canvas && Ht(this.canvas.getElement()) || v()).getElementById(t3) : t3, e2);
  }
  getElement() {
    return this._element;
  }
  setElement(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = t3, this._originalElement = t3, this._setWidthHeight(e2), t3.classList.add(_No.CSS_CANVAS), 0 !== this.filters.length && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(t3) {
    const e2 = zo(false);
    e2 instanceof Yo && e2.evictCachesForKey(t3);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((t3) => {
      const e2 = this[t3];
      e2 && m().dispose(e2), this[t3] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const t3 = this.getElement();
    return t3 ? { width: t3.naturalWidth || t3.width, height: t3.naturalHeight || t3.height } : { width: 0, height: 0 };
  }
  _stroke(t3) {
    if (!this.stroke || 0 === this.strokeWidth)
      return;
    const e2 = this.width / 2, s2 = this.height / 2;
    t3.beginPath(), t3.moveTo(-e2, -s2), t3.lineTo(e2, -s2), t3.lineTo(e2, s2), t3.lineTo(-e2, s2), t3.lineTo(-e2, -s2), t3.closePath();
  }
  toObject() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const s2 = [];
    return this.filters.forEach((t4) => {
      t4 && s2.push(t4.toObject());
    }), e(e({}, super.toObject([...Uo, ...t3])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: s2 }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const t3 = [], e2 = this._element, s2 = -this.width / 2, i2 = -this.height / 2;
    let r2 = [], n2 = [], o2 = "", a2 = "";
    if (!e2)
      return [];
    if (this.hasCrop()) {
      const t4 = tt();
      r2.push('<clipPath id="imageCrop_' + t4 + '">\n', '	<rect x="' + s2 + '" y="' + i2 + '" width="' + this.width + '" height="' + this.height + '" />\n', "</clipPath>\n"), o2 = ' clip-path="url(#imageCrop_' + t4 + ')" ';
    }
    if (this.imageSmoothing || (a2 = ' image-rendering="optimizeSpeed"'), t3.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(true), '" x="').concat(s2 - this.cropX, '" y="').concat(i2 - this.cropY, '" width="').concat(e2.width || e2.naturalWidth, '" height="').concat(e2.height || e2.naturalHeight, '"').concat(a2).concat(o2, "></image>\n")), this.stroke || this.strokeDashArray) {
      const t4 = this.fill;
      this.fill = null, n2 = ['	<rect x="'.concat(s2, '" y="').concat(i2, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), '" />\n')], this.fill = t4;
    }
    return r2 = "fill" !== this.paintFirst ? r2.concat(n2, t3) : r2.concat(t3, n2), r2;
  }
  getSrc(t3) {
    const e2 = t3 ? this._element : this._originalElement;
    return e2 ? e2.toDataURL ? e2.toDataURL() : this.srcFromAttribute ? e2.getAttribute("src") || "" : e2.src : this.src || "";
  }
  getSvgSrc(t3) {
    return this.getSrc(t3);
  }
  setSrc(t3) {
    let { crossOrigin: e2, signal: s2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Ct(t3, { crossOrigin: e2, signal: s2 }).then((t4) => {
      void 0 !== e2 && this.set({ crossOrigin: e2 }), this.setElement(t4);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const t3 = this.resizeFilter, e2 = this.minimumScaleTrigger, s2 = this.getTotalObjectScaling(), i2 = s2.x, r2 = s2.y, n2 = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", true), !t3 || i2 > e2 && r2 > e2)
      return this._element = n2, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = i2, void (this._lastScaleY = r2);
    const o2 = et(), a2 = n2.width, h2 = n2.height;
    o2.width = a2, o2.height = h2, this._element = o2, this._lastScaleX = t3.scaleX = i2, this._lastScaleY = t3.scaleY = r2, zo().applyFilters([t3], n2, a2, h2, this._element), this._filterScalingX = o2.width / this._originalElement.width, this._filterScalingY = o2.height / this._originalElement.height;
  }
  applyFilters() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.filters || [];
    if (t3 = t3.filter((t4) => t4 && !t4.isNeutralState()), this.set("dirty", true), this.removeTexture("".concat(this.cacheKey, "_filtered")), 0 === t3.length)
      return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const e2 = this._originalElement, s2 = e2.naturalWidth || e2.width, i2 = e2.naturalHeight || e2.height;
    if (this._element === this._originalElement) {
      const t4 = et();
      t4.width = s2, t4.height = i2, this._element = t4, this._filteredEl = t4;
    } else
      this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, s2, i2), this._lastScaleX = 1, this._lastScaleY = 1);
    zo().applyFilters(t3, this._originalElement, s2, i2, this._element), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(t3) {
    t3.imageSmoothingEnabled = this.imageSmoothing, true !== this.isMoving && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t3), this._renderPaintInOrder(t3);
  }
  drawCacheOnCanvas(t3) {
    t3.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(t3);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(t3) {
    const e2 = this._element;
    if (!e2)
      return;
    const s2 = this._filterScalingX, i2 = this._filterScalingY, r2 = this.width, n2 = this.height, o2 = Math.max(this.cropX, 0), a2 = Math.max(this.cropY, 0), h2 = e2.naturalWidth || e2.width, c2 = e2.naturalHeight || e2.height, l2 = o2 * s2, u2 = a2 * i2, d2 = Math.min(r2 * s2, h2 - l2), g2 = Math.min(n2 * i2, c2 - u2), f2 = -r2 / 2, p2 = -n2 / 2, m2 = Math.min(r2, h2 / s2 - o2), v2 = Math.min(n2, c2 / i2 - a2);
    e2 && t3.drawImage(e2, l2, u2, d2, g2, f2, p2, m2, v2);
  }
  _needsResize() {
    const t3 = this.getTotalObjectScaling();
    return t3.x !== this._lastScaleX || t3.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: t3, height: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const s2 = this.getOriginalSize();
    this.width = t3 || s2.width, this.height = e2 || s2.height;
  }
  parsePreserveAspectRatioAttribute() {
    const t3 = Lt(this.preserveAspectRatio || ""), e2 = this.width, s2 = this.height, i2 = { width: e2, height: s2 };
    let r2, n2 = this._element.width, o2 = this._element.height, a2 = 1, h2 = 1, c2 = 0, l2 = 0, u2 = 0, d2 = 0;
    return !t3 || t3.alignX === F && t3.alignY === F ? (a2 = e2 / n2, h2 = s2 / o2) : ("meet" === t3.meetOrSlice && (a2 = h2 = _r(this._element, i2), r2 = (e2 - n2 * a2) / 2, "Min" === t3.alignX && (c2 = -r2), "Max" === t3.alignX && (c2 = r2), r2 = (s2 - o2 * h2) / 2, "Min" === t3.alignY && (l2 = -r2), "Max" === t3.alignY && (l2 = r2)), "slice" === t3.meetOrSlice && (a2 = h2 = xr(this._element, i2), r2 = n2 - e2 / a2, "Mid" === t3.alignX && (u2 = r2 / 2), "Max" === t3.alignX && (u2 = r2), r2 = o2 - s2 / h2, "Mid" === t3.alignY && (d2 = r2 / 2), "Max" === t3.alignY && (d2 = r2), n2 = e2 / a2, o2 = s2 / h2)), { width: n2, height: o2, scaleX: a2, scaleY: h2, offsetLeft: c2, offsetTop: l2, cropX: u2, cropY: d2 };
  }
  static fromObject(t3, s2) {
    let { filters: r2, resizeFilter: n2, src: o2, crossOrigin: a2, type: h2 } = t3, c2 = i(t3, Go);
    return Promise.all([Ct(o2, e(e({}, s2), {}, { crossOrigin: a2 })), r2 && bt(r2, s2), n2 && bt([n2], s2), wt(c2, s2)]).then((t4) => {
      let [s3, i2 = [], [r3] = [], n3 = {}] = t4;
      return new this(s3, e(e({}, c2), {}, { src: o2, filters: i2, resizeFilter: r3 }, n3));
    });
  }
  static fromURL(t3) {
    let { crossOrigin: e2 = null, signal: s2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = arguments.length > 2 ? arguments[2] : void 0;
    return Ct(t3, { crossOrigin: e2, signal: s2 }).then((t4) => new this(t4, i2));
  }
  static async fromElement(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s2 = arguments.length > 2 ? arguments[2] : void 0;
    const i2 = er(t3, this.ATTRIBUTE_NAMES, s2);
    return this.fromURL(i2["xlink:href"], e2, i2).catch((t4) => (h("log", "Unable to parse Image", t4), null));
  }
};
function qo(t3) {
  if (!ys.test(t3.nodeName))
    return {};
  const e2 = t3.getAttribute("viewBox");
  let s2, i2, r2 = 1, n2 = 1, o2 = 0, a2 = 0;
  const h2 = t3.getAttribute("width"), c2 = t3.getAttribute("height"), l2 = t3.getAttribute("x") || 0, u2 = t3.getAttribute("y") || 0, d2 = !(e2 && xs.test(e2)), g2 = !h2 || !c2 || "100%" === h2 || "100%" === c2;
  let f2 = "", p2 = 0, m2 = 0;
  if (d2 && (l2 || u2) && t3.parentNode && "#document" !== t3.parentNode.nodeName && (f2 = " translate(" + Ft(l2 || "0") + " " + Ft(u2 || "0") + ") ", s2 = (t3.getAttribute("transform") || "") + f2, t3.setAttribute("transform", s2), t3.removeAttribute("x"), t3.removeAttribute("y")), d2 && g2)
    return { width: 0, height: 0 };
  const v2 = { width: 0, height: 0 };
  if (d2)
    return v2.width = Ft(h2), v2.height = Ft(c2), v2;
  const y2 = e2.match(xs);
  o2 = -parseFloat(y2[1]), a2 = -parseFloat(y2[2]);
  const _2 = parseFloat(y2[3]), x2 = parseFloat(y2[4]);
  v2.minX = o2, v2.minY = a2, v2.viewBoxWidth = _2, v2.viewBoxHeight = x2, g2 ? (v2.width = _2, v2.height = x2) : (v2.width = Ft(h2), v2.height = Ft(c2), r2 = v2.width / _2, n2 = v2.height / x2);
  const C2 = Lt(t3.getAttribute("preserveAspectRatio") || "");
  if (C2.alignX !== F && ("meet" === C2.meetOrSlice && (n2 = r2 = r2 > n2 ? n2 : r2), "slice" === C2.meetOrSlice && (n2 = r2 = r2 > n2 ? r2 : n2), p2 = v2.width - _2 * r2, m2 = v2.height - x2 * r2, "Mid" === C2.alignX && (p2 /= 2), "Mid" === C2.alignY && (m2 /= 2), "Min" === C2.alignX && (p2 = 0), "Min" === C2.alignY && (m2 = 0)), 1 === r2 && 1 === n2 && 0 === o2 && 0 === a2 && 0 === l2 && 0 === u2)
    return v2;
  if ((l2 || u2) && "#document" !== t3.parentNode.nodeName && (f2 = " translate(" + Ft(l2 || "0") + " " + Ft(u2 || "0") + ") "), s2 = f2 + " matrix(" + r2 + " 0 0 " + n2 + " " + (o2 * r2 + p2) + " " + (a2 * n2 + m2) + ") ", "svg" === t3.nodeName) {
    for (i2 = t3.ownerDocument.createElementNS(ds, "g"); t3.firstChild; )
      i2.appendChild(t3.firstChild);
    t3.appendChild(i2);
  } else
    i2 = t3, i2.removeAttribute("x"), i2.removeAttribute("y"), s2 = i2.getAttribute("transform") + s2;
  return i2.setAttribute("transform", s2), v2;
}
s(No, "type", "Image"), s(No, "cacheProperties", [...Os, ...Uo]), s(No, "ownDefaults", { strokeWidth: 0, srcFromAttribute: false, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: true }), s(No, "CSS_CANVAS", "canvas-img"), s(No, "ATTRIBUTE_NAMES", [...Si, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "crossOrigin", "image-rendering"]), I.setClass(No), I.setSVGClass(No);
var Ko = (t3) => t3.tagName.replace("svg:", "");
var Jo = hs(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
function Zo(t3, e2) {
  let s2, i2, r2, n2, o2 = [];
  for (r2 = 0, n2 = e2.length; r2 < n2; r2++)
    s2 = e2[r2], i2 = t3.getElementsByTagNameNS("http://www.w3.org/2000/svg", s2), o2 = o2.concat(Array.from(i2));
  return o2;
}
var Qo = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"];
var $o = "xlink:href";
function ta(t3, e2) {
  var s2;
  const i2 = (null === (s2 = e2.getAttribute($o)) || void 0 === s2 ? void 0 : s2.slice(1)) || "", r2 = t3.getElementById(i2);
  if (r2 && r2.getAttribute($o) && ta(t3, r2), r2 && (Qo.forEach((t4) => {
    const s3 = r2.getAttribute(t4);
    !e2.hasAttribute(t4) && s3 && e2.setAttribute(t4, s3);
  }), !e2.children.length)) {
    const t4 = r2.cloneNode(true);
    for (; t4.firstChild; )
      e2.appendChild(t4.firstChild);
  }
  e2.removeAttribute($o);
}
var ea = ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"];
function sa(t3) {
  const s2 = t3.getElementsByTagName("style");
  let i2, r2;
  const n2 = {};
  for (i2 = 0, r2 = s2.length; i2 < r2; i2++) {
    const t4 = (s2[i2].textContent || "").replace(/\/\*[\s\S]*?\*\//g, "");
    "" !== t4.trim() && t4.split("}").filter((t5, e2, s3) => s3.length > 1 && t5.trim()).forEach((t5) => {
      if ((t5.match(/{/g) || []).length > 1 && t5.trim().startsWith("@"))
        return;
      const s3 = t5.split("{"), o2 = {}, a2 = s3[1].trim().split(";").filter(function(t6) {
        return t6.trim();
      });
      for (i2 = 0, r2 = a2.length; i2 < r2; i2++) {
        const t6 = a2[i2].split(":"), e2 = t6[0].trim(), s4 = t6[1].trim();
        o2[e2] = s4;
      }
      (t5 = s3[0].trim()).split(",").forEach((t6) => {
        "" !== (t6 = t6.replace(/^svg/i, "").trim()) && (n2[t6] = e(e({}, n2[t6] || {}), o2));
      });
    });
  }
  return n2;
}
var ia = (t3) => I.getSVGClass(Ko(t3).toLowerCase());
var ra = class {
  constructor(t3, e2, s2, i2, r2) {
    this.elements = t3, this.options = e2, this.reviver = s2, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = i2, this.clipPaths = r2, this.gradientDefs = function(t4) {
      const e3 = Zo(t4, ea), s3 = {};
      let i3 = e3.length;
      for (; i3--; ) {
        const r3 = e3[i3];
        r3.getAttribute("xlink:href") && ta(t4, r3);
        const n2 = r3.getAttribute("id");
        n2 && (s3[n2] = r3);
      }
      return s3;
    }(i2), this.cssRules = sa(i2);
  }
  parse() {
    return Promise.all(this.elements.map((t3) => this.createObject(t3)));
  }
  async createObject(t3) {
    const e2 = ia(t3);
    if (e2) {
      const s2 = await e2.fromElement(t3, this.options, this.cssRules);
      return this.resolveGradient(s2, t3, "fill"), this.resolveGradient(s2, t3, "stroke"), s2 instanceof No && s2._originalElement ? nn(s2, s2.parsePreserveAspectRatioAttribute()) : nn(s2), await this.resolveClipPath(s2, t3), this.reviver && this.reviver(t3, s2), s2;
    }
    return null;
  }
  extractPropertyDefinition(t3, e2, s2) {
    const i2 = t3[e2], r2 = this.regexUrl;
    if (!r2.test(i2))
      return;
    r2.lastIndex = 0;
    const n2 = r2.exec(i2)[1];
    return r2.lastIndex = 0, s2[n2];
  }
  resolveGradient(t3, s2, i2) {
    const r2 = this.extractPropertyDefinition(t3, i2, this.gradientDefs);
    if (r2) {
      const n2 = s2.getAttribute(i2 + "-opacity"), o2 = Pn.fromElement(r2, t3, e(e({}, this.options), {}, { opacity: n2 }));
      t3.set(i2, o2);
    }
  }
  async resolveClipPath(t3, e2) {
    const s2 = this.extractPropertyDefinition(t3, "clipPath", this.clipPaths);
    if (s2) {
      const i2 = ht(t3.calcTransformMatrix()), r2 = s2[0].parentElement;
      let n2 = e2;
      for (; n2.parentElement && n2.getAttribute("clip-path") !== t3.clipPath; )
        n2 = n2.parentElement;
      n2.parentElement.appendChild(r2);
      const o2 = Ji("".concat(n2.getAttribute("transform") || "", " ").concat(r2.getAttribute("originalTransform") || ""));
      r2.setAttribute("transform", "matrix(".concat(o2.join(","), ")"));
      const a2 = await Promise.all(s2.map((t4) => ia(t4).fromElement(t4, this.options, this.cssRules).then((t5) => (nn(t5), t5.fillRule = t5.clipRule, delete t5.clipRule, t5)))), h2 = 1 === a2.length ? a2[0] : new yr(a2), c2 = ct(i2, h2.calcTransformMatrix());
      h2.clipPath && await this.resolveClipPath(h2, n2);
      const { scaleX: l2, scaleY: u2, angle: d2, skewX: g2, translateX: f2, translateY: p2 } = dt(c2);
      h2.set({ flipX: false, flipY: false }), h2.set({ scaleX: l2, scaleY: u2, angle: d2, skewX: g2, skewY: 0 }), h2.setPositionByOrigin(new U(f2, p2), M, M), t3.clipPath = h2;
    } else
      delete t3.clipPath;
  }
};
var na = (t3) => vs.test(Ko(t3));
var oa = () => ({ objects: [], elements: [], options: {}, allElements: [] });
async function aa(t3, s2) {
  let { crossOrigin: i2, signal: r2 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  if (r2 && r2.aborted)
    return h("log", new l("parseSVGDocument")), oa();
  const n2 = t3.documentElement;
  !function(t4) {
    const e2 = Zo(t4, ["use", "svg:use"]);
    let s3 = 0;
    for (; e2.length && s3 < e2.length; ) {
      const i3 = e2[s3], r3 = i3.getAttribute("xlink:href") || i3.getAttribute("href");
      if (null === r3)
        return;
      const n3 = r3.slice(1), o3 = i3.getAttribute("x") || 0, a3 = i3.getAttribute("y") || 0, h2 = t4.getElementById(n3);
      if (null === h2)
        return;
      let c3 = h2.cloneNode(true), l2 = (c3.getAttribute("transform") || "") + " translate(" + o3 + ", " + a3 + ")";
      const u3 = e2.length, d3 = ds;
      if (qo(c3), /^svg$/i.test(c3.nodeName)) {
        const t5 = c3.ownerDocument.createElementNS(d3, "g");
        for (let e3 = 0, s4 = c3.attributes, i4 = s4.length; e3 < i4; e3++) {
          const i5 = s4.item(e3);
          i5 && t5.setAttributeNS(d3, i5.nodeName, i5.nodeValue);
        }
        for (; c3.firstChild; )
          t5.appendChild(c3.firstChild);
        c3 = t5;
      }
      for (let t5 = 0, e3 = i3.attributes, s4 = e3.length; t5 < s4; t5++) {
        const s5 = e3.item(t5);
        if (!s5)
          continue;
        const { nodeName: i4, nodeValue: r4 } = s5;
        "x" !== i4 && "y" !== i4 && "xlink:href" !== i4 && "href" !== i4 && ("transform" === i4 ? l2 = r4 + " " + l2 : c3.setAttribute(i4, r4));
      }
      c3.setAttribute("transform", l2), c3.setAttribute("instantiated_by_use", "1"), c3.removeAttribute("id"), i3.parentNode.replaceChild(c3, i3), e2.length === u3 && s3++;
    }
  }(t3);
  const o2 = Array.from(n2.getElementsByTagName("*")), a2 = e(e({}, qo(n2)), {}, { crossOrigin: i2, signal: r2 }), c2 = o2.filter((t4) => (qo(t4), na(t4) && !function(t5) {
    let e2 = t5;
    for (; e2 && (e2 = e2.parentElement); )
      if (e2 && e2.nodeName && Jo.test(Ko(e2)) && !e2.getAttribute("instantiated_by_use"))
        return true;
    return false;
  }(t4)));
  if (!c2 || c2 && !c2.length)
    return e(e({}, oa()), {}, { options: a2, allElements: o2 });
  const u2 = {};
  o2.filter((t4) => "clipPath" === Ko(t4)).forEach((t4) => {
    t4.setAttribute("originalTransform", t4.getAttribute("transform") || "");
    const e2 = t4.getAttribute("id");
    u2[e2] = Array.from(t4.getElementsByTagName("*")).filter((t5) => na(t5));
  });
  const d2 = new ra(c2, a2, s2, t3, u2);
  return { objects: await d2.parse(), elements: c2, options: a2, allElements: o2 };
}
function ha(t3, e2, s2) {
  return aa(new (y()).DOMParser().parseFromString(t3.trim(), "text/xml"), e2, s2);
}
function ca(t3, e2) {
  let s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  return new Promise((e3, i2) => {
    rn(t3.replace(/^\n\s*/, "").trim(), { onComplete: (t4) => {
      const s3 = t4.responseXML;
      s3 && e3(s3), i2();
    }, signal: s2.signal });
  }).then((t4) => aa(t4, e2, s2)).catch(() => oa());
}
var la = "modifyPoly";
var ua = (t3) => function(e2, s2, i2) {
  const { points: r2, pathOffset: n2 } = i2;
  return new U(r2[t3]).subtract(n2).transform(ct(i2.getViewportTransform(), i2.calcTransformMatrix()));
};
var da = (t3, e2, s2, i2) => {
  const { target: r2, pointIndex: n2 } = e2, o2 = r2, a2 = ue(new U(s2, i2), void 0, o2.calcOwnMatrix());
  return o2.points[n2] = a2.add(o2.pathOffset), o2.setDimensions(), true;
};
var ga = (t3, s2) => function(i2, r2, n2, o2) {
  const a2 = r2.target, h2 = new U(a2.points[(t3 > 0 ? t3 : a2.points.length) - 1]), c2 = h2.subtract(a2.pathOffset).transform(a2.calcOwnMatrix()), l2 = s2(i2, e(e({}, r2), {}, { pointIndex: t3 }), n2, o2), u2 = h2.subtract(a2.pathOffset).transform(a2.calcOwnMatrix()).subtract(c2);
  return a2.left -= u2.x, a2.top -= u2.y, l2;
};
var fa = (t3) => Es(la, ga(t3, da));
var pa = Object.freeze({ __proto__: null, changeWidth: js, createObjectDefaultControls: ni, createPolyActionHandler: fa, createPolyControls: function(t3) {
  let s2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const i2 = {};
  for (let r2 = 0; r2 < ("number" == typeof t3 ? t3 : t3.points.length); r2++)
    i2["p".concat(r2)] = new Rs(e({ actionName: la, positionHandler: ua(r2), actionHandler: fa(r2) }, s2));
  return i2;
}, createPolyPositionHandler: ua, createResizeControls: oi, createTextboxDefaultControls: ai, dragHandler: Se, factoryPolyActionHandler: ga, getLocalPoint: we, polyActionHandler: da, renderCircleControl: Fs, renderSquareControl: Ls, rotationStyleHandler: Bs, rotationWithSnapping: Is, scaleCursorStyleHandler: Vs, scaleOrSkewActionName: ei, scaleSkewCursorStyleHandler: si, scalingEqually: Hs, scalingX: Gs, scalingXOrSkewingY: ii, scalingY: Us, scalingYOrSkewingX: ri, skewCursorStyleHandler: Js, skewHandlerX: Qs, skewHandlerY: $s, wrapWithFireEvent: Es, wrapWithFixedAnchor: As });
var ma = (t3) => void 0 !== t3.webgl;
var va = (t3, e2) => {
  const s2 = et(), i2 = et().getContext("webgl"), r2 = { imageBuffer: new ArrayBuffer(t3 * e2 * 4) }, n2 = { destinationWidth: t3, destinationHeight: e2, targetCanvas: s2 };
  let o2;
  s2.width = t3, s2.height = e2, o2 = y().performance.now(), Yo.prototype.copyGLTo2D.call(r2, i2, n2);
  const a2 = y().performance.now() - o2;
  o2 = y().performance.now(), Yo.prototype.copyGLTo2DPutImageData.call(r2, i2, n2);
  return a2 > y().performance.now() - o2;
};
var ya = "precision highp float";
var _a = "\n    ".concat(ya, ";\n    varying vec2 vTexCoord;\n    uniform sampler2D uTexture;\n    void main() {\n      gl_FragColor = texture2D(uTexture, vTexCoord);\n    }");
var xa = ["type"];
var Ca = ["type"];
var ba = new RegExp(ya, "g");
var wa = class {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let t3 = i(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, xa);
    s(this, "vertexSource", "\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    void main() {\n      vTexCoord = aPosition;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }"), Object.assign(this, this.constructor.defaults, t3);
  }
  getFragmentSource() {
    return _a;
  }
  createProgram(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getFragmentSource(), s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.vertexSource;
    const { WebGLProbe: { GLPrecision: i2 = "highp" } } = m();
    "highp" !== i2 && (e2 = e2.replace(ba, ya.replace("highp", i2)));
    const r2 = t3.createShader(t3.VERTEX_SHADER), n2 = t3.createShader(t3.FRAGMENT_SHADER), o2 = t3.createProgram();
    if (!r2 || !n2 || !o2)
      throw new c("Vertex, fragment shader or program creation error");
    if (t3.shaderSource(r2, s2), t3.compileShader(r2), !t3.getShaderParameter(r2, t3.COMPILE_STATUS))
      throw new c("Vertex shader compile error for ".concat(this.type, ": ").concat(t3.getShaderInfoLog(r2)));
    if (t3.shaderSource(n2, e2), t3.compileShader(n2), !t3.getShaderParameter(n2, t3.COMPILE_STATUS))
      throw new c("Fragment shader compile error for ".concat(this.type, ": ").concat(t3.getShaderInfoLog(n2)));
    if (t3.attachShader(o2, r2), t3.attachShader(o2, n2), t3.linkProgram(o2), !t3.getProgramParameter(o2, t3.LINK_STATUS))
      throw new c('Shader link error for "'.concat(this.type, '" ').concat(t3.getProgramInfoLog(o2)));
    const a2 = this.getUniformLocations(t3, o2) || {};
    return a2.uStepW = t3.getUniformLocation(o2, "uStepW"), a2.uStepH = t3.getUniformLocation(o2, "uStepH"), { program: o2, attributeLocations: this.getAttributeLocations(t3, o2), uniformLocations: a2 };
  }
  getAttributeLocations(t3, e2) {
    return { aPosition: t3.getAttribLocation(e2, "aPosition") };
  }
  getUniformLocations(t3, e2) {
    return {};
  }
  sendAttributeData(t3, e2, s2) {
    const i2 = e2.aPosition, r2 = t3.createBuffer();
    t3.bindBuffer(t3.ARRAY_BUFFER, r2), t3.enableVertexAttribArray(i2), t3.vertexAttribPointer(i2, 2, t3.FLOAT, false, 0, 0), t3.bufferData(t3.ARRAY_BUFFER, s2, t3.STATIC_DRAW);
  }
  _setupFrameBuffer(t3) {
    const e2 = t3.context;
    if (t3.passes > 1) {
      const s2 = t3.destinationWidth, i2 = t3.destinationHeight;
      t3.sourceWidth === s2 && t3.sourceHeight === i2 || (e2.deleteTexture(t3.targetTexture), t3.targetTexture = t3.filterBackend.createTexture(e2, s2, i2)), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t3.targetTexture, 0);
    } else
      e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.finish();
  }
  _swapTextures(t3) {
    t3.passes--, t3.pass++;
    const e2 = t3.targetTexture;
    t3.targetTexture = t3.sourceTexture, t3.sourceTexture = e2;
  }
  isNeutralState(t3) {
    const e2 = this.mainParameter, s2 = this.constructor.defaults[e2];
    if (e2) {
      const t4 = this[e2];
      return Array.isArray(s2) && Array.isArray(t4) ? s2.every((e3, s3) => e3 === t4[s3]) : s2 === t4;
    }
    return false;
  }
  applyTo(t3) {
    ma(t3) ? (this._setupFrameBuffer(t3), this.applyToWebGL(t3), this._swapTextures(t3)) : this.applyTo2d(t3);
  }
  applyTo2d(t3) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(t3) {
    const e2 = this.getCacheKey();
    return t3.programCache[e2] || (t3.programCache[e2] = this.createProgram(t3.context)), t3.programCache[e2];
  }
  applyToWebGL(t3) {
    const e2 = t3.context, s2 = this.retrieveShader(t3);
    0 === t3.pass && t3.originalTexture ? e2.bindTexture(e2.TEXTURE_2D, t3.originalTexture) : e2.bindTexture(e2.TEXTURE_2D, t3.sourceTexture), e2.useProgram(s2.program), this.sendAttributeData(e2, s2.attributeLocations, t3.aPosition), e2.uniform1f(s2.uniformLocations.uStepW, 1 / t3.sourceWidth), e2.uniform1f(s2.uniformLocations.uStepH, 1 / t3.sourceHeight), this.sendUniformData(e2, s2.uniformLocations), e2.viewport(0, 0, t3.destinationWidth, t3.destinationHeight), e2.drawArrays(e2.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(t3, e2, s2) {
    t3.activeTexture(s2), t3.bindTexture(t3.TEXTURE_2D, e2), t3.activeTexture(t3.TEXTURE0);
  }
  unbindAdditionalTexture(t3, e2) {
    t3.activeTexture(e2), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE0);
  }
  getMainParameter() {
    return this.mainParameter ? this[this.mainParameter] : void 0;
  }
  setMainParameter(t3) {
    this.mainParameter && (this[this.mainParameter] = t3);
  }
  sendUniformData(t3, e2) {
  }
  createHelpLayer(t3) {
    if (!t3.helpLayer) {
      const e2 = et();
      e2.width = t3.sourceWidth, e2.height = t3.sourceHeight, t3.helpLayer = e2;
    }
  }
  toObject() {
    const t3 = this.mainParameter;
    return e({ type: this.type }, t3 ? { [t3]: this[t3] } : {});
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(t3, e2) {
    return new this(i(t3, Ca));
  }
};
s(wa, "type", "BaseFilter");
var Sa = { multiply: "gl_FragColor.rgb *= uColor.rgb;\n", screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n", add: "gl_FragColor.rgb += uColor.rgb;\n", difference: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n", subtract: "gl_FragColor.rgb -= uColor.rgb;\n", lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n", darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n", exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n", overlay: "\n    if (uColor.r < 0.5) {\n      gl_FragColor.r *= 2.0 * uColor.r;\n    } else {\n      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n    }\n    if (uColor.g < 0.5) {\n      gl_FragColor.g *= 2.0 * uColor.g;\n    } else {\n      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n    }\n    if (uColor.b < 0.5) {\n      gl_FragColor.b *= 2.0 * uColor.b;\n    } else {\n      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n    }\n    ", tint: "\n    gl_FragColor.rgb *= (1.0 - uColor.a);\n    gl_FragColor.rgb += uColor.rgb;\n    " };
var Ta = class extends wa {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return "\n      precision highp float;\n      uniform sampler2D uTexture;\n      uniform vec4 uColor;\n      varying vec2 vTexCoord;\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        gl_FragColor = color;\n        if (color.a > 0.0) {\n          ".concat(Sa[this.mode], "\n        }\n      }\n      ");
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    const s2 = new At(this.color).getSource(), i2 = s2[0] * this.alpha, r2 = s2[1] * this.alpha, n2 = s2[2] * this.alpha, o2 = 1 - this.alpha;
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const s3 = e2[t4], a2 = e2[t4 + 1], h2 = e2[t4 + 2];
      switch (this.mode) {
        case "multiply":
          e2[t4] = s3 * i2 / 255, e2[t4 + 1] = a2 * r2 / 255, e2[t4 + 2] = h2 * n2 / 255;
          break;
        case "screen":
          e2[t4] = 255 - (255 - s3) * (255 - i2) / 255, e2[t4 + 1] = 255 - (255 - a2) * (255 - r2) / 255, e2[t4 + 2] = 255 - (255 - h2) * (255 - n2) / 255;
          break;
        case "add":
          e2[t4] = s3 + i2, e2[t4 + 1] = a2 + r2, e2[t4 + 2] = h2 + n2;
          break;
        case "difference":
          e2[t4] = Math.abs(s3 - i2), e2[t4 + 1] = Math.abs(a2 - r2), e2[t4 + 2] = Math.abs(h2 - n2);
          break;
        case "subtract":
          e2[t4] = s3 - i2, e2[t4 + 1] = a2 - r2, e2[t4 + 2] = h2 - n2;
          break;
        case "darken":
          e2[t4] = Math.min(s3, i2), e2[t4 + 1] = Math.min(a2, r2), e2[t4 + 2] = Math.min(h2, n2);
          break;
        case "lighten":
          e2[t4] = Math.max(s3, i2), e2[t4 + 1] = Math.max(a2, r2), e2[t4 + 2] = Math.max(h2, n2);
          break;
        case "overlay":
          e2[t4] = i2 < 128 ? 2 * s3 * i2 / 255 : 255 - 2 * (255 - s3) * (255 - i2) / 255, e2[t4 + 1] = r2 < 128 ? 2 * a2 * r2 / 255 : 255 - 2 * (255 - a2) * (255 - r2) / 255, e2[t4 + 2] = n2 < 128 ? 2 * h2 * n2 / 255 : 255 - 2 * (255 - h2) * (255 - n2) / 255;
          break;
        case "exclusion":
          e2[t4] = i2 + s3 - 2 * i2 * s3 / 255, e2[t4 + 1] = r2 + a2 - 2 * r2 * a2 / 255, e2[t4 + 2] = n2 + h2 - 2 * n2 * h2 / 255;
          break;
        case "tint":
          e2[t4] = i2 + s3 * o2, e2[t4 + 1] = r2 + a2 * o2, e2[t4 + 2] = n2 + h2 * o2;
      }
    }
  }
  getUniformLocations(t3, e2) {
    return { uColor: t3.getUniformLocation(e2, "uColor") };
  }
  sendUniformData(t3, e2) {
    const s2 = new At(this.color).getSource();
    s2[0] = this.alpha * s2[0] / 255, s2[1] = this.alpha * s2[1] / 255, s2[2] = this.alpha * s2[2] / 255, s2[3] = this.alpha, t3.uniform4fv(e2.uColor, s2);
  }
  toObject() {
    return { type: this.type, color: this.color, mode: this.mode, alpha: this.alpha };
  }
};
s(Ta, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), s(Ta, "type", "BlendColor"), I.setClass(Ta);
var Oa = { multiply: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.rgba *= color2.rgba;\n      gl_FragColor = color;\n    }\n    ", mask: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.a = color2.a;\n      gl_FragColor = color;\n    }\n    " };
var ka = ["type", "image"];
var Da = class extends wa {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return Oa[this.mode];
  }
  applyToWebGL(t3) {
    const e2 = t3.context, s2 = this.createTexture(t3.filterBackend, this.image);
    this.bindAdditionalTexture(e2, s2, e2.TEXTURE1), super.applyToWebGL(t3), this.unbindAdditionalTexture(e2, e2.TEXTURE1);
  }
  createTexture(t3, e2) {
    return t3.getCachedTexture(e2.cacheKey, e2.getElement());
  }
  calculateMatrix() {
    const t3 = this.image, { width: e2, height: s2 } = t3.getElement();
    return [1 / t3.scaleX, 0, 0, 0, 1 / t3.scaleY, 0, -t3.left / e2, -t3.top / s2, 1];
  }
  applyTo2d(t3) {
    let { imageData: { data: e2, width: s2, height: i2 }, filterBackend: { resources: r2 } } = t3;
    const n2 = this.image;
    r2.blendImage || (r2.blendImage = et());
    const o2 = r2.blendImage, a2 = o2.getContext("2d");
    o2.width !== s2 || o2.height !== i2 ? (o2.width = s2, o2.height = i2) : a2.clearRect(0, 0, s2, i2), a2.setTransform(n2.scaleX, 0, 0, n2.scaleY, n2.left, n2.top), a2.drawImage(n2.getElement(), 0, 0, s2, i2);
    const h2 = a2.getImageData(0, 0, s2, i2).data;
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const s3 = e2[t4], i3 = e2[t4 + 1], r3 = e2[t4 + 2], n3 = e2[t4 + 3], o3 = h2[t4], a3 = h2[t4 + 1], c2 = h2[t4 + 2], l2 = h2[t4 + 3];
      switch (this.mode) {
        case "multiply":
          e2[t4] = s3 * o3 / 255, e2[t4 + 1] = i3 * a3 / 255, e2[t4 + 2] = r3 * c2 / 255, e2[t4 + 3] = n3 * l2 / 255;
          break;
        case "mask":
          e2[t4 + 3] = l2;
      }
    }
  }
  getUniformLocations(t3, e2) {
    return { uTransformMatrix: t3.getUniformLocation(e2, "uTransformMatrix"), uImage: t3.getUniformLocation(e2, "uImage") };
  }
  sendUniformData(t3, e2) {
    const s2 = this.calculateMatrix();
    t3.uniform1i(e2.uImage, 1), t3.uniformMatrix3fv(e2.uTransformMatrix, false, s2);
  }
  toObject() {
    return { type: this.type, image: this.image && this.image.toObject(), mode: this.mode, alpha: this.alpha };
  }
  static fromObject(t3, s2) {
    let { type: r2, image: n2 } = t3, o2 = i(t3, ka);
    return No.fromObject(n2, s2).then((t4) => new this(e(e({}, o2), {}, { image: t4 })));
  }
};
s(Da, "type", "BlendImage"), s(Da, "defaults", { mode: "multiply", alpha: 1, vertexSource: "\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    uniform mat3 uTransformMatrix;\n    void main() {\n      vTexCoord = aPosition;\n      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n    " }), I.setClass(Da);
var Ma = class extends wa {
  getFragmentSource() {
    return "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n    const float nSamples = 15.0;\n    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n    float random(vec3 scale) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n    }\n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n      float offset = random(v3offset);\n      for (float t = -nSamples; t <= nSamples; t++) {\n        float percent = (t + offset - 0.5) / nSamples;\n        float weight = 1.0 - abs(percent);\n        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n        total += weight;\n      }\n      gl_FragColor = color / total;\n    }\n  ";
  }
  applyTo(t3) {
    ma(t3) ? (this.aspectRatio = t3.sourceWidth / t3.sourceHeight, t3.passes++, this._setupFrameBuffer(t3), this.horizontal = true, this.applyToWebGL(t3), this._swapTextures(t3), this._setupFrameBuffer(t3), this.horizontal = false, this.applyToWebGL(t3), this._swapTextures(t3)) : this.applyTo2d(t3);
  }
  applyTo2d(t3) {
    t3.imageData = this.simpleBlur(t3);
  }
  simpleBlur(t3) {
    let { ctx: e2, imageData: s2, filterBackend: { resources: i2 } } = t3;
    const { width: r2, height: n2 } = s2;
    i2.blurLayer1 || (i2.blurLayer1 = et(), i2.blurLayer2 = et());
    const o2 = i2.blurLayer1, a2 = i2.blurLayer2;
    o2.width === r2 && o2.height === n2 || (a2.width = o2.width = r2, a2.height = o2.height = n2);
    const h2 = o2.getContext("2d"), c2 = a2.getContext("2d"), l2 = 15, u2 = 0.06 * this.blur * 0.5;
    let d2, g2, f2, p2;
    for (h2.putImageData(s2, 0, 0), c2.clearRect(0, 0, r2, n2), p2 = -15; p2 <= l2; p2++)
      d2 = (Math.random() - 0.5) / 4, g2 = p2 / l2, f2 = u2 * g2 * r2 + d2, c2.globalAlpha = 1 - Math.abs(g2), c2.drawImage(o2, f2, d2), h2.drawImage(a2, 0, 0), c2.globalAlpha = 1, c2.clearRect(0, 0, a2.width, a2.height);
    for (p2 = -15; p2 <= l2; p2++)
      d2 = (Math.random() - 0.5) / 4, g2 = p2 / l2, f2 = u2 * g2 * n2 + d2, c2.globalAlpha = 1 - Math.abs(g2), c2.drawImage(o2, d2, f2), h2.drawImage(a2, 0, 0), c2.globalAlpha = 1, c2.clearRect(0, 0, a2.width, a2.height);
    e2.drawImage(o2, 0, 0);
    const m2 = e2.getImageData(0, 0, o2.width, o2.height);
    return h2.globalAlpha = 1, h2.clearRect(0, 0, o2.width, o2.height), m2;
  }
  getUniformLocations(t3, e2) {
    return { delta: t3.getUniformLocation(e2, "uDelta") };
  }
  sendUniformData(t3, e2) {
    const s2 = this.chooseRightDelta();
    t3.uniform2fv(e2.delta, s2);
  }
  chooseRightDelta() {
    let t3 = 1;
    const e2 = [0, 0];
    this.horizontal ? this.aspectRatio > 1 && (t3 = 1 / this.aspectRatio) : this.aspectRatio < 1 && (t3 = this.aspectRatio);
    const s2 = t3 * this.blur * 0.12;
    return this.horizontal ? e2[0] = s2 : e2[1] = s2, e2;
  }
};
s(Ma, "type", "Blur"), s(Ma, "defaults", { blur: 0, mainParameter: "blur" }), I.setClass(Ma);
var Pa = class extends wa {
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBrightness;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += uBrightness;\n    gl_FragColor = color;\n  }\n";
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    if (0 === this.brightness)
      return;
    const s2 = Math.round(255 * this.brightness);
    for (let t4 = 0; t4 < e2.length; t4 += 4)
      e2[t4] = e2[t4] + s2, e2[t4 + 1] = e2[t4 + 1] + s2, e2[t4 + 2] = e2[t4 + 2] + s2;
  }
  getUniformLocations(t3, e2) {
    return { uBrightness: t3.getUniformLocation(e2, "uBrightness") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1f(e2.uBrightness, this.brightness);
  }
};
s(Pa, "type", "Brightness"), s(Pa, "defaults", { brightness: 0, mainParameter: "brightness" }), I.setClass(Pa);
var Ea = ["matrix"];
var Aa = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], mainParameter: "matrix", colorsOnly: true };
var ja = class extends wa {
  setOptions(t3) {
    let { matrix: e2 } = t3, s2 = i(t3, Ea);
    e2 && (this.matrix = [...e2]), Object.assign(this, s2);
  }
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  varying vec2 vTexCoord;\n  uniform mat4 uColorMatrix;\n  uniform vec4 uConstants;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color *= uColorMatrix;\n    color += uConstants;\n    gl_FragColor = color;\n  }";
  }
  applyTo2d(t3) {
    const e2 = t3.imageData.data, s2 = this.matrix, i2 = this.colorsOnly;
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const r2 = e2[t4], n2 = e2[t4 + 1], o2 = e2[t4 + 2];
      if (i2)
        e2[t4] = r2 * s2[0] + n2 * s2[1] + o2 * s2[2] + 255 * s2[4], e2[t4 + 1] = r2 * s2[5] + n2 * s2[6] + o2 * s2[7] + 255 * s2[9], e2[t4 + 2] = r2 * s2[10] + n2 * s2[11] + o2 * s2[12] + 255 * s2[14];
      else {
        const i3 = e2[t4 + 3];
        e2[t4] = r2 * s2[0] + n2 * s2[1] + o2 * s2[2] + i3 * s2[3] + 255 * s2[4], e2[t4 + 1] = r2 * s2[5] + n2 * s2[6] + o2 * s2[7] + i3 * s2[8] + 255 * s2[9], e2[t4 + 2] = r2 * s2[10] + n2 * s2[11] + o2 * s2[12] + i3 * s2[13] + 255 * s2[14], e2[t4 + 3] = r2 * s2[15] + n2 * s2[16] + o2 * s2[17] + i3 * s2[18] + 255 * s2[19];
      }
    }
  }
  getUniformLocations(t3, e2) {
    return { uColorMatrix: t3.getUniformLocation(e2, "uColorMatrix"), uConstants: t3.getUniformLocation(e2, "uConstants") };
  }
  sendUniformData(t3, e2) {
    const s2 = this.matrix, i2 = [s2[0], s2[1], s2[2], s2[3], s2[5], s2[6], s2[7], s2[8], s2[10], s2[11], s2[12], s2[13], s2[15], s2[16], s2[17], s2[18]], r2 = [s2[4], s2[9], s2[14], s2[19]];
    t3.uniformMatrix4fv(e2.uColorMatrix, false, i2), t3.uniform4fv(e2.uConstants, r2);
  }
};
function Fa(t3, i2) {
  var r2;
  const n2 = (s(r2 = class extends ja {
  }, "type", t3), s(r2, "defaults", e(e({}, Aa), {}, { mainParameter: void 0, matrix: i2 })), r2);
  return I.setClass(n2, t3), n2;
}
s(ja, "type", "ColorMatrix"), s(ja, "defaults", Aa), I.setClass(ja);
var La = Fa("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
var Ra = Fa("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
var Ba = Fa("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
var Ia = Fa("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
var Xa = Fa("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
var Ya = Fa("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
var Wa = Fa("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
var Va = ["subFilters"];
var za = class extends wa {
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { subFilters: e2 = [] } = t3;
    super(i(t3, Va)), this.subFilters = e2;
  }
  applyTo(t3) {
    ma(t3) && (t3.passes += this.subFilters.length - 1), this.subFilters.forEach((e2) => {
      e2.applyTo(t3);
    });
  }
  toObject() {
    return e(e({}, super.toObject()), {}, { subFilters: this.subFilters.map((t3) => t3.toObject()) });
  }
  isNeutralState() {
    return !this.subFilters.some((t3) => !t3.isNeutralState());
  }
  static fromObject(t3, e2) {
    return Promise.all((t3.subFilters || []).map((t4) => I.getClass(t4.type).fromObject(t4, e2))).then((t4) => new this({ subFilters: t4 }));
  }
};
s(za, "type", "Composed"), I.setClass(za);
var Ha = class extends wa {
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uContrast;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n    gl_FragColor = color;\n  }";
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    if (0 === this.contrast)
      return;
    const s2 = Math.floor(255 * this.contrast), i2 = 259 * (s2 + 255) / (255 * (259 - s2));
    for (let t4 = 0; t4 < e2.length; t4 += 4)
      e2[t4] = i2 * (e2[t4] - 128) + 128, e2[t4 + 1] = i2 * (e2[t4 + 1] - 128) + 128, e2[t4 + 2] = i2 * (e2[t4 + 2] - 128) + 128;
  }
  getUniformLocations(t3, e2) {
    return { uContrast: t3.getUniformLocation(e2, "uContrast") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1f(e2.uContrast, this.contrast);
  }
};
s(Ha, "type", "Contrast"), s(Ha, "defaults", { contrast: 0, mainParameter: "contrast" }), I.setClass(Ha);
var Ga = { Convolute_3_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ", Convolute_3_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ", Convolute_5_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ", Convolute_5_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ", Convolute_7_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ", Convolute_7_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ", Convolute_9_1: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ", Convolute_9_0: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    " };
var Ua = class extends wa {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return Ga[this.getCacheKey()];
  }
  applyTo2d(t3) {
    const e2 = t3.imageData, s2 = e2.data, i2 = this.matrix, r2 = Math.round(Math.sqrt(i2.length)), n2 = Math.floor(r2 / 2), o2 = e2.width, a2 = e2.height, h2 = t3.ctx.createImageData(o2, a2), c2 = h2.data, l2 = this.opaque ? 1 : 0;
    let u2, d2, g2, f2, p2, m2, v2, y2, _2, x2, C2, b2, w2;
    for (C2 = 0; C2 < a2; C2++)
      for (x2 = 0; x2 < o2; x2++) {
        for (p2 = 4 * (C2 * o2 + x2), u2 = 0, d2 = 0, g2 = 0, f2 = 0, w2 = 0; w2 < r2; w2++)
          for (b2 = 0; b2 < r2; b2++)
            v2 = C2 + w2 - n2, m2 = x2 + b2 - n2, v2 < 0 || v2 >= a2 || m2 < 0 || m2 >= o2 || (y2 = 4 * (v2 * o2 + m2), _2 = i2[w2 * r2 + b2], u2 += s2[y2] * _2, d2 += s2[y2 + 1] * _2, g2 += s2[y2 + 2] * _2, l2 || (f2 += s2[y2 + 3] * _2));
        c2[p2] = u2, c2[p2 + 1] = d2, c2[p2 + 2] = g2, c2[p2 + 3] = l2 ? s2[p2 + 3] : f2;
      }
    t3.imageData = h2;
  }
  getUniformLocations(t3, e2) {
    return { uMatrix: t3.getUniformLocation(e2, "uMatrix"), uOpaque: t3.getUniformLocation(e2, "uOpaque"), uHalfSize: t3.getUniformLocation(e2, "uHalfSize"), uSize: t3.getUniformLocation(e2, "uSize") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1fv(e2.uMatrix, this.matrix);
  }
  toObject() {
    return e(e({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
};
s(Ua, "type", "Convolute"), s(Ua, "defaults", { opaque: false, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), I.setClass(Ua);
var Na = ["gamma"];
var qa = class extends wa {
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform vec3 uGamma;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    vec3 correction = (1.0 / uGamma);\n    color.r = pow(color.r, correction.r);\n    color.g = pow(color.g, correction.g);\n    color.b = pow(color.b, correction.b);\n    gl_FragColor = color;\n    gl_FragColor.rgb *= color.a;\n  }\n";
  }
  constructor() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { gamma: e2 = [1, 1, 1] } = t3;
    super(i(t3, Na)), this.gamma = e2;
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    const s2 = this.gamma, i2 = 1 / s2[0], r2 = 1 / s2[1], n2 = 1 / s2[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const o2 = this.rgbValues;
    for (let t4 = 0; t4 < 256; t4++)
      o2.r[t4] = 255 * Math.pow(t4 / 255, i2), o2.g[t4] = 255 * Math.pow(t4 / 255, r2), o2.b[t4] = 255 * Math.pow(t4 / 255, n2);
    for (let t4 = 0; t4 < e2.length; t4 += 4)
      e2[t4] = o2.r[e2[t4]], e2[t4 + 1] = o2.g[e2[t4 + 1]], e2[t4 + 2] = o2.b[e2[t4 + 2]];
  }
  getUniformLocations(t3, e2) {
    return { uGamma: t3.getUniformLocation(e2, "uGamma") };
  }
  sendUniformData(t3, e2) {
    t3.uniform3fv(e2.uGamma, this.gamma);
  }
};
s(qa, "type", "Gamma"), s(qa, "defaults", { mainParameter: "gamma", gamma: [1, 1, 1] }), I.setClass(qa);
var Ka = { average: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      float average = (color.r + color.b + color.g) / 3.0;\n      gl_FragColor = vec4(average, average, average, color.a);\n    }\n    ", lightness: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    ", luminosity: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    " };
var Ja = class extends wa {
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    for (let t4, s2 = 0; s2 < e2.length; s2 += 4) {
      switch (this.mode) {
        case "average":
          t4 = (e2[s2] + e2[s2 + 1] + e2[s2 + 2]) / 3;
          break;
        case "lightness":
          t4 = (Math.min(e2[s2], e2[s2 + 1], e2[s2 + 2]) + Math.max(e2[s2], e2[s2 + 1], e2[s2 + 2])) / 2;
          break;
        case "luminosity":
          t4 = 0.21 * e2[s2] + 0.72 * e2[s2 + 1] + 0.07 * e2[s2 + 2];
      }
      e2[s2] = t4, e2[s2 + 1] = t4, e2[s2 + 2] = t4;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return Ka[this.mode];
  }
  getUniformLocations(t3, e2) {
    return { uMode: t3.getUniformLocation(e2, "uMode") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1i(e2.uMode, 1);
  }
  isNeutralState() {
    return false;
  }
};
s(Ja, "type", "Grayscale"), s(Ja, "defaults", { mode: "average", mainParameter: "mode" }), I.setClass(Ja);
var Za = class extends ja {
  calculateMatrix() {
    const t3 = this.rotation * Math.PI, e2 = H(t3), s2 = G(t3), i2 = 1 / 3, r2 = Math.sqrt(i2) * s2, n2 = 1 - e2;
    this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = e2 + n2 / 3, this.matrix[1] = i2 * n2 - r2, this.matrix[2] = i2 * n2 + r2, this.matrix[5] = i2 * n2 + r2, this.matrix[6] = e2 + i2 * n2, this.matrix[7] = i2 * n2 - r2, this.matrix[10] = i2 * n2 - r2, this.matrix[11] = i2 * n2 + r2, this.matrix[12] = e2 + i2 * n2;
  }
  isNeutralState() {
    return this.calculateMatrix(), super.isNeutralState();
  }
  applyTo(t3) {
    this.calculateMatrix(), super.applyTo(t3);
  }
};
s(Za, "type", "HueRotation"), s(Za, "defaults", { rotation: 0, mainParameter: "rotation" }), I.setClass(Za);
var Qa = class extends wa {
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    for (let t4 = 0; t4 < e2.length; t4 += 4)
      e2[t4] = 255 - e2[t4], e2[t4 + 1] = 255 - e2[t4 + 1], e2[t4 + 2] = 255 - e2[t4 + 2], this.alpha && (e2[t4 + 3] = 255 - e2[t4 + 3]);
  }
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform int uInvert;\n  uniform int uAlpha;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    if (uInvert == 1) {\n      if (uAlpha == 1) {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);\n      } else {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n      }\n    } else {\n      gl_FragColor = color;\n    }\n  }\n";
  }
  isNeutralState() {
    return !this.invert;
  }
  getUniformLocations(t3, e2) {
    return { uInvert: t3.getUniformLocation(e2, "uInvert"), uAlpha: t3.getUniformLocation(e2, "uAlpha") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1i(e2.uInvert, Number(this.invert)), t3.uniform1i(e2.uAlpha, Number(this.alpha));
  }
};
s(Qa, "type", "Invert"), s(Qa, "defaults", { alpha: false, invert: true, mainParameter: "invert" }), I.setClass(Qa);
var $a = class extends wa {
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uStepH;\n  uniform float uNoise;\n  uniform float uSeed;\n  varying vec2 vTexCoord;\n  float rand(vec2 co, float seed, float vScale) {\n    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n  }\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n    gl_FragColor = color;\n  }\n";
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    if (0 === this.noise)
      return;
    const s2 = this.noise;
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const i2 = (0.5 - Math.random()) * s2;
      e2[t4] += i2, e2[t4 + 1] += i2, e2[t4 + 2] += i2;
    }
  }
  getUniformLocations(t3, e2) {
    return { uNoise: t3.getUniformLocation(e2, "uNoise"), uSeed: t3.getUniformLocation(e2, "uSeed") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1f(e2.uNoise, this.noise / 255), t3.uniform1f(e2.uSeed, Math.random());
  }
  toObject() {
    return e(e({}, super.toObject()), {}, { noise: this.noise });
  }
};
s($a, "type", "Noise"), s($a, "defaults", { mainParameter: "noise", noise: 0 }), I.setClass($a);
var th = class extends wa {
  applyTo2d(t3) {
    let { imageData: { data: e2, width: s2, height: i2 } } = t3;
    for (let t4 = 0; t4 < i2; t4 += this.blocksize)
      for (let r2 = 0; r2 < s2; r2 += this.blocksize) {
        const n2 = 4 * t4 * s2 + 4 * r2, o2 = e2[n2], a2 = e2[n2 + 1], h2 = e2[n2 + 2], c2 = e2[n2 + 3];
        for (let n3 = t4; n3 < Math.min(t4 + this.blocksize, i2); n3++)
          for (let t5 = r2; t5 < Math.min(r2 + this.blocksize, s2); t5++) {
            const i3 = 4 * n3 * s2 + 4 * t5;
            e2[i3] = o2, e2[i3 + 1] = a2, e2[i3 + 2] = h2, e2[i3 + 3] = c2;
          }
      }
  }
  isNeutralState() {
    return 1 === this.blocksize;
  }
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBlocksize;\n  uniform float uStepW;\n  uniform float uStepH;\n  varying vec2 vTexCoord;\n  void main() {\n    float blockW = uBlocksize * uStepW;\n    float blockH = uBlocksize * uStepW;\n    int posX = int(vTexCoord.x / blockW);\n    int posY = int(vTexCoord.y / blockH);\n    float fposX = float(posX);\n    float fposY = float(posY);\n    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n    vec4 color = texture2D(uTexture, squareCoords);\n    gl_FragColor = color;\n  }\n";
  }
  getUniformLocations(t3, e2) {
    return { uBlocksize: t3.getUniformLocation(e2, "uBlocksize"), uStepW: t3.getUniformLocation(e2, "uStepW"), uStepH: t3.getUniformLocation(e2, "uStepH") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1f(e2.uBlocksize, this.blocksize);
  }
};
s(th, "type", "Pixelate"), s(th, "defaults", { blocksize: 4, mainParameter: "blocksize" }), I.setClass(th);
var eh = class extends wa {
  getFragmentShader() {
    return "\nprecision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_FragColor = texture2D(uTexture, vTexCoord);\n  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n    gl_FragColor.a = 0.0;\n  }\n}\n";
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    const s2 = 255 * this.distance, i2 = new At(this.color).getSource(), r2 = [i2[0] - s2, i2[1] - s2, i2[2] - s2], n2 = [i2[0] + s2, i2[1] + s2, i2[2] + s2];
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const s3 = e2[t4], i3 = e2[t4 + 1], o2 = e2[t4 + 2];
      s3 > r2[0] && i3 > r2[1] && o2 > r2[2] && s3 < n2[0] && i3 < n2[1] && o2 < n2[2] && (e2[t4 + 3] = 0);
    }
  }
  getUniformLocations(t3, e2) {
    return { uLow: t3.getUniformLocation(e2, "uLow"), uHigh: t3.getUniformLocation(e2, "uHigh") };
  }
  sendUniformData(t3, e2) {
    const s2 = new At(this.color).getSource(), i2 = this.distance, r2 = [0 + s2[0] / 255 - i2, 0 + s2[1] / 255 - i2, 0 + s2[2] / 255 - i2, 1], n2 = [s2[0] / 255 + i2, s2[1] / 255 + i2, s2[2] / 255 + i2, 1];
    t3.uniform4fv(e2.uLow, r2), t3.uniform4fv(e2.uHigh, n2);
  }
  toObject() {
    return e(e({}, super.toObject()), {}, { color: this.color, distance: this.distance });
  }
};
s(eh, "type", "RemoveColor"), s(eh, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: false }), I.setClass(eh);
var sh = class extends wa {
  getUniformLocations(t3, e2) {
    return { uDelta: t3.getUniformLocation(e2, "uDelta"), uTaps: t3.getUniformLocation(e2, "uTaps") };
  }
  sendUniformData(t3, e2) {
    t3.uniform2fv(e2.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t3.uniform1fv(e2.uTaps, this.taps);
  }
  getFilterWindow() {
    const t3 = this.tempScale;
    return Math.ceil(this.lanczosLobes / t3);
  }
  getCacheKey() {
    const t3 = this.getFilterWindow();
    return "".concat(this.type, "_").concat(t3);
  }
  getFragmentSource() {
    const t3 = this.getFilterWindow();
    return this.generateShader(t3);
  }
  getTaps() {
    const t3 = this.lanczosCreate(this.lanczosLobes), e2 = this.tempScale, s2 = this.getFilterWindow(), i2 = new Array(s2);
    for (let r2 = 1; r2 <= s2; r2++)
      i2[r2 - 1] = t3(r2 * e2);
    return i2;
  }
  generateShader(t3) {
    const e2 = new Array(t3);
    for (let s2 = 1; s2 <= t3; s2++)
      e2[s2 - 1] = "".concat(s2, ".0 * uDelta");
    return "\n      ".concat(this.fragmentSourceTOP, "\n      uniform float uTaps[").concat(t3, "];\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        float sum = 1.0;\n        ").concat(e2.map((t4, e3) => "\n              color += texture2D(uTexture, vTexCoord + ".concat(t4, ") * uTaps[").concat(e3, "] + texture2D(uTexture, vTexCoord - ").concat(t4, ") * uTaps[").concat(e3, "];\n              sum += 2.0 * uTaps[").concat(e3, "];\n            ")).join("\n"), "\n        gl_FragColor = color / sum;\n      }\n    ");
  }
  applyToForWebgl(t3) {
    t3.passes++, this.width = t3.sourceWidth, this.horizontal = true, this.dW = Math.round(this.width * this.scaleX), this.dH = t3.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t3.destinationWidth = this.dW, super.applyTo(t3), t3.sourceWidth = t3.destinationWidth, this.height = t3.sourceHeight, this.horizontal = false, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t3.destinationHeight = this.dH, super.applyTo(t3), t3.sourceHeight = t3.destinationHeight;
  }
  applyTo(t3) {
    ma(t3) ? this.applyToForWebgl(t3) : this.applyTo2d(t3);
  }
  isNeutralState() {
    return 1 === this.scaleX && 1 === this.scaleY;
  }
  lanczosCreate(t3) {
    return (e2) => {
      if (e2 >= t3 || e2 <= -t3)
        return 0;
      if (e2 < 11920929e-14 && e2 > -11920929e-14)
        return 1;
      const s2 = (e2 *= Math.PI) / t3;
      return Math.sin(e2) / e2 * Math.sin(s2) / s2;
    };
  }
  applyTo2d(t3) {
    const e2 = t3.imageData, s2 = this.scaleX, i2 = this.scaleY;
    this.rcpScaleX = 1 / s2, this.rcpScaleY = 1 / i2;
    const r2 = e2.width, n2 = e2.height, o2 = Math.round(r2 * s2), a2 = Math.round(n2 * i2);
    let h2;
    h2 = "sliceHack" === this.resizeType ? this.sliceByTwo(t3, r2, n2, o2, a2) : "hermite" === this.resizeType ? this.hermiteFastResize(t3, r2, n2, o2, a2) : "bilinear" === this.resizeType ? this.bilinearFiltering(t3, r2, n2, o2, a2) : "lanczos" === this.resizeType ? this.lanczosResize(t3, r2, n2, o2, a2) : new ImageData(o2, a2), t3.imageData = h2;
  }
  sliceByTwo(t3, e2, s2, i2, r2) {
    const n2 = t3.imageData, o2 = 0.5;
    let a2 = false, h2 = false, c2 = e2 * o2, l2 = s2 * o2;
    const u2 = t3.filterBackend.resources;
    let d2 = 0, g2 = 0;
    const f2 = e2;
    let p2 = 0;
    u2.sliceByTwo || (u2.sliceByTwo = et());
    const m2 = u2.sliceByTwo;
    (m2.width < 1.5 * e2 || m2.height < s2) && (m2.width = 1.5 * e2, m2.height = s2);
    const v2 = m2.getContext("2d");
    for (v2.clearRect(0, 0, 1.5 * e2, s2), v2.putImageData(n2, 0, 0), i2 = Math.floor(i2), r2 = Math.floor(r2); !a2 || !h2; )
      e2 = c2, s2 = l2, i2 < Math.floor(c2 * o2) ? c2 = Math.floor(c2 * o2) : (c2 = i2, a2 = true), r2 < Math.floor(l2 * o2) ? l2 = Math.floor(l2 * o2) : (l2 = r2, h2 = true), v2.drawImage(m2, d2, g2, e2, s2, f2, p2, c2, l2), d2 = f2, g2 = p2, p2 += l2;
    return v2.getImageData(d2, g2, i2, r2);
  }
  lanczosResize(t3, e2, s2, i2, r2) {
    const n2 = t3.imageData.data, o2 = t3.ctx.createImageData(i2, r2), a2 = o2.data, h2 = this.lanczosCreate(this.lanczosLobes), c2 = this.rcpScaleX, l2 = this.rcpScaleY, u2 = 2 / this.rcpScaleX, d2 = 2 / this.rcpScaleY, g2 = Math.ceil(c2 * this.lanczosLobes / 2), f2 = Math.ceil(l2 * this.lanczosLobes / 2), p2 = {}, m2 = { x: 0, y: 0 }, v2 = { x: 0, y: 0 };
    return function t4(y2) {
      let _2, x2, C2, b2, w2, S2, T2, O2, k2, D2, M2;
      for (m2.x = (y2 + 0.5) * c2, v2.x = Math.floor(m2.x), _2 = 0; _2 < r2; _2++) {
        for (m2.y = (_2 + 0.5) * l2, v2.y = Math.floor(m2.y), w2 = 0, S2 = 0, T2 = 0, O2 = 0, k2 = 0, x2 = v2.x - g2; x2 <= v2.x + g2; x2++)
          if (!(x2 < 0 || x2 >= e2)) {
            D2 = Math.floor(1e3 * Math.abs(x2 - m2.x)), p2[D2] || (p2[D2] = {});
            for (let t5 = v2.y - f2; t5 <= v2.y + f2; t5++)
              t5 < 0 || t5 >= s2 || (M2 = Math.floor(1e3 * Math.abs(t5 - m2.y)), p2[D2][M2] || (p2[D2][M2] = h2(Math.sqrt(Math.pow(D2 * u2, 2) + Math.pow(M2 * d2, 2)) / 1e3)), C2 = p2[D2][M2], C2 > 0 && (b2 = 4 * (t5 * e2 + x2), w2 += C2, S2 += C2 * n2[b2], T2 += C2 * n2[b2 + 1], O2 += C2 * n2[b2 + 2], k2 += C2 * n2[b2 + 3]));
          }
        b2 = 4 * (_2 * i2 + y2), a2[b2] = S2 / w2, a2[b2 + 1] = T2 / w2, a2[b2 + 2] = O2 / w2, a2[b2 + 3] = k2 / w2;
      }
      return ++y2 < i2 ? t4(y2) : o2;
    }(0);
  }
  bilinearFiltering(t3, e2, s2, i2, r2) {
    let n2, o2, a2, h2, c2, l2, u2, d2, g2, f2, p2, m2, v2, y2 = 0;
    const _2 = this.rcpScaleX, x2 = this.rcpScaleY, C2 = 4 * (e2 - 1), b2 = t3.imageData.data, w2 = t3.ctx.createImageData(i2, r2), S2 = w2.data;
    for (u2 = 0; u2 < r2; u2++)
      for (d2 = 0; d2 < i2; d2++)
        for (c2 = Math.floor(_2 * d2), l2 = Math.floor(x2 * u2), g2 = _2 * d2 - c2, f2 = x2 * u2 - l2, v2 = 4 * (l2 * e2 + c2), p2 = 0; p2 < 4; p2++)
          n2 = b2[v2 + p2], o2 = b2[v2 + 4 + p2], a2 = b2[v2 + C2 + p2], h2 = b2[v2 + C2 + 4 + p2], m2 = n2 * (1 - g2) * (1 - f2) + o2 * g2 * (1 - f2) + a2 * f2 * (1 - g2) + h2 * g2 * f2, S2[y2++] = m2;
    return w2;
  }
  hermiteFastResize(t3, e2, s2, i2, r2) {
    const n2 = this.rcpScaleX, o2 = this.rcpScaleY, a2 = Math.ceil(n2 / 2), h2 = Math.ceil(o2 / 2), c2 = t3.imageData.data, l2 = t3.ctx.createImageData(i2, r2), u2 = l2.data;
    for (let t4 = 0; t4 < r2; t4++)
      for (let s3 = 0; s3 < i2; s3++) {
        const r3 = 4 * (s3 + t4 * i2);
        let l3 = 0, d2 = 0, g2 = 0, f2 = 0, p2 = 0, m2 = 0, v2 = 0;
        const y2 = (t4 + 0.5) * o2;
        for (let i3 = Math.floor(t4 * o2); i3 < (t4 + 1) * o2; i3++) {
          const t5 = Math.abs(y2 - (i3 + 0.5)) / h2, r4 = (s3 + 0.5) * n2, o3 = t5 * t5;
          for (let t6 = Math.floor(s3 * n2); t6 < (s3 + 1) * n2; t6++) {
            let s4 = Math.abs(r4 - (t6 + 0.5)) / a2;
            const n3 = Math.sqrt(o3 + s4 * s4);
            n3 > 1 && n3 < -1 || (l3 = 2 * n3 * n3 * n3 - 3 * n3 * n3 + 1, l3 > 0 && (s4 = 4 * (t6 + i3 * e2), v2 += l3 * c2[s4 + 3], g2 += l3, c2[s4 + 3] < 255 && (l3 = l3 * c2[s4 + 3] / 250), f2 += l3 * c2[s4], p2 += l3 * c2[s4 + 1], m2 += l3 * c2[s4 + 2], d2 += l3));
          }
        }
        u2[r3] = f2 / d2, u2[r3 + 1] = p2 / d2, u2[r3 + 2] = m2 / d2, u2[r3 + 3] = v2 / g2;
      }
    return l2;
  }
  toObject() {
    return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes };
  }
};
s(sh, "type", "Resize"), s(sh, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3, fragmentSourceTOP: "\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n  " }), I.setClass(sh);
var ih = class extends wa {
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uSaturation;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float rgMax = max(color.r, color.g);\n    float rgbMax = max(rgMax, color.b);\n    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n    gl_FragColor = color;\n  }\n";
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    if (0 === this.saturation)
      return;
    const s2 = -this.saturation;
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const i2 = Math.max(e2[t4], e2[t4 + 1], e2[t4 + 2]);
      e2[t4] += i2 !== e2[t4] ? (i2 - e2[t4]) * s2 : 0, e2[t4 + 1] += i2 !== e2[t4 + 1] ? (i2 - e2[t4 + 1]) * s2 : 0, e2[t4 + 2] += i2 !== e2[t4 + 2] ? (i2 - e2[t4 + 2]) * s2 : 0;
    }
  }
  getUniformLocations(t3, e2) {
    return { uSaturation: t3.getUniformLocation(e2, "uSaturation") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1f(e2.uSaturation, -this.saturation);
  }
};
s(ih, "type", "Saturation"), s(ih, "defaults", { saturation: 0, mainParameter: "saturation" }), I.setClass(ih);
var rh = class extends wa {
  getFragmentSource() {
    return "\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uVibrance;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float max = max(color.r, max(color.g, color.b));\n    float avg = (color.r + color.g + color.b) / 3.0;\n    float amt = (abs(max - avg) * 2.0) * uVibrance;\n    color.r += max != color.r ? (max - color.r) * amt : 0.00;\n    color.g += max != color.g ? (max - color.g) * amt : 0.00;\n    color.b += max != color.b ? (max - color.b) * amt : 0.00;\n    gl_FragColor = color;\n  }\n";
  }
  applyTo2d(t3) {
    let { imageData: { data: e2 } } = t3;
    if (0 === this.vibrance)
      return;
    const s2 = -this.vibrance;
    for (let t4 = 0; t4 < e2.length; t4 += 4) {
      const i2 = Math.max(e2[t4], e2[t4 + 1], e2[t4 + 2]), r2 = (e2[t4] + e2[t4 + 1] + e2[t4 + 2]) / 3, n2 = 2 * Math.abs(i2 - r2) / 255 * s2;
      e2[t4] += i2 !== e2[t4] ? (i2 - e2[t4]) * n2 : 0, e2[t4 + 1] += i2 !== e2[t4 + 1] ? (i2 - e2[t4 + 1]) * n2 : 0, e2[t4 + 2] += i2 !== e2[t4 + 2] ? (i2 - e2[t4 + 2]) * n2 : 0;
    }
  }
  getUniformLocations(t3, e2) {
    return { uVibrance: t3.getUniformLocation(e2, "uVibrance") };
  }
  sendUniformData(t3, e2) {
    t3.uniform1f(e2.uVibrance, -this.vibrance);
  }
};
s(rh, "type", "Vibrance"), s(rh, "defaults", { vibrance: 0, mainParameter: "vibrance" }), I.setClass(rh);
var nh = Object.freeze({ __proto__: null, BaseFilter: wa, BlackWhite: Wa, BlendColor: Ta, BlendImage: Da, Blur: Ma, Brightness: Pa, Brownie: La, ColorMatrix: ja, Composed: za, Contrast: Ha, Convolute: Ua, Gamma: qa, Grayscale: Ja, HueRotation: Za, Invert: Qa, Kodachrome: Ba, Noise: $a, Pixelate: th, Polaroid: Xa, RemoveColor: eh, Resize: sh, Saturation: ih, Sepia: Ya, Technicolor: Ia, Vibrance: rh, Vintage: Ra });
export {
  Io as ActiveSelection,
  jn as BaseBrush,
  Ps as BaseFabricObject,
  mn as Canvas,
  Xo as Canvas2dFilterBackend,
  an as CanvasDOMManager,
  Yn as Circle,
  Wn as CircleBrush,
  Fo as ClipPathLayout,
  At as Color,
  Rs as Control,
  Jn as Ellipse,
  No as FabricImage,
  li as FabricObject,
  _o as FabricText,
  ur as FitContentLayout,
  Lo as FixedLayout,
  Pn as Gradient,
  yr as Group,
  Ao as IText,
  No as Image,
  is as Intersection,
  pr as LayoutManager,
  lr as LayoutStrategy,
  Nn as Line,
  li as Object,
  Y as Observable,
  Rn as Path,
  An as Pattern,
  zn as PatternBrush,
  Bn as PencilBrush,
  U as Point,
  eo as Polygon,
  to as Polyline,
  rr as Rect,
  ws as Shadow,
  Vn as SprayBrush,
  Qt as StaticCanvas,
  Jt as StaticCanvasDOMManager,
  _o as Text,
  jo as Textbox,
  qn as Triangle,
  Yo as WebGLFilterBackend,
  x as cache,
  I as classRegistry,
  a as config,
  pa as controlsUtils,
  K as createCollectionMixin,
  nh as filters,
  sa as getCSSRules,
  m as getEnv,
  v as getFabricDocument,
  y as getFabricWindow,
  zo as getFilterBackend,
  O as iMatrix,
  Vo as initFilterBackend,
  va as isPutImageFaster,
  ma as isWebGLPipelineState,
  ha as loadSVGFromString,
  ca as loadSVGFromURL,
  er as parseAttributes,
  Qi as parseFontDeclaration,
  Zn as parsePointsAttribute,
  aa as parseSVGDocument,
  $i as parseStyleAttribute,
  Ji as parseTransformAttribute,
  X as runningAnimations,
  p as setEnv,
  Ho as setFilterBackend,
  on as util,
  C as version
};
//# sourceMappingURL=fabric.js.map
