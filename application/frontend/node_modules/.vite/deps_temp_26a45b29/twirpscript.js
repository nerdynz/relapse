import "./chunk-SSYGV25P.js";

// node_modules/twirpscript/dist/runtime/error/index.js
var TwirpError = class {
  constructor(error) {
    this.code = error.code;
    this.msg = error.msg;
    this.meta = error.meta;
  }
};
var TwirpIntermediaryError = class extends TwirpError {
  constructor(error) {
    super(error);
  }
};
var statusCodeForErrorCode = {
  canceled: 408,
  unknown: 500,
  invalid_argument: 400,
  malformed: 400,
  deadline_exceeded: 408,
  not_found: 404,
  bad_route: 404,
  already_exists: 409,
  permission_denied: 403,
  unauthenticated: 401,
  resource_exhausted: 403,
  failed_precondition: 412,
  aborted: 409,
  out_of_range: 400,
  unimplemented: 501,
  internal: 500,
  unavailable: 503,
  data_loss: 500
};
function isTwirpError(error) {
  if (typeof error === "object" && error !== null) {
    return "code" in error && error.code in statusCodeForErrorCode;
  }
  return false;
}
function errorCodeFromStatusCode(status) {
  if (300 >= status && status <= 400) {
    return "internal";
  }
  const statusError = {
    401: "unauthenticated",
    403: "permission_denied",
    404: "bad_route",
    429: "unavailable",
    502: "unavailable",
    503: "unavailable",
    504: "unavailable"
  };
  return statusError[status] ?? "internal";
}
async function twirpErrorFromResponse(res) {
  const text = await res.text();
  try {
    const json = JSON.parse(text);
    if (isTwirpError(json)) {
      return new TwirpError(json);
    }
  } catch {
  }
  return new TwirpIntermediaryError({
    code: errorCodeFromStatusCode(res.status),
    msg: "HTTP Error from Intermediary Proxy",
    meta: {
      http_error_from_intermediary: "true",
      status_code: res.status.toString(),
      body: text,
      location: res.headers.get("location") ?? void 0
    }
  });
}

// node_modules/twirpscript/dist/runtime/eventEmitter/index.js
function createEventEmitter() {
  const listeners = {};
  return {
    on: (eventName, listener) => {
      var _a;
      listeners[eventName] ?? (listeners[eventName] = []);
      (_a = listeners[eventName]) == null ? void 0 : _a.push(listener);
    },
    off: (eventName, listener) => {
      var _a;
      listeners[eventName] = (_a = listeners[eventName]) == null ? void 0 : _a.filter((x) => x !== listener);
    },
    emit: (eventName, ...args) => {
      var _a;
      (_a = listeners[eventName]) == null ? void 0 : _a.forEach((cb) => {
        cb(...args);
      });
    }
  };
}

// node_modules/twirpscript/dist/runtime/client/index.js
var clientMiddleware = [];
var ee = createEventEmitter();
var fetchTransport = async (url, opts) => {
  return fetch(url, opts);
};
var client = {
  baseURL: "",
  headers: {},
  prefix: "/twirp",
  use(middleware) {
    clientMiddleware.push(middleware);
    return client;
  },
  on: (...args) => {
    ee.on(...args);
    return client;
  },
  off: (...args) => {
    ee.off(...args);
    return client;
  },
  rpcTransport: fetchTransport
};
async function runMiddleware(config, request) {
  let cfg = config;
  let idx = 1;
  const middleware = [...clientMiddleware, request];
  try {
    return await middleware[0](config, function next(c) {
      cfg = c;
      const nxt = middleware[idx];
      idx++;
      return nxt(c, next);
    });
  } catch (e) {
    const error = e instanceof TwirpError ? e : new TwirpError({
      code: "internal",
      msg: "client error"
    });
    ee.emit("error", cfg, error);
    throw e;
  }
}
function mergeConfig(config = {}, path) {
  const baseURL = config.baseURL ?? client.baseURL ?? "";
  const prefix = config.prefix ?? client.prefix ?? "";
  const url = baseURL + prefix + path;
  const rpcTransport = config.rpcTransport ?? client.rpcTransport;
  return {
    url,
    headers: {
      ...client.headers,
      ...config.headers
    },
    rpcTransport
  };
}
async function makeRequest(contentType, path, body, config) {
  return runMiddleware(mergeConfig(config, path), async (c) => {
    ee.emit("requestPrepared", c);
    const res = await c.rpcTransport(c.url, {
      method: "POST",
      headers: {
        accept: contentType,
        "content-type": contentType,
        ...c.headers
      },
      body
    });
    ee.emit("responseReceived", c);
    if (!res.ok) {
      throw await twirpErrorFromResponse(res);
    }
    switch (contentType) {
      case "application/protobuf": {
        const buffer = await res.arrayBuffer();
        return new Uint8Array(buffer);
      }
      case "application/json": {
        return res.text();
      }
      default: {
        const _exhaust = contentType;
        return _exhaust;
      }
    }
  });
}
function JSONrequest(path, body, config) {
  return makeRequest("application/json", path, body, config);
}
function PBrequest(path, body, config) {
  return makeRequest("application/protobuf", path, body, config);
}

// node_modules/twirpscript/dist/runtime/server/requestLogging/index.js
var timingField = "__twirpRequestStartMs__";
function withRequestLogging(app) {
  app.on("requestReceived", (ctx, request) => {
    ctx[timingField] = Date.now();
    console.info(`[TwirpScript] Started ${request.method} "${request.url}"`);
  });
  app.on("requestRouted", (ctx) => {
    var _a, _b;
    console.info(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `[TwirpScript] Processing by ${(_a = ctx.service) == null ? void 0 : _a.name}#${(_b = ctx.method) == null ? void 0 : _b.name} as ${ctx.contentType}`
    );
  });
  app.on("responseSent", (ctx, response) => {
    const time = Date.now() - ctx[timingField];
    console.info(`[TwirpScript] Completed ${response.statusCode} in ${time} ms.`);
  });
  app.on("error", (_ctx, error) => {
    console.error("[TwirpScript] Error:");
    console.error(error);
  });
  return app;
}

// node_modules/twirpscript/dist/runtime/server/index.js
var TWIRPSCRIPT_INVARIANT = "TwirpScript Invariant";
function TwirpErrorResponse(error) {
  return {
    statusCode: statusCodeForErrorCode[error.code],
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify(error)
  };
}
async function executeServiceMethod(method, req, context, ee2) {
  switch (context.contentType) {
    case "JSON": {
      let body;
      try {
        const utf8 = new TextDecoder().decode(req.body);
        body = method.input.json.decode(utf8);
      } catch (e) {
        throw new TwirpError({
          code: "invalid_argument",
          msg: "failed to deserialize argument as JSON"
        });
      }
      ee2.emit("requestRouted", context, body);
      const response = await method.handler(body, context);
      ee2.emit("responsePrepared", context, response);
      return method.output.json.encode(response);
    }
    case "Protobuf": {
      let body;
      try {
        body = method.input.protobuf.decode(req.body);
      } catch (e) {
        throw new TwirpError({
          code: "invalid_argument",
          msg: "failed to deserialize argument as Protobuf"
        });
      }
      ee2.emit("requestRouted", context, body);
      const response = await method.handler(body, context);
      ee2.emit("responsePrepared", context, response);
      return method.output.protobuf.encode(response);
    }
    case "Unknown": {
      throw new Error(TWIRPSCRIPT_INVARIANT);
    }
    default: {
      const _exhaust = context.contentType;
      throw new Error(TWIRPSCRIPT_INVARIANT + _exhaust);
    }
  }
}
function validateRequest(req) {
  if (!req.url) {
    return new TwirpError({
      code: "malformed",
      msg: "no request url provided"
    });
  }
  if (!req.method) {
    return new TwirpError({
      code: "malformed",
      msg: "no request method provided"
    });
  }
  if (req.method !== "POST") {
    return new TwirpError({
      code: "malformed",
      msg: `unexpected request method ${req.method}`
    });
  }
  const contentType = req.headers["content-type"];
  if (!contentType) {
    return new TwirpError({
      code: "malformed",
      msg: "no request content-type provided"
    });
  }
  if (contentType !== "application/json" && contentType !== "application/protobuf") {
    return new TwirpError({
      code: "malformed",
      msg: `unexpected request content-type ${contentType}`
    });
  }
}
function handleError(error, ctx, ee2) {
  ee2.emit("error", ctx, error);
  return TwirpErrorResponse(error);
}
function handleUserSpaceError(error, ctx, ee2) {
  if (error instanceof TwirpError) {
    return handleError(error, ctx, ee2);
  } else {
    ee2.emit("error", ctx, new TwirpError({
      code: "internal",
      msg: "server error",
      // Do expose internal error message in reporting
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
      meta: { error }
    }));
    return TwirpErrorResponse(new TwirpError({
      code: "internal",
      msg: "server error"
    }));
  }
}
function twirpHandler(ee2) {
  return async (req, ctx) => {
    const err = validateRequest(req);
    if (err) {
      return handleError(err, ctx, ee2);
    }
    const handler = ctx.method;
    if (!handler) {
      return handleError(new TwirpError({
        code: "bad_route",
        msg: `no handler for path POST ${req.url}.`
      }), ctx, ee2);
    }
    try {
      const response = await executeServiceMethod(handler, req, ctx, ee2);
      return {
        statusCode: 200,
        headers: {
          "content-type": req.headers["content-type"]
        },
        body: response
      };
    } catch (error) {
      return handleUserSpaceError(error, ctx, ee2);
    }
  };
}
function getContentType(contentType) {
  switch (contentType) {
    case "application/json":
      return "JSON";
    case "application/protobuf":
      return "Protobuf";
    default:
      return "Unknown";
  }
}
function getRequestContext(req, services, config) {
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment , @typescript-eslint/no-explicit-any
    service: void 0,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment , @typescript-eslint/no-explicit-any
    method: void 0,
    contentType: getContentType(req.headers["content-type"])
  };
  const prefix = config.prefix + "/";
  const startsWithPrefix = req.url.startsWith(prefix);
  if (!startsWithPrefix) {
    return ctx;
  }
  const methodIdx = req.url.lastIndexOf("/");
  const serviceName = req.url.slice(prefix.length, methodIdx);
  const serviceMethod = req.url.slice(methodIdx + 1);
  const service = services.find((service2) => service2.name === serviceName);
  const handler = service == null ? void 0 : service.methods[serviceMethod];
  if (handler) {
    ctx.service = service;
    ctx.method = handler;
  }
  return ctx;
}
function lowercaseHeaders(headers) {
  return Object.fromEntries(Object.entries(headers).map(([key, value]) => [key.toLowerCase(), value]));
}
function createTwirpServerless(services, config = {}) {
  const configWithDefaults = {
    debug: true,
    prefix: "/twirp",
    ...config
  };
  const serverMiddleware = [];
  const ee2 = createEventEmitter();
  const twirp = twirpHandler(ee2);
  async function app(rawRequest) {
    const req = {
      ...rawRequest,
      headers: lowercaseHeaders(rawRequest.headers)
    };
    const ctx = getRequestContext(req, services, configWithDefaults);
    ee2.emit("requestReceived", ctx, req);
    let response;
    let idx = 1;
    const middleware = [...serverMiddleware, twirp];
    try {
      response = await middleware[0](req, ctx, function next() {
        const nxt = middleware[idx];
        idx++;
        return nxt(req, ctx, next);
      });
    } catch (error) {
      response = handleUserSpaceError(error, ctx, ee2);
    }
    ee2.emit("responseSent", ctx, response);
    return response;
  }
  app.use = (handler) => {
    serverMiddleware.push(handler);
    return app;
  };
  app.on = (...args) => {
    ee2.on(...args);
    return app;
  };
  app.off = (...args) => {
    ee2.off(...args);
    return app;
  };
  if (configWithDefaults.debug !== false) {
    withRequestLogging(app);
  }
  return app;
}
async function getBody(req) {
  const buffers = [];
  for await (const chunk of req) {
    buffers.push(chunk);
  }
  const length = buffers.reduce((acc, buffer) => acc + buffer.length, 0);
  const body = new Uint8Array(length);
  let offset = 0;
  buffers.forEach((buffer) => {
    body.set(buffer, offset);
    offset += buffer.length;
  });
  return body;
}
function createTwirpServer(services, config = {}) {
  const _app = createTwirpServerless(services, config);
  async function app(req, res) {
    const body = await getBody(req);
    const request = req;
    request.body = body;
    const response = await _app(request);
    res.writeHead(response.statusCode, response.headers);
    res.end(response.body);
  }
  app.use = (handler) => {
    _app.use(handler);
    return app;
  };
  app.on = (...args) => {
    _app.on(...args);
    return app;
  };
  app.off = (...args) => {
    _app.off(...args);
    return app;
  };
  return app;
}

// node_modules/twirpscript/dist/runtime/compatCheck.js
var RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION = "MIN_SUPPORTED_VERSION_0_0_56";
var MIN_SUPPORTED_VERSION_0_0_56 = RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION;
export {
  JSONrequest,
  MIN_SUPPORTED_VERSION_0_0_56,
  PBrequest,
  RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION,
  TwirpError,
  TwirpErrorResponse,
  client,
  createTwirpServer,
  createTwirpServerless
};
//# sourceMappingURL=twirpscript.js.map
